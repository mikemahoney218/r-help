From j@ork|n @end|ng |rom @om@um@ry|@nd@edu  Mon Jul  1 17:54:21 2024
From: j@ork|n @end|ng |rom @om@um@ry|@nd@edu (Sorkin, John)
Date: Mon, 1 Jul 2024 15:54:21 +0000
Subject: [R] Create matrix with variable number of columns AND CREATE NAMES
 FOR THE COLUMNS
Message-ID: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>

#I am trying to write code that will create a matrix with a variable number of columns where the #number of columns is 1+Grps
#I can do this:
NSims <- 4
Grps <- 5
DiffMeans <- matrix(nrow=NSims,ncol=1+Grps)
DiffMeans

#I have a problem when I try to name the columns of the matrix. I want the first column to be NSims, #and the other columns to be something like Value1, Value2, . . . Valuen where N=Grps

# I wrote a function to build a list of length Grps
createValuelist <- function(num_elements) {
  for (i in 1:num_elements) {
    cat("Item", i, "\n", sep = "")
  }
}
createValuelist(Grps)

# When I try to assign column names I receive an error:
#Error in dimnames(DiffMeans) <- list(NULL, c("NSim", createValuelist(Grps))) : 
# length of 'dimnames' [2] not equal to array extent
dimnames(DiffMeans) <- list(NULL,c("NSim",createValuelist(Grps)))
DiffMeans

# Thank you for your help!


John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;?
PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




From tebert @end|ng |rom u||@edu  Mon Jul  1 19:43:36 2024
From: tebert @end|ng |rom u||@edu (Ebert,Timothy Aaron)
Date: Mon, 1 Jul 2024 17:43:36 +0000
Subject: [R] 
 Create matrix with variable number of columns AND CREATE NAMES
 FOR THE COLUMNS
In-Reply-To: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <CH3PR22MB45142BD4D2792E8AEAB11AF4CFD32@CH3PR22MB4514.namprd22.prod.outlook.com>

NSims <- 4
Grps <- 5
DiffMeans <- matrix(nrow=NSims,ncol=1+Grps)
DiffMeans

#I have a problem when I try to name the columns of the matrix. I want the first column to be NSims, #and the other columns to be something like Value1, Value2, . . . Valuen where N=Grps
Colnames <- as.vector("NSims")
num_elements <- ncol(DiffMeans)
for (i in 2:num_elements) {
  Colnames[i] <- paste0("Item",i)
}
colnames(DiffMeans) <- Colnames

You need the vector "Colnames" to have the same number of elements as columns in DiffMeans.
Colnames in created with the first element in place because that will not change.
The loop starts with the second element so that the first element is not overwritten by the for loop.


As a function it might look something like this:
# Name columns is a function that will take a matrix and two strings.
# The first string is the name of the first column.
# The second string is the base part of column names.
#     The function adds a number after the base part.
name_cols <- function(matrix, name1, name2){
  colnames <- as.vector(name1)
  num_elements <- ncol(DiffMeans)
  # I wrote a function to build a list of length Grps createValuelist <- function(num_elements) {
  for (i in 2:num_elements) {
    colnames[i] <- paste0(name2,i)
  }
}

colnames(DiffMeans) <- name_cols(DiffNames,"Book", "Cola")

You can now make the names anything you want for any specific use.
You could add some error checking like making sure the first parameter is a matrix and the other two parmeters are appropriate strings.
If the function will only be called once or twice it might be simpler to not use a function.


Tim
-----Original Message-----
From: R-help <r-help-bounces at r-project.org> On Behalf Of Sorkin, John
Sent: Monday, July 1, 2024 11:54 AM
To: r-help at r-project.org (r-help at r-project.org) <r-help at r-project.org>
Subject: [R] Create matrix with variable number of columns AND CREATE NAMES FOR THE COLUMNS

[External Email]

#I am trying to write code that will create a matrix with a variable number of columns where the #number of columns is 1+Grps #I can do this:
NSims <- 4
Grps <- 5
DiffMeans <- matrix(nrow=NSims,ncol=1+Grps) DiffMeans

#I have a problem when I try to name the columns of the matrix. I want the first column to be NSims, #and the other columns to be something like Value1, Value2, . . . Valuen where N=Grps

# I wrote a function to build a list of length Grps createValuelist <- function(num_elements) {
  for (i in 1:num_elements) {
    cat("Item", i, "\n", sep = "")
  }
}
createValuelist(Grps)

# When I try to assign column names I receive an error:
#Error in dimnames(DiffMeans) <- list(NULL, c("NSim", createValuelist(Grps))) :
# length of 'dimnames' [2] not equal to array extent
dimnames(DiffMeans) <- list(NULL,c("NSim",createValuelist(Grps)))
DiffMeans

# Thank you for your help!


John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine; Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center; PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center; Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382



______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide http://www.r-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Mon Jul  1 19:56:23 2024
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Mon, 1 Jul 2024 18:56:23 +0100
Subject: [R] 
 Create matrix with variable number of columns AND CREATE NAMES
 FOR THE COLUMNS
In-Reply-To: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <78bf05fa-7f80-413e-aa6d-0c0f785c0c49@sapo.pt>

?s 16:54 de 01/07/2024, Sorkin, John escreveu:
> #I am trying to write code that will create a matrix with a variable number of columns where the #number of columns is 1+Grps
> #I can do this:
> NSims <- 4
> Grps <- 5
> DiffMeans <- matrix(nrow=NSims,ncol=1+Grps)
> DiffMeans
> 
> #I have a problem when I try to name the columns of the matrix. I want the first column to be NSims, #and the other columns to be something like Value1, Value2, . . . Valuen where N=Grps
> 
> # I wrote a function to build a list of length Grps
> createValuelist <- function(num_elements) {
>    for (i in 1:num_elements) {
>      cat("Item", i, "\n", sep = "")
>    }
> }
> createValuelist(Grps)
> 
> # When I try to assign column names I receive an error:
> #Error in dimnames(DiffMeans) <- list(NULL, c("NSim", createValuelist(Grps))) :
> # length of 'dimnames' [2] not equal to array extent
> dimnames(DiffMeans) <- list(NULL,c("NSim",createValuelist(Grps)))
> DiffMeans
> 
> # Thank you for your help!
> 
> 
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
> 
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
> 
> 
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
Hello,

Something like this?



names_cols <- function(x, First = "NSims", Prefix = "Value") {
   nms <- c(First, sprintf("%s%d", Prefix, seq_len(ncol(x) - 1L)))
   colnames(x) <- nms
   x
}

NSims <- 4
Grps <- 5
DiffMeans <- matrix(nrow=NSims,ncol=1+Grps)
names_cols(DiffMeans)
#>      NSims Value1 Value2 Value3 Value4 Value5
#> [1,]    NA     NA     NA     NA     NA     NA
#> [2,]    NA     NA     NA     NA     NA     NA
#> [3,]    NA     NA     NA     NA     NA     NA
#> [4,]    NA     NA     NA     NA     NA     NA



Hope this helps,

Rui Barradas


-- 
Este e-mail foi analisado pelo software antiv?rus AVG para verificar a presen?a de v?rus.
www.avg.com


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Mon Jul  1 20:05:32 2024
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Mon, 1 Jul 2024 19:05:32 +0100
Subject: [R] 
 Create matrix with variable number of columns AND CREATE NAMES
 FOR THE COLUMNS
In-Reply-To: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <cbf9861a-2d11-4fb9-86c4-db6387b71af1@sapo.pt>

?s 16:54 de 01/07/2024, Sorkin, John escreveu:
> #I am trying to write code that will create a matrix with a variable number of columns where the #number of columns is 1+Grps
> #I can do this:
> NSims <- 4
> Grps <- 5
> DiffMeans <- matrix(nrow=NSims,ncol=1+Grps)
> DiffMeans
> 
> #I have a problem when I try to name the columns of the matrix. I want the first column to be NSims, #and the other columns to be something like Value1, Value2, . . . Valuen where N=Grps
> 
> # I wrote a function to build a list of length Grps
> createValuelist <- function(num_elements) {
>    for (i in 1:num_elements) {
>      cat("Item", i, "\n", sep = "")
>    }
> }
> createValuelist(Grps)
> 
> # When I try to assign column names I receive an error:
> #Error in dimnames(DiffMeans) <- list(NULL, c("NSim", createValuelist(Grps))) :
> # length of 'dimnames' [2] not equal to array extent
> dimnames(DiffMeans) <- list(NULL,c("NSim",createValuelist(Grps)))
> DiffMeans
> 
> # Thank you for your help!
> 
> 
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
> 
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
> 
> 
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
Hello,

Sorry for my first answer, I thought you only wanted to name the matrix 
columns. After reading the OP again, this time actually reading it, I 
realized you also want to create the matrix. This is even in the 
question title line :(.



create_matrix <- function(nsims, ngrps, First = "NSims", Prefix = "Value") {
   # could also be paste0(Prefix, seq_len(ngrps))
   grp_names <- sprintf("%s%d", Prefix, seq_len(ngrps))
   nms <- c(First, grp_names)
   matrix(nrow = nsims, ncol = 1L + ngrps, dimnames = list(NULL, nms))
}

NSims <- 4
Grps <- 5
create_matrix(NSims, Grps)
#>      NSims Value1 Value2 Value3 Value4 Value5
#> [1,]    NA     NA     NA     NA     NA     NA
#> [2,]    NA     NA     NA     NA     NA     NA
#> [3,]    NA     NA     NA     NA     NA     NA
#> [4,]    NA     NA     NA     NA     NA     NA



Hope this helps,

Rui Barradas


-- 
Este e-mail foi analisado pelo software antiv?rus AVG para verificar a presen?a de v?rus.
www.avg.com


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Mon Jul  1 20:50:09 2024
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Mon, 01 Jul 2024 11:50:09 -0700
Subject: [R] 
 Create matrix with variable number of columns AND CREATE NAMES
 FOR THE COLUMNS
In-Reply-To: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <F4ADB92D-420E-41C8-9EBB-119C1CCC397E@dcn.davis.ca.us>

I think you should reconsider your goal. Matrices must have all elements of the same type, and in this case you seem to be trying to mix a number of something (integer) with mean values (double). This would normally be stored together in a data frame or separately in a vector for counts and a matrix for means.

If you are just thinking about data presentation, a data frame would be a better choice than a single matrix.

On July 1, 2024 8:54:21 AM PDT, "Sorkin, John" <jsorkin at som.umaryland.edu> wrote:
>#I am trying to write code that will create a matrix with a variable number of columns where the #number of columns is 1+Grps
>#I can do this:
>NSims <- 4
>Grps <- 5
>DiffMeans <- matrix(nrow=NSims,ncol=1+Grps)
>DiffMeans
>
>#I have a problem when I try to name the columns of the matrix. I want the first column to be NSims, #and the other columns to be something like Value1, Value2, . . . Valuen where N=Grps
>
># I wrote a function to build a list of length Grps
>createValuelist <- function(num_elements) {
>  for (i in 1:num_elements) {
>    cat("Item", i, "\n", sep = "")
>  }
>}
>createValuelist(Grps)
>
># When I try to assign column names I receive an error:
>#Error in dimnames(DiffMeans) <- list(NULL, c("NSim", createValuelist(Grps))) : 
># length of 'dimnames' [2] not equal to array extent
>dimnames(DiffMeans) <- list(NULL,c("NSim",createValuelist(Grps)))
>DiffMeans
>
># Thank you for your help!
>
>
>John David Sorkin M.D., Ph.D.
>Professor of Medicine, University of Maryland School of Medicine;
>Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;?
>PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
>Senior Statistician University of Maryland Center for Vascular Research;
>
>Division of Gerontology and Paliative Care,
>10 North Greene Street
>GRECC (BT/18/GR)
>Baltimore, MD 21201-1524
>Cell phone 443-418-5382
>
>
>
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.

-- 
Sent from my phone. Please excuse my brevity.


From tuech|er @end|ng |rom gmx@@t  Mon Jul  1 20:55:07 2024
From: tuech|er @end|ng |rom gmx@@t (Heinz Tuechler)
Date: Mon, 1 Jul 2024 20:55:07 +0200
Subject: [R] 
 Create matrix with variable number of columns AND CREATE NAMES
 FOR THE COLUMNS
In-Reply-To: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB50491491431A5556461E7BABE2D32@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <13d92624-cdc5-9cf2-60a5-f76285d93723@gmx.at>

Sorkin, John wrote/hat geschrieben on/am 01.07.2024 17:54:
> #I am trying to write code that will create a matrix with a variable number of columns where the #number of columns is 1+Grps
> #I can do this:
> NSims <- 4
> Grps <- 5
> DiffMeans <- matrix(nrow=NSims,ncol=1+Grps)
> DiffMeans
>
> #I have a problem when I try to name the columns of the matrix. I want the first column to be NSims, #and the other columns to be something like Value1, Value2, . . . Valuen where N=Grps
>
> # I wrote a function to build a list of length Grps
> createValuelist <- function(num_elements) {
>   for (i in 1:num_elements) {
>     cat("Item", i, "\n", sep = "")
>   }
> }
> createValuelist(Grps)
>
> # When I try to assign column names I receive an error:
> #Error in dimnames(DiffMeans) <- list(NULL, c("NSim", createValuelist(Grps))) :
> # length of 'dimnames' [2] not equal to array extent
> dimnames(DiffMeans) <- list(NULL,c("NSim",createValuelist(Grps)))
> DiffMeans
>
> # Thank you for your help!
>
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
maybe:
NSims <- 4
Grps <- 5
DiffMeans <-
     matrix(nrow=NSims,ncol=1+Grps,
            dimnames=list(NULL, c('Nsimn', paste('Item', 1:Grps, sep=''))))
DiffMeans

best,
Heinz

>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


From @@uer @end|ng |rom |mb|@un|-he|de|berg@de  Mon Jul  1 15:33:43 2024
From: @@uer @end|ng |rom |mb|@un|-he|de|berg@de (Sauer, Lukas Daniel)
Date: Mon, 1 Jul 2024 13:33:43 +0000
Subject: [R] summaryRprof: Unexpected unit for memory profiling
Message-ID: <0ead849446304c87ac70ee9cdc492976@imbi.uni-heidelberg.de>

Hello,

I am profiling memory usage using utils::Rprof() and subsequently summarizing the profile using utils::summaryRprof(). According to the documentation ?summaryRprof, the option `memory = "both"` reports "memory consumption in Mb in addition to the timings", i.e. the unit is megabytes. However, looking at the source code (https://github.com/wch/r-source/blob/18652de8890d89563b923ff58b45ccb04d9955fe/src/library/utils/R/summRprof.R#L170) suggests that memory is reported in mebibytes (division by 1048576 and not by 100000). This is in line with the following minimal example:

use_mb <- function(){a <- runif(1000000)}
use_mib <- function(){b <- runif(1024^2)}
Rprof("Rprof.out", memory.profiling=TRUE)
use_mb()
use_mib()
Rprof(NULL)
summaryRprof("Rprof.out", memory="both")

Do not source this code, but execute it line by line. This example returns the output:

$by.self
        self.time self.pct total.time total.pct mem.total
"runif"      0.04      100       0.04       100      15.6

$by.total
          total.time total.pct mem.total self.time self.pct
"runif"         0.04       100      15.6      0.04      100
"use_mb"        0.02        50       7.6      0.00        0
"use_mib"       0.02        50       8.0      0.00        0

$sample.interval
[1] 0.02

$sampling.time
[1] 0.04

The example was run under:

R version 4.4.0 (2024-04-24 ucrt)
Platform: x86_64-w64-mingw32/x64
Running under: Windows 11 x64 (build 22631)

If the unit were megabytes, I would expect mem.total to be 16.4, 8.0, and 8.4 -- but rather it is 15.6, 7.6, and 8.0. Do you agree that this behavior is unexpected or did I overlook something? If yes, I will file a bug report and suggest that the documentation is changed to "memory consumption in MiB in addition to the timings".

Best regards,

Lukas D Sauer
Biometrician
Institute of Medical Biometry

Heidelberg University Hospital | Im Neuenheimer Feld 130.3 | D-69120 Heidelberg
Tel. +49 6221 56-35036 | Fax. +49 6221 56-4195 | E-Mail: sauer at imbi.uni-heidelberg.de
biometrie.uni-heidelberg.de | twitter.com/imbi_heidelberg


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Tue Jul  2 09:05:53 2024
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Tue, 02 Jul 2024 00:05:53 -0700
Subject: [R] summaryRprof: Unexpected unit for memory profiling
In-Reply-To: <0ead849446304c87ac70ee9cdc492976@imbi.uni-heidelberg.de>
References: <0ead849446304c87ac70ee9cdc492976@imbi.uni-heidelberg.de>
Message-ID: <EBF51C4A-6225-419C-B7B7-2EA1B7BB6E09@dcn.davis.ca.us>

There was a time when people pretty much ignored the distinction between MB and MiB in computer applications, and using the binary version was usually assumed because, well, this _is_ memory we are measuring. I think this is a leftover from that time.

On July 1, 2024 6:33:43 AM PDT, "Sauer, Lukas Daniel" <sauer at imbi.uni-heidelberg.de> wrote:
>Hello,
>
>I am profiling memory usage using utils::Rprof() and subsequently summarizing the profile using utils::summaryRprof(). According to the documentation ?summaryRprof, the option `memory = "both"` reports "memory consumption in Mb in addition to the timings", i.e. the unit is megabytes. However, looking at the source code (https://github.com/wch/r-source/blob/18652de8890d89563b923ff58b45ccb04d9955fe/src/library/utils/R/summRprof.R#L170) suggests that memory is reported in mebibytes (division by 1048576 and not by 100000). This is in line with the following minimal example:
>
>use_mb <- function(){a <- runif(1000000)}
>use_mib <- function(){b <- runif(1024^2)}
>Rprof("Rprof.out", memory.profiling=TRUE)
>use_mb()
>use_mib()
>Rprof(NULL)
>summaryRprof("Rprof.out", memory="both")
>
>Do not source this code, but execute it line by line. This example returns the output:
>
>$by.self
>        self.time self.pct total.time total.pct mem.total
>"runif"      0.04      100       0.04       100      15.6
>
>$by.total
>          total.time total.pct mem.total self.time self.pct
>"runif"         0.04       100      15.6      0.04      100
>"use_mb"        0.02        50       7.6      0.00        0
>"use_mib"       0.02        50       8.0      0.00        0
>
>$sample.interval
>[1] 0.02
>
>$sampling.time
>[1] 0.04
>
>The example was run under:
>
>R version 4.4.0 (2024-04-24 ucrt)
>Platform: x86_64-w64-mingw32/x64
>Running under: Windows 11 x64 (build 22631)
>
>If the unit were megabytes, I would expect mem.total to be 16.4, 8.0, and 8.4 -- but rather it is 15.6, 7.6, and 8.0. Do you agree that this behavior is unexpected or did I overlook something? If yes, I will file a bug report and suggest that the documentation is changed to "memory consumption in MiB in addition to the timings".
>
>Best regards,
>
>Lukas D Sauer
>Biometrician
>Institute of Medical Biometry
>
>Heidelberg University Hospital | Im Neuenheimer Feld 130.3 | D-69120 Heidelberg
>Tel. +49 6221 56-35036 | Fax. +49 6221 56-4195 | E-Mail: sauer at imbi.uni-heidelberg.de
>biometrie.uni-heidelberg.de | twitter.com/imbi_heidelberg
>
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.

-- 
Sent from my phone. Please excuse my brevity.


From tr|ng @end|ng |rom gvdnet@dk  Wed Jul  3 10:13:59 2024
From: tr|ng @end|ng |rom gvdnet@dk (Troels Ring)
Date: Wed, 3 Jul 2024 10:13:59 +0200
Subject: [R] simple problem with unquoting argument
Message-ID: <5bd7164c-315e-458b-913a-164dfd336d4b@gvdnet.dk>

Hi? friends - I'm in problems finding out how to unquote - I have a 
series of vectors named adds1....adds11 and need to e.g. find the sum of 
each of them

So I try

SS <- c()

for (i in 1:11) {

e <- paste("adds",i,sep="")

SS[i]? <- sum(xx(e)) }

Now e looks right - but I have been unable to find out how to get the 
string e converted to the proper argument for sum()? - i.e. what? is 
function xx?

All best wishes
Troels Ring, Aalborg, Denmark


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Wed Jul  3 10:24:21 2024
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Wed, 3 Jul 2024 09:24:21 +0100
Subject: [R] simple problem with unquoting argument
In-Reply-To: <5bd7164c-315e-458b-913a-164dfd336d4b@gvdnet.dk>
References: <5bd7164c-315e-458b-913a-164dfd336d4b@gvdnet.dk>
Message-ID: <26ef9ed0-e712-4847-8c09-c6fbd17a31c6@sapo.pt>

?s 09:13 de 03/07/2024, Troels Ring escreveu:
> Hi? friends - I'm in problems finding out how to unquote - I have a 
> series of vectors named adds1....adds11 and need to e.g. find the sum of 
> each of them
> 
> So I try
> 
> SS <- c()
> 
> for (i in 1:11) {
> 
> e <- paste("adds",i,sep="")
> 
> SS[i]? <- sum(xx(e)) }
> 
> Now e looks right - but I have been unable to find out how to get the 
> string e converted to the proper argument for sum()? - i.e. what? is 
> function xx?
> 
> All best wishes
> Troels Ring, Aalborg, Denmark
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide 
> http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
Hello,

Function xx is ?get or mget (same help page).
You can get the vectors adds all in one instruction with mget or one at 
a time with get.


adds1 <- 1:10
adds2 <- 2:10
adds3 <- 3:10
adds4 <- 4:10
adds5 <- 5:10

# create SS with the required length beforehand
SS <- numeric(5L)
for (i in 1:5) {
   e <- paste("adds",i,sep="")
   SS[i]  <- sum(get(e))
}
SS
#> [1] 55 54 52 49 45


Or all in one instruction with the assistance of ?ls.



# ls(pattern = "^adds") |> mget() |> lapply(sum)
ls(pattern = "^adds") |> mget() |> sapply(sum)
#> adds1 adds2 adds3 adds4 adds5
#>    55    54    52    49    45


Hope this helps,

Rui Barradas


-- 
Este e-mail foi analisado pelo software antiv?rus AVG para verificar a presen?a de v?rus.
www.avg.com


From |kry|ov @end|ng |rom d|@root@org  Wed Jul  3 10:25:02 2024
From: |kry|ov @end|ng |rom d|@root@org (Ivan Krylov)
Date: Wed, 3 Jul 2024 11:25:02 +0300
Subject: [R] simple problem with unquoting argument
In-Reply-To: <5bd7164c-315e-458b-913a-164dfd336d4b@gvdnet.dk>
References: <5bd7164c-315e-458b-913a-164dfd336d4b@gvdnet.dk>
Message-ID: <20240703112502.2fd088f3@Tarkus>

? Wed, 3 Jul 2024 10:13:59 +0200
Troels Ring <tring at gvdnet.dk> ?????:

> Now e looks right - but I have been unable to find out how to get the 
> string e converted to the proper argument for sum()? - i.e. what? is 
> function xx?

get(e) will return the value of the variable with the name stored in
the variable e.

A more idiomatic variant will require more changes:

1. Create the "adds" variable as a list, so that it could contain other
arbitrary R values:

adds <- list()

2. Instead of assigning adds1 <- something(), adds2 <-
something_else(), ..., assign to the elements of the list:

adds[[1]] <- something()
adds[[2]] <- something_else()
...

3. Now you can use the same syntax to access the elements of the list:

SS[i] <- sum(adds[[i]])

As a bonus, you can use the "apply" family of R functions that will
perform the loop for you: instead of SS <- c(); for (i in 1:11) SS[i]
<- sum(adds[[i]]) you can write

SS <- vapply(adds, sum, numeric(1))

...and it will perform the same loop inside it, verifying each time
that sum(adds[[i]]) returns a single number.

-- 
Best regards,
Ivan

P.S. I'm sorry for letting our project lapse.


From tr|ng @end|ng |rom gvdnet@dk  Wed Jul  3 16:16:23 2024
From: tr|ng @end|ng |rom gvdnet@dk (Troels Ring)
Date: Wed, 3 Jul 2024 16:16:23 +0200
Subject: [R] simple problem with unquoting argument
In-Reply-To: <20240703112502.2fd088f3@Tarkus>
References: <5bd7164c-315e-458b-913a-164dfd336d4b@gvdnet.dk>
 <20240703112502.2fd088f3@Tarkus>
Message-ID: <8364b241-9166-4b5a-bf9a-499a412e0e9e@gvdnet.dk>

Dear Ivan and Rui - thanks a lot for the effective help.

All best wishes Troels

Den 03-07-2024 kl. 10:25 skrev Ivan Krylov:
> ? Wed, 3 Jul 2024 10:13:59 +0200
> Troels Ring <tring at gvdnet.dk> ?????:
>
>> Now e looks right - but I have been unable to find out how to get the
>> string e converted to the proper argument for sum()? - i.e. what? is
>> function xx?
> get(e) will return the value of the variable with the name stored in
> the variable e.
>
> A more idiomatic variant will require more changes:
>
> 1. Create the "adds" variable as a list, so that it could contain other
> arbitrary R values:
>
> adds <- list()
>
> 2. Instead of assigning adds1 <- something(), adds2 <-
> something_else(), ..., assign to the elements of the list:
>
> adds[[1]] <- something()
> adds[[2]] <- something_else()
> ...
>
> 3. Now you can use the same syntax to access the elements of the list:
>
> SS[i] <- sum(adds[[i]])
>
> As a bonus, you can use the "apply" family of R functions that will
> perform the loop for you: instead of SS <- c(); for (i in 1:11) SS[i]
> <- sum(adds[[i]]) you can write
>
> SS <- vapply(adds, sum, numeric(1))
>
> ...and it will perform the same loop inside it, verifying each time
> that sum(adds[[i]]) returns a single number.
>


From r-m@||@ @end|ng |rom erez@h@org  Fri Jul  5 13:35:40 2024
From: r-m@||@ @end|ng |rom erez@h@org (Erez Shomron)
Date: Fri, 05 Jul 2024 14:35:40 +0300
Subject: [R] Bug? plot.formula does need support plot.first / plot.last
 param in plot.default
Message-ID: <a9dd2c4c-953d-4d3b-9480-06bc3454df7f@app.fastmail.com>

Is the following a bug in your opinion? I think so.

This works as expected:

```
with(mtcars, plot(wt, mpg, plot.first = {
    plot.window(range(wt), range(mpg))
    arrows(3, 15, 4, 30)
}))
```

This does not.

```
plot(mpg ~ wt, data = mtcars, plot.first = {
    plot.window(range(wt), range(mpg))
    arrows(3, 15, 4, 30)
})
```

With error:
```
Error in arrows(3, 15, 4, 30) : plot.new has not been called yet
```

The second example should work.

>From the docs:

?plot.formula
"     For the ?plot? method the formula can be of the form ?~ z + y +
     z?: the variables specified on the right-hand side are collected
     into a data frame, subsetted if specified, and displayed by
     ?plot.data.frame?.
"

?plot.data.frame
"     ...: further arguments to ?stripchart?, ?plot.default? or ?pairs?.
"

And plot.default has both plot.first and plot.last

It seems very arbitrary you can't use these parameters with the plot.formula method specifically.

> sessionInfo()
R version 4.4.1 (2024-06-14)
Platform: x86_64-suse-linux-gnu
Running under: openSUSE Tumbleweed
[...]


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Jul  6 00:05:50 2024
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Fri, 5 Jul 2024 18:05:50 -0400
Subject: [R] Bug? plot.formula does need support plot.first / plot.last
 param in plot.default
In-Reply-To: <a9dd2c4c-953d-4d3b-9480-06bc3454df7f@app.fastmail.com>
References: <a9dd2c4c-953d-4d3b-9480-06bc3454df7f@app.fastmail.com>
Message-ID: <83c5f0f0-8193-436b-94b5-d4570d1db03f@gmail.com>

That definitely looks like a bug, but not one that anyone will be eager 
to fix.  It's very old code that tried to be clever, and that's the 
hardest kind of code to fix.

Remember Kernighan's Law:  "Everyone knows that debugging is twice as 
hard as writing a program in the first place. So if you?re as clever as 
you can be when you write it, how will you ever debug it?"

Duncan Murdoch

On 2024-07-05 7:35 a.m., Erez Shomron wrote:
> Is the following a bug in your opinion? I think so.
> 
> This works as expected:
> 
> ```
> with(mtcars, plot(wt, mpg, plot.first = {
>      plot.window(range(wt), range(mpg))
>      arrows(3, 15, 4, 30)
> }))
> ```
> 
> This does not.
> 
> ```
> plot(mpg ~ wt, data = mtcars, plot.first = {
>      plot.window(range(wt), range(mpg))
>      arrows(3, 15, 4, 30)
> })
> ```
> 
> With error:
> ```
> Error in arrows(3, 15, 4, 30) : plot.new has not been called yet
> ```
> 
> The second example should work.
> 
>  From the docs:
> 
> ?plot.formula
> "     For the ?plot? method the formula can be of the form ?~ z + y +
>       z?: the variables specified on the right-hand side are collected
>       into a data frame, subsetted if specified, and displayed by
>       ?plot.data.frame?.
> "
> 
> ?plot.data.frame
> "     ...: further arguments to ?stripchart?, ?plot.default? or ?pairs?.
> "
> 
> And plot.default has both plot.first and plot.last
> 
> It seems very arbitrary you can't use these parameters with the plot.formula method specifically.
> 
>> sessionInfo()
> R version 4.4.1 (2024-06-14)
> Platform: x86_64-suse-linux-gnu
> Running under: openSUSE Tumbleweed
> [...]
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From r-m@||@ @end|ng |rom erez@h@org  Sat Jul  6 08:15:56 2024
From: r-m@||@ @end|ng |rom erez@h@org (Erez Shomron)
Date: Sat, 06 Jul 2024 09:15:56 +0300
Subject: [R] Bug? plot.formula does need support plot.first / plot.last
 param in plot.default
In-Reply-To: <83c5f0f0-8193-436b-94b5-d4570d1db03f@gmail.com>
References: <a9dd2c4c-953d-4d3b-9480-06bc3454df7f@app.fastmail.com>
 <83c5f0f0-8193-436b-94b5-d4570d1db03f@gmail.com>
Message-ID: <453eb9fd-0a17-4b94-80c2-f679c0807dcc@app.fastmail.com>

Thanks for your answer.

Should I report in Bugzilla at least so it's tracked?

I can point that the issue is with line 6 of the function body:
```
    dots <- lapply(m$..., eval, md, eframe)
```

I assume the intention was to evaluate the arguments with the context of data passed to the function.
But the expression in panel.first / panel.last gets evaluated before plot.new is called (as the error indicates).

I believe the fix would be to somehow not evaluate line 6, or replace with `dots <- m$...`, and when `plot` is later called, to somehow evaluate it with the data passed to the function. I tried to add `envir` argument to `do.call` but it does not work as I expected.

I would've liked to contribute a patch but my R knowledge is limited and and this `plot.formula` code is a bit of my head frankly.

Kindly,
Erez


On Sat, Jul 6, 2024, at 1:05 AM, Duncan Murdoch wrote:
> That definitely looks like a bug, but not one that anyone will be eager 
> to fix.  It's very old code that tried to be clever, and that's the 
> hardest kind of code to fix.
> 
> Remember Kernighan's Law:  "Everyone knows that debugging is twice as 
> hard as writing a program in the first place. So if you?re as clever as 
> you can be when you write it, how will you ever debug it?"
> 
> Duncan Murdoch
> 
> On 2024-07-05 7:35 a.m., Erez Shomron wrote:
> > Is the following a bug in your opinion? I think so.
> > 
> > This works as expected:
> > 
> > ```
> > with(mtcars, plot(wt, mpg, plot.first = {
> >      plot.window(range(wt), range(mpg))
> >      arrows(3, 15, 4, 30)
> > }))
> > ```
> > 
> > This does not.
> > 
> > ```
> > plot(mpg ~ wt, data = mtcars, plot.first = {
> >      plot.window(range(wt), range(mpg))
> >      arrows(3, 15, 4, 30)
> > })
> > ```
> > 
> > With error:
> > ```
> > Error in arrows(3, 15, 4, 30) : plot.new has not been called yet
> > ```
> > 
> > The second example should work.
> > 
> >  From the docs:
> > 
> > ?plot.formula
> > "     For the ?plot? method the formula can be of the form ?~ z + y +
> >       z?: the variables specified on the right-hand side are collected
> >       into a data frame, subsetted if specified, and displayed by
> >       ?plot.data.frame?.
> > "
> > 
> > ?plot.data.frame
> > "     ...: further arguments to ?stripchart?, ?plot.default? or ?pairs?.
> > "
> > 
> > And plot.default has both plot.first and plot.last
> > 
> > It seems very arbitrary you can't use these parameters with the plot.formula method specifically.
> > 
> >> sessionInfo()
> > R version 4.4.1 (2024-06-14)
> > Platform: x86_64-suse-linux-gnu
> > Running under: openSUSE Tumbleweed
> > [...]
> > 
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.
> 
> 


From @te|@no@@o||@ @end|ng |rom reg|one@m@rche@|t  Sat Jul  6 15:02:48 2024
From: @te|@no@@o||@ @end|ng |rom reg|one@m@rche@|t (Stefano Sofia)
Date: Sat, 6 Jul 2024 13:02:48 +0000
Subject: [R] add only the 1st of May with POSIXct
In-Reply-To: <878qztdtz9.fsf@enricoschumann.net>
References: <e558a289b0ee415e83939fc5e9bfdb41@regione.marche.it>,
 <878qztdtz9.fsf@enricoschumann.net>
Message-ID: <e566396a3e7649c8a71a20c2558afff5@regione.marche.it>

Sorry for the delay of my answer.

Enrico and Rui, thank you for your help.

Both solutions worked well, in particular Enrico's hint is very easy to implement.


Thank you

Stefano


         (oo)
--oOO--( )--OOo--------------------------------------
Stefano Sofia PhD
Civil Protection - Marche Region - Italy
Meteo Section
Snow Section
Via del Colle Ameno 5
60126 Torrette di Ancona, Ancona (AN)
Uff: +39 071 806 7743
E-mail: stefano.sofia at regione.marche.it
---Oo---------oO----------------------------------------


________________________________
Da: Enrico Schumann <es at enricoschumann.net>
Inviato: mercoled? 29 maggio 2024 08:15
A: Stefano Sofia
Cc: r-help at R-project.org
Oggetto: Re: [R] add only the 1st of May with POSIXct

[Non ricevi spesso messaggi di posta elettronica da es at enricoschumann.net. Per informazioni sull'importanza di questo fatto, visita https://aka.ms/LearnAboutSenderIdentification.]

On Tue, 28 May 2024, Stefano Sofia writes:

> Dear R-list users,
>
> From an initial and a final date I create a sequence of days using POSIXct.
>
> If this interval covers all or only in part the months from May to October, I need to get rid of the days from the 2nd of May to the 31st of October:
>
>
> a <- as.POSIXct("2002-11-01", format = "%Y-%m-%d", tz="Etc/GMT-1")
>
> b <- as.POSIXct("2004-06-01", format = "%Y-%m-%d", tz="Etc/GMT-1")
>
> mydf <- data.frame(data_POSIX=seq(as.POSIXct(paste(format(a, "%Y-%m-%d"), "09:00:00", sep=""), format="%Y-%m-%d %H:%M:%S", tz="Etc/GMT-1"), as.POSIXct(paste(format(b, "%Y-%m-%d"), "09:00:00", sep=""), format="%Y-%m-%d %H:%M:%S", tz="Etc/GMT-1"), by="1 day"))
>
>
> If I execute
>
> as.data.frame(mydf[format(mydf$data_POSIX,"%m") %in% c("11", "12", "01", "02", "03", "04"), ])
>
> the interval will be
>
> from 2002-11-01 09:00:00 to 2003-04-30 09:00:00
>
> and from 2003-11-01 09:00:00 to 2004-04-30 09:00:00
>
>
> but I need also 2003-05-01 09:00:00 and 2004-05-01 09:00:00
>
>
> How can I solve this problem?
>
>
> Thank you for your attention and your help
>
> Stefano
>

I think this could be simplified a bit:

    a <- as.POSIXct("2002-11-01 09", format = "%Y-%m-%d %H", tz="Etc/GMT-1")
    b <- as.POSIXct("2004-06-01 09", format = "%Y-%m-%d %H", tz="Etc/GMT-1")

Create your sequence:

    S <- seq(a, b , by = "1 day")
    month.day <- format(S, "%m-%d")

Now subset S for those days that you want:

    S[month.day <= "05-01" | month.day > "10-31"]


--
Enrico Schumann
Lucerne, Switzerland
https://eur02.safelinks.protection.outlook.com/?url=http%3A%2F%2Fenricoschumann.net%2F&data=05%7C02%7Cstefano.sofia%40regione.marche.it%7Cfb03eb5bf2e24b4b76b408dc7fa6b98e%7C295eaa1431a14b09bfe65a338b679f60%7C0%7C0%7C638525601265102204%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C0%7C%7C%7C&sdata=46TUwFWwpLcdtZGARpDkhnuHhgZ546khJI%2FONPeYXe4%3D&reserved=0

________________________________

AVVISO IMPORTANTE: Questo messaggio di posta elettronica pu? contenere informazioni confidenziali, pertanto ? destinato solo a persone autorizzate alla ricezione. I messaggi di posta elettronica per i client di Regione Marche possono contenere informazioni confidenziali e con privilegi legali. Se non si ? il destinatario specificato, non leggere, copiare, inoltrare o archiviare questo messaggio. Se si ? ricevuto questo messaggio per errore, inoltrarlo al mittente ed eliminarlo completamente dal sistema del proprio computer. Ai sensi dell'art. 6 della DGR n. 1394/2008 si segnala che, in caso di necessit? ed urgenza, la risposta al presente messaggio di posta elettronica pu? essere visionata da persone estranee al destinatario.
IMPORTANT NOTICE: This e-mail message is intended to be received only by persons entitled to receive the confidential information it may contain. E-mail messages to clients of Regione Marche may contain information that is confidential and legally privileged. Please do not read, copy, forward, or store this message unless you are an intended recipient of it. If you have received this message in error, please forward it to the sender and delete it completely from your computer system.

	[[alternative HTML version deleted]]


From |kry|ov @end|ng |rom d|@root@org  Sat Jul  6 16:24:38 2024
From: |kry|ov @end|ng |rom d|@root@org (Ivan Krylov)
Date: Sat, 6 Jul 2024 17:24:38 +0300
Subject: [R] Bug? plot.formula does need support plot.first / plot.last
 param in plot.default
In-Reply-To: <a9dd2c4c-953d-4d3b-9480-06bc3454df7f@app.fastmail.com>
References: <a9dd2c4c-953d-4d3b-9480-06bc3454df7f@app.fastmail.com>
Message-ID: <20240706172438.2b4340c5@parabola>

? Fri, 05 Jul 2024 14:35:40 +0300
"Erez Shomron" <r-mails at erezsh.org> ?????:

> This works as expected:

> with(mtcars, plot(wt, mpg, plot.first = {
>     plot.window(range(wt), range(mpg))
>     arrows(3, 15, 4, 30)
> }))

I think you meant panel.first, not plot.first. At least I cannot find
any mention of plot.first in the R source code. In this example,
plot.first ends up being an argument of an internal call from
plot.default() to plot.window(), which evaluates its ellipsis
arguments. If your plot.first expression returned a non-NULL value, you
would also have received a warning:

plot.window(0:1, 0:1, plot.first = message('hello'))
# hello
plot.window(0:1, 0:1, plot.first = 123)
# Warning message:
# In plot.window(0:1, 0:1, plot.first = 123) :
#   "plot.first" is not a graphical parameter

It is indeed documented that "passing [panel.first] from other ?plot?
methods may well not work since it may be evaluated too early". The
plot.formula method deliberately evaluates the arguments in the
ellipsis, and the workaround suggested in
https://bugs.r-project.org/show_bug.cgi?id=14591 doesn't help because
the expression is then evaluated in an undesired environment (parent
frame, not data).

You are correct that plot.formula tries to evaluate all its remaining
arguments in the context of the data passed to the method. In order for
the lazy evaluation to work, plot.formula would have to (1) know and
skip all such arguments by name on line 6, minding partial matching, (2)
rewrite them into the form evalq(original_argument_expression,
model_frame, parent_frame) so that they would be able to access both
the data and the variables visible in the frame of the caller, and (3)
give these expressions to do.call() in place of the original ones.

(1) sounds especially brittle since plot.formula() may dispatch to
other plot.* methods. Additionally, great care will need to be taken
not to break existing code that calls plot.formula, even if it's
already full of workarounds for plot.formula's behaviour.

-- 
Best regards,
Ivan


From r-m@||@ @end|ng |rom erez@h@org  Sat Jul  6 16:55:34 2024
From: r-m@||@ @end|ng |rom erez@h@org (Erez Shomron)
Date: Sat, 06 Jul 2024 17:55:34 +0300
Subject: [R] Bug? plot.formula does need support plot.first / plot.last
 param in plot.default
In-Reply-To: <20240706172438.2b4340c5@parabola>
References: <a9dd2c4c-953d-4d3b-9480-06bc3454df7f@app.fastmail.com>
 <20240706172438.2b4340c5@parabola>
Message-ID: <308fc620-a977-4c0d-a305-64ac660b32cf@app.fastmail.com>

Thank you Ivan,

Yes I meant `panel.first`.
I fumbled the title and the examples, but the end result is the same:

```
# Works
with(mtcars, plot(wt, mpg, panel.first = {
    arrows(3, 15, 4, 30)
}))

# Doesn't work
plot(mpg ~ wt, data = mtcars, panel.first = {
    arrows(3, 15, 4, 30)
})

```

I saw the bug reported 13 years ago after-the-fact, and the paragraph I missed for the manual entry.
Thanks for clarifying both.

I do think making these arguments lazy evaluate would be a welcome change. It's especially confusing for new R users trying to use base graphics to plot their linear model. But I also understand this would be low priority as user workaround is simple (don't use the formula method), and because of the testing effort that would be required.

Maybe a warning would be nice, telling users that `panel.first` and `panel.last` are evaluated before plotting. I think users would check `?plot` before `?plot.formula` and would not see any reason not to try and pass these arguments.

Kind Regards,
Erez

On Sat, Jul 6, 2024, at 5:24 PM, Ivan Krylov wrote:
> ? Fri, 05 Jul 2024 14:35:40 +0300
> "Erez Shomron" <r-mails at erezsh.org> ?????:
> 
> > This works as expected:
> 
> > with(mtcars, plot(wt, mpg, plot.first = {
> >     plot.window(range(wt), range(mpg))
> >     arrows(3, 15, 4, 30)
> > }))
> 
> I think you meant panel.first, not plot.first. At least I cannot find
> any mention of plot.first in the R source code. In this example,
> plot.first ends up being an argument of an internal call from
> plot.default() to plot.window(), which evaluates its ellipsis
> arguments. If your plot.first expression returned a non-NULL value, you
> would also have received a warning:
> 
> plot.window(0:1, 0:1, plot.first = message('hello'))
> # hello
> plot.window(0:1, 0:1, plot.first = 123)
> # Warning message:
> # In plot.window(0:1, 0:1, plot.first = 123) :
> #   "plot.first" is not a graphical parameter
> 
> It is indeed documented that "passing [panel.first] from other ?plot?
> methods may well not work since it may be evaluated too early". The
> plot.formula method deliberately evaluates the arguments in the
> ellipsis, and the workaround suggested in
> https://bugs.r-project.org/show_bug.cgi?id=14591 doesn't help because
> the expression is then evaluated in an undesired environment (parent
> frame, not data).
> 
> You are correct that plot.formula tries to evaluate all its remaining
> arguments in the context of the data passed to the method. In order for
> the lazy evaluation to work, plot.formula would have to (1) know and
> skip all such arguments by name on line 6, minding partial matching, (2)
> rewrite them into the form evalq(original_argument_expression,
> model_frame, parent_frame) so that they would be able to access both
> the data and the variables visible in the frame of the caller, and (3)
> give these expressions to do.call() in place of the original ones.
> 
> (1) sounds especially brittle since plot.formula() may dispatch to
> other plot.* methods. Additionally, great care will need to be taken
> not to break existing code that calls plot.formula, even if it's
> already full of workarounds for plot.formula's behaviour.
> 
> -- 
> Best regards,
> Ivan
> 


