From j@p@rk4 @end|ng |rom u|c@edu  Sun Jan  5 17:58:16 2025
From: j@p@rk4 @end|ng |rom u|c@edu (Sparks, John)
Date: Sun, 5 Jan 2025 16:58:16 +0000
Subject: [R] Using library(TTR) Calculate ATR by Symbol
Message-ID: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>

Hi,

In looking at the documentation for the TTR library and particularly the example for calculating the ATR (average true range).  The example shows how to calculate ATR for a file of a single stock.

If I have multiple stocks in one file, isn't there a way to get the ATR for each of them?  Or does one have to break out each stock and calculate the ATR separately using some sort of loop.

In terms of a reproducible example, the file below contains open, high, low, close, etc. for AAPL and then MSFT.

If the ATR calculation were fully working, then there would be blanks for records 41 through 54 and then the ATR calculation would start up again.

Guidance would be very much appreciated.

--John Sparks


Hist<-
structure(list(symbol = c("AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
"AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
"AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
"AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
"AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
"AAPL", "AAPL", "AAPL", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
"MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
"MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
"MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
"MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
"MSFT", "MSFT", "MSFT"), date = structure(c(20033, 20034, 20035,
20038, 20039, 20040, 20041, 20042, 20045, 20046, 20047, 20048,
20049, 20052, 20053, 20054, 20056, 20059, 20060, 20061, 20062,
20063, 20066, 20067, 20068, 20069, 20070, 20073, 20074, 20075,
20076, 20077, 20080, 20081, 20083, 20084, 20087, 20088, 20090,
20091, 20033, 20034, 20035, 20038, 20039, 20040, 20041, 20042,
20045, 20046, 20047, 20048, 20049, 20052, 20053, 20054, 20056,
20059, 20060, 20061, 20062, 20063, 20066, 20067, 20068, 20069,
20070, 20073, 20074, 20075, 20076, 20077, 20080, 20081, 20083,
20084, 20087, 20088, 20090, 20091), class = "Date"), open = c(222.61,
224.63, 227.17, 225, 224.55, 224.01, 225.02, 226.4, 225.25, 226.98,
228.06, 228.88, 228.06, 231.46, 233.33, 234.47, 234.81, 237.27,
239.81, 242.87, 243.99, 242.91, 241.83, 246.89, 247.96, 246.89,
247.82, 247.99, 250.08, 252.16, 247.5, 248.04, 254.77, 255.49,
258.19, 257.83, 252.23, 252.44, 248.93, 243.36, 412.42, 421.28,
425.32, 422.52, 418.25, 421.64, 425, 419.82, 414.87, 413.11,
416.87, 419.5, 411.37, 418.38, 419.59, 425.11, 420.09, 421.57,
429.84, 433.03, 437.92, 442.3, 442.6, 444.39, 444.05, 449.11,
448.44, 447.27, 451.01, 451.32, 441.62, 433.11, 436.74, 434.65,
439.08, 434.6, 426.06, 426.1, 425.53, 421.08), high = c(226.07,
227.88, 228.66, 225.7, 225.59, 226.65, 228.87, 226.92, 229.74,
230.16, 229.93, 230.16, 230.72, 233.25, 235.57, 235.69, 237.81,
240.79, 242.76, 244.11, 244.54, 244.63, 247.24, 248.21, 250.8,
248.74, 249.29, 251.38, 253.83, 254.28, 252, 255, 255.65, 258.21,
260.1, 258.7, 253.5, 253.28, 249.1, 244.18, 420.45, 426.85, 426.5,
424.81, 424.44, 429.33, 428.17, 422.8, 418.4, 417.94, 417.29,
419.78, 417.4, 421.08, 429.04, 427.23, 424.88, 433, 432.47, 439.67,
444.66, 446.1, 448.33, 449.62, 450.35, 456.16, 451.43, 452.18,
455.29, 452.65, 443.18, 443.74, 437.65, 439.6, 440.94, 435.22,
427.55, 426.73, 426.07, 424.03), low = c(221.19, 224.57, 226.41,
221.5, 223.36, 222.76, 225, 224.27, 225.17, 226.66, 225.89, 225.71,
228.06, 229.74, 233.33, 233.81, 233.97, 237.16, 238.9, 241.25,
242.13, 242.08, 241.75, 245.34, 246.26, 245.68, 246.24, 247.65,
249.78, 247.74, 247.09, 245.69, 253.45, 255.29, 257.63, 253.06,
250.75, 249.43, 241.82, 241.89, 410.52, 419.88, 421.78, 416,
417.2, 418.21, 420, 413.64, 412.1, 411.55, 410.58, 410.29, 411.06,
414.85, 418.85, 422.02, 417.8, 421.31, 427.74, 432.63, 436.17,
441.77, 440.5, 441.6, 444.05, 449.11, 445.58, 445.28, 449.57,
437.02, 436.32, 428.63, 432.83, 434.19, 436.63, 426.35, 421.9,
420.66, 414.85, 419.54), close = c(222.72, 227.48, 226.96, 224.23,
224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
250.42, 243.85, 243.36, 420.18, 425.43, 422.54, 418.01, 423.03,
425.2, 426.89, 415, 415.76, 417.79, 415.49, 412.87, 417, 418.79,
427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62, 443.57,
446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46, 437.39,
437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83, 421.5,
418.58, 423.35), adjClose = c(222.48, 227.23, 226.96, 224.23,
224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
250.42, 243.85, 243.36, 419.34, 424.58, 421.7, 417.17, 422.18,
424.35, 426.04, 414.17, 414.93, 416.96, 414.66, 412.87, 417,
418.79, 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62,
443.57, 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46,
437.39, 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83,
421.5, 418.58, 423.35)), class = "data.frame", row.names = c(NA,
-80L))

library(TTR)
atr <- ATR(Hist[,c("high","low","close")], n=14)
atr






	[[alternative HTML version deleted]]


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Sun Jan  5 18:31:16 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 5 Jan 2025 11:31:16 -0600
Subject: [R] Using library(TTR) Calculate ATR by Symbol
In-Reply-To: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
References: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
Message-ID: <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>

Hi,

TTR/xts/quantmod maintainer here.

On Sun, Jan 5, 2025 at 10:58?AM Sparks, John <jspark4 at uic.edu> wrote:
>
> Hi,
>
> In looking at the documentation for the TTR library and particularly the
> example for calculating the ATR (average true range).  The example shows
> how to calculate ATR for a file of a single stock.
>
> If I have multiple stocks in one file, isn't there a way to get the ATR
> for each of them?  Or does one have to break out each stock and calculate
> the ATR separately using some sort of loop.
>
Yes, the TTR functions only work on a single stock at a time.

> In terms of a reproducible example, the file below contains open, high,
> low, close, etc. for AAPL and then MSFT.
>
Thanks for the reproducible data!

> If the ATR calculation were fully working, then there would be blanks for
> records 41 through 54 and then the ATR calculation would start up again.
>
> Guidance would be very much appreciated.
>
> --John Sparks
>
>
> Hist<-
> structure(list(symbol = c("AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT"), date = structure(c(20033, 20034, 20035,
> 20038, 20039, 20040, 20041, 20042, 20045, 20046, 20047, 20048,
> 20049, 20052, 20053, 20054, 20056, 20059, 20060, 20061, 20062,
> 20063, 20066, 20067, 20068, 20069, 20070, 20073, 20074, 20075,
> 20076, 20077, 20080, 20081, 20083, 20084, 20087, 20088, 20090,
> 20091, 20033, 20034, 20035, 20038, 20039, 20040, 20041, 20042,
> 20045, 20046, 20047, 20048, 20049, 20052, 20053, 20054, 20056,
> 20059, 20060, 20061, 20062, 20063, 20066, 20067, 20068, 20069,
> 20070, 20073, 20074, 20075, 20076, 20077, 20080, 20081, 20083,
> 20084, 20087, 20088, 20090, 20091), class = "Date"), open = c(222.61,
> 224.63, 227.17, 225, 224.55, 224.01, 225.02, 226.4, 225.25, 226.98,
> 228.06, 228.88, 228.06, 231.46, 233.33, 234.47, 234.81, 237.27,
> 239.81, 242.87, 243.99, 242.91, 241.83, 246.89, 247.96, 246.89,
> 247.82, 247.99, 250.08, 252.16, 247.5, 248.04, 254.77, 255.49,
> 258.19, 257.83, 252.23, 252.44, 248.93, 243.36, 412.42, 421.28,
> 425.32, 422.52, 418.25, 421.64, 425, 419.82, 414.87, 413.11,
> 416.87, 419.5, 411.37, 418.38, 419.59, 425.11, 420.09, 421.57,
> 429.84, 433.03, 437.92, 442.3, 442.6, 444.39, 444.05, 449.11,
> 448.44, 447.27, 451.01, 451.32, 441.62, 433.11, 436.74, 434.65,
> 439.08, 434.6, 426.06, 426.1, 425.53, 421.08), high = c(226.07,
> 227.88, 228.66, 225.7, 225.59, 226.65, 228.87, 226.92, 229.74,
> 230.16, 229.93, 230.16, 230.72, 233.25, 235.57, 235.69, 237.81,
> 240.79, 242.76, 244.11, 244.54, 244.63, 247.24, 248.21, 250.8,
> 248.74, 249.29, 251.38, 253.83, 254.28, 252, 255, 255.65, 258.21,
> 260.1, 258.7, 253.5, 253.28, 249.1, 244.18, 420.45, 426.85, 426.5,
> 424.81, 424.44, 429.33, 428.17, 422.8, 418.4, 417.94, 417.29,
> 419.78, 417.4, 421.08, 429.04, 427.23, 424.88, 433, 432.47, 439.67,
> 444.66, 446.1, 448.33, 449.62, 450.35, 456.16, 451.43, 452.18,
> 455.29, 452.65, 443.18, 443.74, 437.65, 439.6, 440.94, 435.22,
> 427.55, 426.73, 426.07, 424.03), low = c(221.19, 224.57, 226.41,
> 221.5, 223.36, 222.76, 225, 224.27, 225.17, 226.66, 225.89, 225.71,
> 228.06, 229.74, 233.33, 233.81, 233.97, 237.16, 238.9, 241.25,
> 242.13, 242.08, 241.75, 245.34, 246.26, 245.68, 246.24, 247.65,
> 249.78, 247.74, 247.09, 245.69, 253.45, 255.29, 257.63, 253.06,
> 250.75, 249.43, 241.82, 241.89, 410.52, 419.88, 421.78, 416,
> 417.2, 418.21, 420, 413.64, 412.1, 411.55, 410.58, 410.29, 411.06,
> 414.85, 418.85, 422.02, 417.8, 421.31, 427.74, 432.63, 436.17,
> 441.77, 440.5, 441.6, 444.05, 449.11, 445.58, 445.28, 449.57,
> 437.02, 436.32, 428.63, 432.83, 434.19, 436.63, 426.35, 421.9,
> 420.66, 414.85, 419.54), close = c(222.72, 227.48, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 420.18, 425.43, 422.54, 418.01, 423.03,
> 425.2, 426.89, 415, 415.76, 417.79, 415.49, 412.87, 417, 418.79,
> 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62, 443.57,
> 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46, 437.39,
> 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83, 421.5,
> 418.58, 423.35), adjClose = c(222.48, 227.23, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 419.34, 424.58, 421.7, 417.17, 422.18,
> 424.35, 426.04, 414.17, 414.93, 416.96, 414.66, 412.87, 417,
> 418.79, 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62,
> 443.57, 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46,
> 437.39, 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83,
> 421.5, 418.58, 423.35)), class = "data.frame", row.names = c(NA,
> -80L))
>
> library(TTR)
> atr <- ATR(Hist[,c("high","low","close")], n=14)
> atr
>
>
Here's a function that splits your data into a list by symbol, then
does the TTR calculation for each symbol and re-combines the result
into an object with the same structure as the input.

  library(quantmod)
  my_atr <- function(ohlc, n = 14, ...)
  {
      cn <- names(ohlc)
      # get all the necessary columns
      atr_cols <- c(which(grepl("date", cn, ignore.case = TRUE)),
                    has.HLC(ohlc, which = TRUE))
      # find the symbol column
      sym_col <- which(grepl("symbol", cn, ignore.case = TRUE))

      # convert the input data.frame into a list of xts objects
      # this ensures the data are correctly ordered by date
      xts_list <- lapply(split(ohlc[, atr_cols], ohlc[, sym_col]), as.xts)
      # calculate ATR for each symbol
      atr_list <- lapply(xts_list, ATR, n = n, ...)

      # convert the list results into data.frames
      to_df <- function(nm) {
          i <- atr_list[[nm]];
          data.frame(symbol = nm, date = index(i), coredata(i))
      }
      atr_df <- lapply(names(atr_list), to_df)

      # rbind all the list elements into a single data frame
      do.call(rbind, atr_df)
  }

Hope that helps.

-- 
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  www.fosstrading.com


From j@p@rk4 @end|ng |rom u|c@edu  Sun Jan  5 18:49:23 2025
From: j@p@rk4 @end|ng |rom u|c@edu (Sparks, John)
Date: Sun, 5 Jan 2025 17:49:23 +0000
Subject: [R] Using library(TTR) Calculate ATR by Symbol
In-Reply-To: <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>
References: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>
Message-ID: <BY5PR13MB363695BC10D86ED57E323AEEFA172@BY5PR13MB3636.namprd13.prod.outlook.com>

Thanks!  Appears helpful and the quick turnaround is very much appreciated.  I'll do some testing now.

--JJS
________________________________
From: Joshua Ulrich <josh.m.ulrich at gmail.com>
Sent: Sunday, January 5, 2025 11:31 AM
To: Sparks, John <jspark4 at uic.edu>
Cc: R-help at r-project.org <R-help at r-project.org>
Subject: Re: Using library(TTR) Calculate ATR by Symbol

CAUTION: External Sender

Hi,

TTR/xts/quantmod maintainer here.

On Sun, Jan 5, 2025 at 10:58?AM Sparks, John <jspark4 at uic.edu> wrote:
>
> Hi,
>
> In looking at the documentation for the TTR library and particularly the
> example for calculating the ATR (average true range).  The example shows
> how to calculate ATR for a file of a single stock.
>
> If I have multiple stocks in one file, isn't there a way to get the ATR
> for each of them?  Or does one have to break out each stock and calculate
> the ATR separately using some sort of loop.
>
Yes, the TTR functions only work on a single stock at a time.

> In terms of a reproducible example, the file below contains open, high,
> low, close, etc. for AAPL and then MSFT.
>
Thanks for the reproducible data!

> If the ATR calculation were fully working, then there would be blanks for
> records 41 through 54 and then the ATR calculation would start up again.
>
> Guidance would be very much appreciated.
>
> --John Sparks
>
>
> Hist<-
> structure(list(symbol = c("AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT"), date = structure(c(20033, 20034, 20035,
> 20038, 20039, 20040, 20041, 20042, 20045, 20046, 20047, 20048,
> 20049, 20052, 20053, 20054, 20056, 20059, 20060, 20061, 20062,
> 20063, 20066, 20067, 20068, 20069, 20070, 20073, 20074, 20075,
> 20076, 20077, 20080, 20081, 20083, 20084, 20087, 20088, 20090,
> 20091, 20033, 20034, 20035, 20038, 20039, 20040, 20041, 20042,
> 20045, 20046, 20047, 20048, 20049, 20052, 20053, 20054, 20056,
> 20059, 20060, 20061, 20062, 20063, 20066, 20067, 20068, 20069,
> 20070, 20073, 20074, 20075, 20076, 20077, 20080, 20081, 20083,
> 20084, 20087, 20088, 20090, 20091), class = "Date"), open = c(222.61,
> 224.63, 227.17, 225, 224.55, 224.01, 225.02, 226.4, 225.25, 226.98,
> 228.06, 228.88, 228.06, 231.46, 233.33, 234.47, 234.81, 237.27,
> 239.81, 242.87, 243.99, 242.91, 241.83, 246.89, 247.96, 246.89,
> 247.82, 247.99, 250.08, 252.16, 247.5, 248.04, 254.77, 255.49,
> 258.19, 257.83, 252.23, 252.44, 248.93, 243.36, 412.42, 421.28,
> 425.32, 422.52, 418.25, 421.64, 425, 419.82, 414.87, 413.11,
> 416.87, 419.5, 411.37, 418.38, 419.59, 425.11, 420.09, 421.57,
> 429.84, 433.03, 437.92, 442.3, 442.6, 444.39, 444.05, 449.11,
> 448.44, 447.27, 451.01, 451.32, 441.62, 433.11, 436.74, 434.65,
> 439.08, 434.6, 426.06, 426.1, 425.53, 421.08), high = c(226.07,
> 227.88, 228.66, 225.7, 225.59, 226.65, 228.87, 226.92, 229.74,
> 230.16, 229.93, 230.16, 230.72, 233.25, 235.57, 235.69, 237.81,
> 240.79, 242.76, 244.11, 244.54, 244.63, 247.24, 248.21, 250.8,
> 248.74, 249.29, 251.38, 253.83, 254.28, 252, 255, 255.65, 258.21,
> 260.1, 258.7, 253.5, 253.28, 249.1, 244.18, 420.45, 426.85, 426.5,
> 424.81, 424.44, 429.33, 428.17, 422.8, 418.4, 417.94, 417.29,
> 419.78, 417.4, 421.08, 429.04, 427.23, 424.88, 433, 432.47, 439.67,
> 444.66, 446.1, 448.33, 449.62, 450.35, 456.16, 451.43, 452.18,
> 455.29, 452.65, 443.18, 443.74, 437.65, 439.6, 440.94, 435.22,
> 427.55, 426.73, 426.07, 424.03), low = c(221.19, 224.57, 226.41,
> 221.5, 223.36, 222.76, 225, 224.27, 225.17, 226.66, 225.89, 225.71,
> 228.06, 229.74, 233.33, 233.81, 233.97, 237.16, 238.9, 241.25,
> 242.13, 242.08, 241.75, 245.34, 246.26, 245.68, 246.24, 247.65,
> 249.78, 247.74, 247.09, 245.69, 253.45, 255.29, 257.63, 253.06,
> 250.75, 249.43, 241.82, 241.89, 410.52, 419.88, 421.78, 416,
> 417.2, 418.21, 420, 413.64, 412.1, 411.55, 410.58, 410.29, 411.06,
> 414.85, 418.85, 422.02, 417.8, 421.31, 427.74, 432.63, 436.17,
> 441.77, 440.5, 441.6, 444.05, 449.11, 445.58, 445.28, 449.57,
> 437.02, 436.32, 428.63, 432.83, 434.19, 436.63, 426.35, 421.9,
> 420.66, 414.85, 419.54), close = c(222.72, 227.48, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 420.18, 425.43, 422.54, 418.01, 423.03,
> 425.2, 426.89, 415, 415.76, 417.79, 415.49, 412.87, 417, 418.79,
> 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62, 443.57,
> 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46, 437.39,
> 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83, 421.5,
> 418.58, 423.35), adjClose = c(222.48, 227.23, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 419.34, 424.58, 421.7, 417.17, 422.18,
> 424.35, 426.04, 414.17, 414.93, 416.96, 414.66, 412.87, 417,
> 418.79, 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62,
> 443.57, 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46,
> 437.39, 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83,
> 421.5, 418.58, 423.35)), class = "data.frame", row.names = c(NA,
> -80L))
>
> library(TTR)
> atr <- ATR(Hist[,c("high","low","close")], n=14)
> atr
>
>
Here's a function that splits your data into a list by symbol, then
does the TTR calculation for each symbol and re-combines the result
into an object with the same structure as the input.

  library(quantmod)
  my_atr <- function(ohlc, n = 14, ...)
  {
      cn <- names(ohlc)
      # get all the necessary columns
      atr_cols <- c(which(grepl("date", cn, ignore.case = TRUE)),
                    has.HLC(ohlc, which = TRUE))
      # find the symbol column
      sym_col <- which(grepl("symbol", cn, ignore.case = TRUE))

      # convert the input data.frame into a list of xts objects
      # this ensures the data are correctly ordered by date
      xts_list <- lapply(split(ohlc[, atr_cols], ohlc[, sym_col]), as.xts)
      # calculate ATR for each symbol
      atr_list <- lapply(xts_list, ATR, n = n, ...)

      # convert the list results into data.frames
      to_df <- function(nm) {
          i <- atr_list[[nm]];
          data.frame(symbol = nm, date = index(i), coredata(i))
      }
      atr_df <- lapply(names(atr_list), to_df)

      # rbind all the list elements into a single data frame
      do.call(rbind, atr_df)
  }

Hope that helps.

--
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  https://nam04.safelinks.protection.outlook.com/?url=http%3A%2F%2Fwww.fosstrading.com%2F&data=05%7C02%7Cjspark4%40uic.edu%7C2aac1a65ee7c4120930d08dd2daecd07%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638716950981045350%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=zXHcmYaGJN7iyOUvxLhRWr8E%2BjrDyG5ze3LB0uf4n%2BI%3D&reserved=0<http://www.fosstrading.com/>

This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.

	[[alternative HTML version deleted]]


From j@p@rk4 @end|ng |rom u|c@edu  Sun Jan  5 18:58:26 2025
From: j@p@rk4 @end|ng |rom u|c@edu (Sparks, John)
Date: Sun, 5 Jan 2025 17:58:26 +0000
Subject: [R] Using library(TTR) Calculate ATR by Symbol
In-Reply-To: <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>
References: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>
Message-ID: <BY5PR13MB36363E6763A62060DDDEEBD7FA172@BY5PR13MB3636.namprd13.prod.outlook.com>

I don't see atr_df appearing in my current directory.

Also, I assume that the input data frame is named ohlc?  Or am I missing something.

Thanks,
--JJS

________________________________
From: Joshua Ulrich <josh.m.ulrich at gmail.com>
Sent: Sunday, January 5, 2025 11:31 AM
To: Sparks, John <jspark4 at uic.edu>
Cc: R-help at r-project.org <R-help at r-project.org>
Subject: Re: Using library(TTR) Calculate ATR by Symbol

CAUTION: External Sender

Hi,

TTR/xts/quantmod maintainer here.

On Sun, Jan 5, 2025 at 10:58?AM Sparks, John <jspark4 at uic.edu> wrote:
>
> Hi,
>
> In looking at the documentation for the TTR library and particularly the
> example for calculating the ATR (average true range).  The example shows
> how to calculate ATR for a file of a single stock.
>
> If I have multiple stocks in one file, isn't there a way to get the ATR
> for each of them?  Or does one have to break out each stock and calculate
> the ATR separately using some sort of loop.
>
Yes, the TTR functions only work on a single stock at a time.

> In terms of a reproducible example, the file below contains open, high,
> low, close, etc. for AAPL and then MSFT.
>
Thanks for the reproducible data!

> If the ATR calculation were fully working, then there would be blanks for
> records 41 through 54 and then the ATR calculation would start up again.
>
> Guidance would be very much appreciated.
>
> --John Sparks
>
>
> Hist<-
> structure(list(symbol = c("AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT"), date = structure(c(20033, 20034, 20035,
> 20038, 20039, 20040, 20041, 20042, 20045, 20046, 20047, 20048,
> 20049, 20052, 20053, 20054, 20056, 20059, 20060, 20061, 20062,
> 20063, 20066, 20067, 20068, 20069, 20070, 20073, 20074, 20075,
> 20076, 20077, 20080, 20081, 20083, 20084, 20087, 20088, 20090,
> 20091, 20033, 20034, 20035, 20038, 20039, 20040, 20041, 20042,
> 20045, 20046, 20047, 20048, 20049, 20052, 20053, 20054, 20056,
> 20059, 20060, 20061, 20062, 20063, 20066, 20067, 20068, 20069,
> 20070, 20073, 20074, 20075, 20076, 20077, 20080, 20081, 20083,
> 20084, 20087, 20088, 20090, 20091), class = "Date"), open = c(222.61,
> 224.63, 227.17, 225, 224.55, 224.01, 225.02, 226.4, 225.25, 226.98,
> 228.06, 228.88, 228.06, 231.46, 233.33, 234.47, 234.81, 237.27,
> 239.81, 242.87, 243.99, 242.91, 241.83, 246.89, 247.96, 246.89,
> 247.82, 247.99, 250.08, 252.16, 247.5, 248.04, 254.77, 255.49,
> 258.19, 257.83, 252.23, 252.44, 248.93, 243.36, 412.42, 421.28,
> 425.32, 422.52, 418.25, 421.64, 425, 419.82, 414.87, 413.11,
> 416.87, 419.5, 411.37, 418.38, 419.59, 425.11, 420.09, 421.57,
> 429.84, 433.03, 437.92, 442.3, 442.6, 444.39, 444.05, 449.11,
> 448.44, 447.27, 451.01, 451.32, 441.62, 433.11, 436.74, 434.65,
> 439.08, 434.6, 426.06, 426.1, 425.53, 421.08), high = c(226.07,
> 227.88, 228.66, 225.7, 225.59, 226.65, 228.87, 226.92, 229.74,
> 230.16, 229.93, 230.16, 230.72, 233.25, 235.57, 235.69, 237.81,
> 240.79, 242.76, 244.11, 244.54, 244.63, 247.24, 248.21, 250.8,
> 248.74, 249.29, 251.38, 253.83, 254.28, 252, 255, 255.65, 258.21,
> 260.1, 258.7, 253.5, 253.28, 249.1, 244.18, 420.45, 426.85, 426.5,
> 424.81, 424.44, 429.33, 428.17, 422.8, 418.4, 417.94, 417.29,
> 419.78, 417.4, 421.08, 429.04, 427.23, 424.88, 433, 432.47, 439.67,
> 444.66, 446.1, 448.33, 449.62, 450.35, 456.16, 451.43, 452.18,
> 455.29, 452.65, 443.18, 443.74, 437.65, 439.6, 440.94, 435.22,
> 427.55, 426.73, 426.07, 424.03), low = c(221.19, 224.57, 226.41,
> 221.5, 223.36, 222.76, 225, 224.27, 225.17, 226.66, 225.89, 225.71,
> 228.06, 229.74, 233.33, 233.81, 233.97, 237.16, 238.9, 241.25,
> 242.13, 242.08, 241.75, 245.34, 246.26, 245.68, 246.24, 247.65,
> 249.78, 247.74, 247.09, 245.69, 253.45, 255.29, 257.63, 253.06,
> 250.75, 249.43, 241.82, 241.89, 410.52, 419.88, 421.78, 416,
> 417.2, 418.21, 420, 413.64, 412.1, 411.55, 410.58, 410.29, 411.06,
> 414.85, 418.85, 422.02, 417.8, 421.31, 427.74, 432.63, 436.17,
> 441.77, 440.5, 441.6, 444.05, 449.11, 445.58, 445.28, 449.57,
> 437.02, 436.32, 428.63, 432.83, 434.19, 436.63, 426.35, 421.9,
> 420.66, 414.85, 419.54), close = c(222.72, 227.48, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 420.18, 425.43, 422.54, 418.01, 423.03,
> 425.2, 426.89, 415, 415.76, 417.79, 415.49, 412.87, 417, 418.79,
> 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62, 443.57,
> 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46, 437.39,
> 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83, 421.5,
> 418.58, 423.35), adjClose = c(222.48, 227.23, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 419.34, 424.58, 421.7, 417.17, 422.18,
> 424.35, 426.04, 414.17, 414.93, 416.96, 414.66, 412.87, 417,
> 418.79, 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62,
> 443.57, 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46,
> 437.39, 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83,
> 421.5, 418.58, 423.35)), class = "data.frame", row.names = c(NA,
> -80L))
>
> library(TTR)
> atr <- ATR(Hist[,c("high","low","close")], n=14)
> atr
>
>
Here's a function that splits your data into a list by symbol, then
does the TTR calculation for each symbol and re-combines the result
into an object with the same structure as the input.

  library(quantmod)
  my_atr <- function(ohlc, n = 14, ...)
  {
      cn <- names(ohlc)
      # get all the necessary columns
      atr_cols <- c(which(grepl("date", cn, ignore.case = TRUE)),
                    has.HLC(ohlc, which = TRUE))
      # find the symbol column
      sym_col <- which(grepl("symbol", cn, ignore.case = TRUE))

      # convert the input data.frame into a list of xts objects
      # this ensures the data are correctly ordered by date
      xts_list <- lapply(split(ohlc[, atr_cols], ohlc[, sym_col]), as.xts)
      # calculate ATR for each symbol
      atr_list <- lapply(xts_list, ATR, n = n, ...)

      # convert the list results into data.frames
      to_df <- function(nm) {
          i <- atr_list[[nm]];
          data.frame(symbol = nm, date = index(i), coredata(i))
      }
      atr_df <- lapply(names(atr_list), to_df)

      # rbind all the list elements into a single data frame
      do.call(rbind, atr_df)
  }

Hope that helps.

--
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  https://nam04.safelinks.protection.outlook.com/?url=http%3A%2F%2Fwww.fosstrading.com%2F&data=05%7C02%7Cjspark4%40uic.edu%7C2aac1a65ee7c4120930d08dd2daecd07%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638716950981045350%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=zXHcmYaGJN7iyOUvxLhRWr8E%2BjrDyG5ze3LB0uf4n%2BI%3D&reserved=0<http://www.fosstrading.com/>

This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Sun Jan  5 18:59:22 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Sun, 5 Jan 2025 09:59:22 -0800
Subject: [R] Extracting specific arguments from "..."
Message-ID: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>

Consider:

f1 <- function(...){
  one <- list(...)[['a']]
  two <- ...elt(match('a', ...names()))
  c(one, two)
}
## Here "..." is an argument list with "a" somewhere in it, but in an
unknown position.

> f1(b=5, a = 2, c=7)
[1] 2 2

Which is better for extracting a specific named argument, one<- or
two<- ?  Or a third alternative that is better than both?
Comments and critiques welcome.

Cheers,
Bert


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Sun Jan  5 19:09:51 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 5 Jan 2025 12:09:51 -0600
Subject: [R] Using library(TTR) Calculate ATR by Symbol
In-Reply-To: <BY5PR13MB36363E6763A62060DDDEEBD7FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
References: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>
 <BY5PR13MB36363E6763A62060DDDEEBD7FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
Message-ID: <CAPPM_gTD4hHsYtPzjFO2rUqhp7Xp7kEfnECM3PiQYWNNYhDqFQ@mail.gmail.com>

On Sun, Jan 5, 2025 at 11:58?AM Sparks, John <jspark4 at uic.edu> wrote:
>
> I don't see atr_df appearing in my current directory.
>
> Also, I assume that the input data frame is named ohlc?  Or am I missing something.
>
You need to call the function with your data and assign it to an object.

For example:
    atr <- my_atr(Hist)

> Thanks,
> --JJS
>
> ________________________________
> From: Joshua Ulrich <josh.m.ulrich at gmail.com>
> Sent: Sunday, January 5, 2025 11:31 AM
> To: Sparks, John <jspark4 at uic.edu>
> Cc: R-help at r-project.org <R-help at r-project.org>
> Subject: Re: Using library(TTR) Calculate ATR by Symbol
>
> CAUTION: External Sender
>
> Hi,
>
> TTR/xts/quantmod maintainer here.
>
> On Sun, Jan 5, 2025 at 10:58?AM Sparks, John <jspark4 at uic.edu> wrote:
> >
> > Hi,
> >
> > In looking at the documentation for the TTR library and particularly the
> > example for calculating the ATR (average true range).  The example shows
> > how to calculate ATR for a file of a single stock.
> >
> > If I have multiple stocks in one file, isn't there a way to get the ATR
> > for each of them?  Or does one have to break out each stock and calculate
> > the ATR separately using some sort of loop.
> >
> Yes, the TTR functions only work on a single stock at a time.
>
> > In terms of a reproducible example, the file below contains open, high,
> > low, close, etc. for AAPL and then MSFT.
> >
> Thanks for the reproducible data!
>
> > If the ATR calculation were fully working, then there would be blanks for
> > records 41 through 54 and then the ATR calculation would start up again.
> >
> > Guidance would be very much appreciated.
> >
> > --John Sparks
> >
> >
> > Hist<-
> > structure(list(symbol = c("AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> > "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> > "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> > "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> > "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> > "AAPL", "AAPL", "AAPL", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> > "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> > "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> > "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> > "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> > "MSFT", "MSFT", "MSFT"), date = structure(c(20033, 20034, 20035,
> > 20038, 20039, 20040, 20041, 20042, 20045, 20046, 20047, 20048,
> > 20049, 20052, 20053, 20054, 20056, 20059, 20060, 20061, 20062,
> > 20063, 20066, 20067, 20068, 20069, 20070, 20073, 20074, 20075,
> > 20076, 20077, 20080, 20081, 20083, 20084, 20087, 20088, 20090,
> > 20091, 20033, 20034, 20035, 20038, 20039, 20040, 20041, 20042,
> > 20045, 20046, 20047, 20048, 20049, 20052, 20053, 20054, 20056,
> > 20059, 20060, 20061, 20062, 20063, 20066, 20067, 20068, 20069,
> > 20070, 20073, 20074, 20075, 20076, 20077, 20080, 20081, 20083,
> > 20084, 20087, 20088, 20090, 20091), class = "Date"), open = c(222.61,
> > 224.63, 227.17, 225, 224.55, 224.01, 225.02, 226.4, 225.25, 226.98,
> > 228.06, 228.88, 228.06, 231.46, 233.33, 234.47, 234.81, 237.27,
> > 239.81, 242.87, 243.99, 242.91, 241.83, 246.89, 247.96, 246.89,
> > 247.82, 247.99, 250.08, 252.16, 247.5, 248.04, 254.77, 255.49,
> > 258.19, 257.83, 252.23, 252.44, 248.93, 243.36, 412.42, 421.28,
> > 425.32, 422.52, 418.25, 421.64, 425, 419.82, 414.87, 413.11,
> > 416.87, 419.5, 411.37, 418.38, 419.59, 425.11, 420.09, 421.57,
> > 429.84, 433.03, 437.92, 442.3, 442.6, 444.39, 444.05, 449.11,
> > 448.44, 447.27, 451.01, 451.32, 441.62, 433.11, 436.74, 434.65,
> > 439.08, 434.6, 426.06, 426.1, 425.53, 421.08), high = c(226.07,
> > 227.88, 228.66, 225.7, 225.59, 226.65, 228.87, 226.92, 229.74,
> > 230.16, 229.93, 230.16, 230.72, 233.25, 235.57, 235.69, 237.81,
> > 240.79, 242.76, 244.11, 244.54, 244.63, 247.24, 248.21, 250.8,
> > 248.74, 249.29, 251.38, 253.83, 254.28, 252, 255, 255.65, 258.21,
> > 260.1, 258.7, 253.5, 253.28, 249.1, 244.18, 420.45, 426.85, 426.5,
> > 424.81, 424.44, 429.33, 428.17, 422.8, 418.4, 417.94, 417.29,
> > 419.78, 417.4, 421.08, 429.04, 427.23, 424.88, 433, 432.47, 439.67,
> > 444.66, 446.1, 448.33, 449.62, 450.35, 456.16, 451.43, 452.18,
> > 455.29, 452.65, 443.18, 443.74, 437.65, 439.6, 440.94, 435.22,
> > 427.55, 426.73, 426.07, 424.03), low = c(221.19, 224.57, 226.41,
> > 221.5, 223.36, 222.76, 225, 224.27, 225.17, 226.66, 225.89, 225.71,
> > 228.06, 229.74, 233.33, 233.81, 233.97, 237.16, 238.9, 241.25,
> > 242.13, 242.08, 241.75, 245.34, 246.26, 245.68, 246.24, 247.65,
> > 249.78, 247.74, 247.09, 245.69, 253.45, 255.29, 257.63, 253.06,
> > 250.75, 249.43, 241.82, 241.89, 410.52, 419.88, 421.78, 416,
> > 417.2, 418.21, 420, 413.64, 412.1, 411.55, 410.58, 410.29, 411.06,
> > 414.85, 418.85, 422.02, 417.8, 421.31, 427.74, 432.63, 436.17,
> > 441.77, 440.5, 441.6, 444.05, 449.11, 445.58, 445.28, 449.57,
> > 437.02, 436.32, 428.63, 432.83, 434.19, 436.63, 426.35, 421.9,
> > 420.66, 414.85, 419.54), close = c(222.72, 227.48, 226.96, 224.23,
> > 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> > 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> > 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> > 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> > 250.42, 243.85, 243.36, 420.18, 425.43, 422.54, 418.01, 423.03,
> > 425.2, 426.89, 415, 415.76, 417.79, 415.49, 412.87, 417, 418.79,
> > 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62, 443.57,
> > 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46, 437.39,
> > 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83, 421.5,
> > 418.58, 423.35), adjClose = c(222.48, 227.23, 226.96, 224.23,
> > 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> > 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> > 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> > 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> > 250.42, 243.85, 243.36, 419.34, 424.58, 421.7, 417.17, 422.18,
> > 424.35, 426.04, 414.17, 414.93, 416.96, 414.66, 412.87, 417,
> > 418.79, 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62,
> > 443.57, 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46,
> > 437.39, 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83,
> > 421.5, 418.58, 423.35)), class = "data.frame", row.names = c(NA,
> > -80L))
> >
> > library(TTR)
> > atr <- ATR(Hist[,c("high","low","close")], n=14)
> > atr
> >
> >
> Here's a function that splits your data into a list by symbol, then
> does the TTR calculation for each symbol and re-combines the result
> into an object with the same structure as the input.
>
>   library(quantmod)
>   my_atr <- function(ohlc, n = 14, ...)
>   {
>       cn <- names(ohlc)
>       # get all the necessary columns
>       atr_cols <- c(which(grepl("date", cn, ignore.case = TRUE)),
>                     has.HLC(ohlc, which = TRUE))
>       # find the symbol column
>       sym_col <- which(grepl("symbol", cn, ignore.case = TRUE))
>
>       # convert the input data.frame into a list of xts objects
>       # this ensures the data are correctly ordered by date
>       xts_list <- lapply(split(ohlc[, atr_cols], ohlc[, sym_col]), as.xts)
>       # calculate ATR for each symbol
>       atr_list <- lapply(xts_list, ATR, n = n, ...)
>
>       # convert the list results into data.frames
>       to_df <- function(nm) {
>           i <- atr_list[[nm]];
>           data.frame(symbol = nm, date = index(i), coredata(i))
>       }
>       atr_df <- lapply(names(atr_list), to_df)
>
>       # rbind all the list elements into a single data frame
>       do.call(rbind, atr_df)
>   }
>
> Hope that helps.
>
> --
> Joshua Ulrich  |  about.me/joshuaulrich
>
> This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.


From |kw@|mmo @end|ng |rom gm@||@com  Sun Jan  5 19:15:55 2025
From: |kw@|mmo @end|ng |rom gm@||@com (Iris Simmons)
Date: Sun, 5 Jan 2025 13:15:55 -0500
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
Message-ID: <CADNULg9QiL2c-ROdQXY94R0JbxEx-kf9PyYRndSiy4tvzgXzMQ@mail.gmail.com>

I would use two because it does not force the evaluation of the other
arguments in the ... list.



On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:

> Consider:
>
> f1 <- function(...){
>   one <- list(...)[['a']]
>   two <- ...elt(match('a', ...names()))
>   c(one, two)
> }
> ## Here "..." is an argument list with "a" somewhere in it, but in an
> unknown position.
>
> > f1(b=5, a = 2, c=7)
> [1] 2 2
>
> Which is better for extracting a specific named argument, one<- or
> two<- ?  Or a third alternative that is better than both?
> Comments and critiques welcome.
>
> Cheers,
> Bert
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Sun Jan  5 20:17:02 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Sun, 5 Jan 2025 11:17:02 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CADNULg9QiL2c-ROdQXY94R0JbxEx-kf9PyYRndSiy4tvzgXzMQ@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
 <CADNULg9QiL2c-ROdQXY94R0JbxEx-kf9PyYRndSiy4tvzgXzMQ@mail.gmail.com>
Message-ID: <CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q@mail.gmail.com>

Thanks, Iris.
That is what I suspected, but it wasn't clear to me from the docs.

Best,
Bert

On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
>
> I would use two because it does not force the evaluation of the other arguments in the ... list.
>
>
>
> On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
>>
>> Consider:
>>
>> f1 <- function(...){
>>   one <- list(...)[['a']]
>>   two <- ...elt(match('a', ...names()))
>>   c(one, two)
>> }
>> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> unknown position.
>>
>> > f1(b=5, a = 2, c=7)
>> [1] 2 2
>>
>> Which is better for extracting a specific named argument, one<- or
>> two<- ?  Or a third alternative that is better than both?
>> Comments and critiques welcome.
>>
>> Cheers,
>> Bert
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.


From j@p@rk4 @end|ng |rom u|c@edu  Sun Jan  5 21:03:11 2025
From: j@p@rk4 @end|ng |rom u|c@edu (Sparks, John)
Date: Sun, 5 Jan 2025 20:03:11 +0000
Subject: [R] Help Parsing String? From HTML
Message-ID: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>

Hi,

I am scraping some data from the internet and I got what I want but in a big long string (sort of) and can't figure out a way to parse it.

What I have gotten to is

> mystring
{xml_nodeset (1)}
[1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n  "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from": "2005-01-04"\n}</p>

But I can't find a way to isolate the individual elements such as symbol, open, etc.

I'll bet there is someone out there with a lot more experience at html parsing than me who can see a way to solve this in minutes.

Any guidance would be appreciated.

--John Sparks

	[[alternative HTML version deleted]]


From |kry|ov @end|ng |rom d|@root@org  Sun Jan  5 21:16:05 2025
From: |kry|ov @end|ng |rom d|@root@org (Ivan Krylov)
Date: Sun, 5 Jan 2025 23:16:05 +0300
Subject: [R] Help Parsing String? From HTML
In-Reply-To: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
References: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
Message-ID: <20250105231605.222a0715@Tarkus>

? Sun, 5 Jan 2025 20:03:11 +0000
"Sparks, John via R-help" <r-help at r-project.org> ?????:

> > mystring  
> {xml_nodeset (1)}
> [1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n
> "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from":
> "2005-01-04"\n}</p>
> 
> But I can't find a way to isolate the individual elements such as
> symbol, open, etc.

This is a JSON string inside a <p> tag. It's not how a web page is
normally constructed (the <p> tag is usually for human-readable text,
not machine readable JSON), but the good news is that

mystring |> xml_text() |> jsonlite::parse_json()

should give you a named list with the desired contents.

-- 
Best regards,
Ivan


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Sun Jan  5 21:55:44 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 5 Jan 2025 14:55:44 -0600
Subject: [R] Help Parsing String? From HTML
In-Reply-To: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
References: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
Message-ID: <CAPPM_gT5LfQ96R2qL4R3a08Cb0u3ZTANpw9K59ng_FJhN0BJvQ@mail.gmail.com>

On Sun, Jan 5, 2025 at 2:03?PM Sparks, John via R-help
<r-help at r-project.org> wrote:
>
> Hi,
>
> I am scraping some data from the internet and I got what I want but in a big long string (sort of) and can't figure out a way to parse it.
>
What site are you scraping? There may be an easier way to get the data on it.

> What I have gotten to is
>
> > mystring
> {xml_nodeset (1)}
> [1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n  "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from": "2005-01-04"\n}</p>
>
> But I can't find a way to isolate the individual elements such as symbol, open, etc.
>
> I'll bet there is someone out there with a lot more experience at html parsing than me who can see a way to solve this in minutes.
>
> Any guidance would be appreciated.
>
> --John Sparks
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.



-- 
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  www.fosstrading.com


From j@p@rk4 @end|ng |rom u|c@edu  Mon Jan  6 00:41:13 2025
From: j@p@rk4 @end|ng |rom u|c@edu (Sparks, John)
Date: Sun, 5 Jan 2025 23:41:13 +0000
Subject: [R] Help Parsing String? From HTML
In-Reply-To: <CAPPM_gT5LfQ96R2qL4R3a08Cb0u3ZTANpw9K59ng_FJhN0BJvQ@mail.gmail.com>
References: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gT5LfQ96R2qL4R3a08Cb0u3ZTANpw9K59ng_FJhN0BJvQ@mail.gmail.com>
Message-ID: <BY5PR13MB363646638BA2166201BABC60FA172@BY5PR13MB3636.namprd13.prod.outlook.com>

Hi Josh,

Thanks for helping me with my second topic of the day.

I am scraping from the fmpcloud website and trying to get data from their survivorship free data (so they say).

The result is supposed to be in json format, but I can't figure out how to get any of R's json interpreters to parse the result.

The programming in R to get the initial data is

html <- read_html("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e")

Any (additional) guidance would be appreciated.

--John Sparks
________________________________
From: Joshua Ulrich <josh.m.ulrich at gmail.com>
Sent: Sunday, January 5, 2025 2:55 PM
To: Sparks, John <jspark4 at uic.edu>
Cc: r-help at r-project.org <r-help at r-project.org>
Subject: Re: [R] Help Parsing String? From HTML

CAUTION: External Sender

On Sun, Jan 5, 2025 at 2:03?PM Sparks, John via R-help
<r-help at r-project.org> wrote:
>
> Hi,
>
> I am scraping some data from the internet and I got what I want but in a big long string (sort of) and can't figure out a way to parse it.
>
What site are you scraping? There may be an easier way to get the data on it.

> What I have gotten to is
>
> > mystring
> {xml_nodeset (1)}
> [1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n  "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from": "2005-01-04"\n}</p>
>
> But I can't find a way to isolate the individual elements such as symbol, open, etc.
>
> I'll bet there is someone out there with a lot more experience at html parsing than me who can see a way to solve this in minutes.
>
> Any guidance would be appreciated.
>
> --John Sparks
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-help&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670167325%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=vpJ%2Bva%2BI%2Fnm1bBXakuB34TSW%2BV832R4sOgyYCAq6iIA%3D&reserved=0<https://stat.ethz.ch/mailman/listinfo/r-help>
> PLEASE do read the posting guide https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.r-project.org%2Fposting-guide.html&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670183537%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=HDxFV4GG6w%2Fut71t3IHHEz%2FTw3kiKYZeuxZvvbGCG7A%3D&reserved=0<https://www.r-project.org/posting-guide.html>
> and provide commented, minimal, self-contained, reproducible code.



--
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  https://nam04.safelinks.protection.outlook.com/?url=http%3A%2F%2Fwww.fosstrading.com%2F&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670195224%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=RSnWCt4%2BS04spT8n1DgklRukVCYHDdoNUW%2BGMtA4iAQ%3D&reserved=0<http://www.fosstrading.com/>

This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.

	[[alternative HTML version deleted]]


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Mon Jan  6 00:54:32 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 5 Jan 2025 17:54:32 -0600
Subject: [R] Help Parsing String? From HTML
In-Reply-To: <BY5PR13MB363646638BA2166201BABC60FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
References: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gT5LfQ96R2qL4R3a08Cb0u3ZTANpw9K59ng_FJhN0BJvQ@mail.gmail.com>
 <BY5PR13MB363646638BA2166201BABC60FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
Message-ID: <CAPPM_gSb4K=pbghXJi61YA9XAXpXRMg-z+ZZWPcf1tC-j2JLxA@mail.gmail.com>

On Sun, Jan 5, 2025 at 5:41?PM Sparks, John <jspark4 at uic.edu> wrote:
>
> Hi Josh,
>
> Thanks for helping me with my second topic of the day.
>
> I am scraping from the fmpcloud website and trying to get data from their survivorship free data (so they say).
>
> The result is supposed to be in json format, but I can't figure out how to get any of R's json interpreters to parse the result.
>
> The programming in R to get the initial data is
>
> html <- read_html("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e")
>
> Any (additional) guidance would be appreciated.
>
That's a REST API endpoint. It responds with JSON, not HTML. So you just need

    x <- jsonlite::parse_json("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e")

> --John Sparks
> ________________________________
> From: Joshua Ulrich <josh.m.ulrich at gmail.com>
> Sent: Sunday, January 5, 2025 2:55 PM
> To: Sparks, John <jspark4 at uic.edu>
> Cc: r-help at r-project.org <r-help at r-project.org>
> Subject: Re: [R] Help Parsing String? From HTML
>
> CAUTION: External Sender
>
> On Sun, Jan 5, 2025 at 2:03?PM Sparks, John via R-help
> <r-help at r-project.org> wrote:
> >
> > Hi,
> >
> > I am scraping some data from the internet and I got what I want but in a big long string (sort of) and can't figure out a way to parse it.
> >
> What site are you scraping? There may be an easier way to get the data on it.
>
> > What I have gotten to is
> >
> > > mystring
> > {xml_nodeset (1)}
> > [1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n  "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from": "2005-01-04"\n}</p>
> >
> > But I can't find a way to isolate the individual elements such as symbol, open, etc.
> >
> > I'll bet there is someone out there with a lot more experience at html parsing than me who can see a way to solve this in minutes.
> >
> > Any guidance would be appreciated.
> >
> > --John Sparks
> >
> >         [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-help&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670167325%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=vpJ%2Bva%2BI%2Fnm1bBXakuB34TSW%2BV832R4sOgyYCAq6iIA%3D&reserved=0
> > PLEASE do read the posting guide https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.r-project.org%2Fposting-guide.html&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670183537%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=HDxFV4GG6w%2Fut71t3IHHEz%2FTw3kiKYZeuxZvvbGCG7A%3D&reserved=0
> > and provide commented, minimal, self-contained, reproducible code.
>
>
>
> --
> Joshua Ulrich  |  about.me/joshuaulrich
>
> This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Mon Jan  6 01:06:15 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 5 Jan 2025 18:06:15 -0600
Subject: [R] Help Parsing String? From HTML
In-Reply-To: <CAPPM_gSb4K=pbghXJi61YA9XAXpXRMg-z+ZZWPcf1tC-j2JLxA@mail.gmail.com>
References: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gT5LfQ96R2qL4R3a08Cb0u3ZTANpw9K59ng_FJhN0BJvQ@mail.gmail.com>
 <BY5PR13MB363646638BA2166201BABC60FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gSb4K=pbghXJi61YA9XAXpXRMg-z+ZZWPcf1tC-j2JLxA@mail.gmail.com>
Message-ID: <CAPPM_gR=wGiNgpuEJjZQLxYpCMFp6WUvFBiJOaagQgkmd1rkjA@mail.gmail.com>

On Sun, Jan 5, 2025 at 5:54?PM Joshua Ulrich <josh.m.ulrich at gmail.com> wrote:
>
> On Sun, Jan 5, 2025 at 5:41?PM Sparks, John <jspark4 at uic.edu> wrote:
> >
> > Hi Josh,
> >
> > Thanks for helping me with my second topic of the day.
> >
> > I am scraping from the fmpcloud website and trying to get data from their survivorship free data (so they say).
> >
> > The result is supposed to be in json format, but I can't figure out how to get any of R's json interpreters to parse the result.
> >
> > The programming in R to get the initial data is
> >
> > html <- read_html("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e")
> >
> > Any (additional) guidance would be appreciated.
> >
> That's a REST API endpoint. It responds with JSON, not HTML. So you just need
>
>     <untested code failure omitted>
>
Correction, that should be either
    x <- jsonlite::parse_json(url("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e"))
    # or
    x <- jsonlite::fromJSON("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e")

> > --John Sparks
> > ________________________________
> > From: Joshua Ulrich <josh.m.ulrich at gmail.com>
> > Sent: Sunday, January 5, 2025 2:55 PM
> > To: Sparks, John <jspark4 at uic.edu>
> > Cc: r-help at r-project.org <r-help at r-project.org>
> > Subject: Re: [R] Help Parsing String? From HTML
> >
> > CAUTION: External Sender
> >
> > On Sun, Jan 5, 2025 at 2:03?PM Sparks, John via R-help
> > <r-help at r-project.org> wrote:
> > >
> > > Hi,
> > >
> > > I am scraping some data from the internet and I got what I want but in a big long string (sort of) and can't figure out a way to parse it.
> > >
> > What site are you scraping? There may be an easier way to get the data on it.
> >
> > > What I have gotten to is
> > >
> > > > mystring
> > > {xml_nodeset (1)}
> > > [1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n  "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from": "2005-01-04"\n}</p>
> > >
> > > But I can't find a way to isolate the individual elements such as symbol, open, etc.
> > >
> > > I'll bet there is someone out there with a lot more experience at html parsing than me who can see a way to solve this in minutes.
> > >
> > > Any guidance would be appreciated.
> > >
> > > --John Sparks
> > >
> > >         [[alternative HTML version deleted]]
> > >
> > > ______________________________________________
> > > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > > https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-help&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670167325%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=vpJ%2Bva%2BI%2Fnm1bBXakuB34TSW%2BV832R4sOgyYCAq6iIA%3D&reserved=0
> > > PLEASE do read the posting guide https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.r-project.org%2Fposting-guide.html&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670183537%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=HDxFV4GG6w%2Fut71t3IHHEz%2FTw3kiKYZeuxZvvbGCG7A%3D&reserved=0
> > > and provide commented, minimal, self-contained, reproducible code.
> >
> >
> >
> > --
> > Joshua Ulrich  |  about.me/joshuaulrich
> >
> > This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.



-- 
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  www.fosstrading.com


From m||@nd_j @end|ng |rom hotm@||@com  Sun Jan  5 21:23:10 2025
From: m||@nd_j @end|ng |rom hotm@||@com (Miland Joshi)
Date: Sun, 5 Jan 2025 20:23:10 +0000
Subject: [R] Possible bug in direct.evidence.plot?
Message-ID: <DB7PR09MB2506A927224E142AC89E9DFEF9172@DB7PR09MB2506.eurprd09.prod.outlook.com>

I succeeded in getting netmetabin to work, but when trying to use direct.evidence.plot I ran into a problem:

> nb1evid <- direct.evidence.plot(nb1)
Error in if (class(x) != "netmeta") { : the condition has length > 1

I tried updating netmeta and dmetar (and dmetafor) from R, but the problem remains.
Has anyone come across this, and could it be a bug?

Regards
Miland Joshi

	[[alternative HTML version deleted]]


From er|cjberger @end|ng |rom gm@||@com  Mon Jan  6 09:24:42 2025
From: er|cjberger @end|ng |rom gm@||@com (Eric Berger)
Date: Mon, 6 Jan 2025 10:24:42 +0200
Subject: [R] Possible bug in direct.evidence.plot?
In-Reply-To: <DB7PR09MB2506A927224E142AC89E9DFEF9172@DB7PR09MB2506.eurprd09.prod.outlook.com>
References: <DB7PR09MB2506A927224E142AC89E9DFEF9172@DB7PR09MB2506.eurprd09.prod.outlook.com>
Message-ID: <CAGgJW74LDza5WL2FRXODpobe9GSTA1a5L04d3ODORwvBHHtKpg@mail.gmail.com>

The explanation is likely that class(x) returns a character vector of
length > 1.
If you go into the code you can achieve what is probably intended without
triggering this error by replacing that statement with the following:

if (inherits(x,"netmeta")) ...

HTH,
Eric


On Mon, Jan 6, 2025 at 9:57?AM Miland Joshi <miland_j at hotmail.com> wrote:

> I succeeded in getting netmetabin to work, but when trying to use
> direct.evidence.plot I ran into a problem:
>
> > nb1evid <- direct.evidence.plot(nb1)
> Error in if (class(x) != "netmeta") { : the condition has length > 1
>
> I tried updating netmeta and dmetar (and dmetafor) from R, but the problem
> remains.
> Has anyone come across this, and could it be a bug?
>
> Regards
> Miland Joshi
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From er|cjberger @end|ng |rom gm@||@com  Mon Jan  6 12:05:38 2025
From: er|cjberger @end|ng |rom gm@||@com (Eric Berger)
Date: Mon, 6 Jan 2025 13:05:38 +0200
Subject: [R] Possible bug in direct.evidence.plot?
In-Reply-To: <DB7PR09MB2506480D2D7136FA27C7306EF9102@DB7PR09MB2506.eurprd09.prod.outlook.com>
References: <DB7PR09MB2506A927224E142AC89E9DFEF9172@DB7PR09MB2506.eurprd09.prod.outlook.com>
 <CAGgJW74LDza5WL2FRXODpobe9GSTA1a5L04d3ODORwvBHHtKpg@mail.gmail.com>
 <DB7PR09MB2506480D2D7136FA27C7306EF9102@DB7PR09MB2506.eurprd09.prod.outlook.com>
Message-ID: <CAGgJW75SWsurK0aXQM7oTbgPwPVvJJu=sj-AGqUnK8KvBWDH6A@mail.gmail.com>

This is as I expected. My suggested fix will work in this case.

On Mon, Jan 6, 2025 at 1:03?PM Miland Joshi <miland_j at hotmail.com> wrote:

> Hello
>
> In R when I looked at the class of nb1 I got:
> > class(nb1)
> [1] "netmetabin" "netmeta"
>
> which suggests that netmeta might work but netmetabin may cause problems.
> I'll notify Mathias Harrer!
>
> BW
> Miland
>
> ------------------------------
> *From:* Eric Berger <ericjberger at gmail.com>
> *Sent:* 06 January 2025 08:24
> *To:* Miland Joshi <miland_j at hotmail.com>
> *Cc:* r-help at R-project.org <r-help at r-project.org>
> *Subject:* Re: [R] Possible bug in direct.evidence.plot?
>
> The explanation is likely that class(x) returns a character vector of
> length > 1.
> If you go into the code you can achieve what is probably intended without
> triggering this error by replacing that statement with the following:
>
> if (inherits(x,"netmeta")) ...
>
> HTH,
> Eric
>
>
> On Mon, Jan 6, 2025 at 9:57?AM Miland Joshi <miland_j at hotmail.com> wrote:
>
> I succeeded in getting netmetabin to work, but when trying to use
> direct.evidence.plot I ran into a problem:
>
> > nb1evid <- direct.evidence.plot(nb1)
> Error in if (class(x) != "netmeta") { : the condition has length > 1
>
> I tried updating netmeta and dmetar (and dmetafor) from R, but the problem
> remains.
> Has anyone come across this, and could it be a bug?
>
> Regards
> Miland Joshi
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>
>

	[[alternative HTML version deleted]]


From JH@rm@e @end|ng |rom roku@com  Mon Jan  6 18:55:21 2025
From: JH@rm@e @end|ng |rom roku@com (Jorgen Harmse)
Date: Mon, 6 Jan 2025 17:55:21 +0000
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
Message-ID: <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>

I think Bert Gunter is right, but do you want partial matches (not found by match), and how robust do you want the code to be?

f <- function(?)
{ pos <- match('a', ...names())
  if (is.na(pos))
    stop("a is required.")
  ?elt(pos)
}

Incidentally, what is the best way to extract the expression without evaluating it?



g <- function(...)

{ pos <- match('a',...names())

  if (is.na(pos))

    stop("a is missing.")

  (function(a,...) substitute(a)) (...)

}

Regards,
Jorgen Harmse.

Message: 8
Date: Sun, 5 Jan 2025 11:17:02 -0800
From: Bert Gunter <bgunter.4567 at gmail.com>
To: Iris Simmons <ikwsimmo at gmail.com>
Cc: R-help <R-help at r-project.org>
Subject: Re: [R] Extracting specific arguments from "..."
Message-ID:
        <CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
Content-Type: text/plain; charset="utf-8"

Thanks, Iris.
That is what I suspected, but it wasn't clear to me from the docs.

Best,
Bert

On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
>
> I would use two because it does not force the evaluation of the other arguments in the ... list.
>
>
>
> On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
>>
>> Consider:
>>
>> f1 <- function(...){
>>   one <- list(...)[['a']]
>>   two <- ...elt(match('a', ...names()))
>>   c(one, two)
>> }
>> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> unknown position.
>>
>> > f1(b=5, a = 2, c=7)
>> [1] 2 2
>>
>> Which is better for extracting a specific named argument, one<- or
>> two<- ?  Or a third alternative that is better than both?
>> Comments and critiques welcome.
>>
>> Cheers,
>> Bert
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.




	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Mon Jan  6 23:22:10 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Mon, 6 Jan 2025 14:22:10 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
Message-ID: <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>

Thanks Jorgen.

I thought your approach to getting the argument expressions was clever, but
somewhat convoluted. I think the usual simple way is to use match.call()
(or sys.call() )to get the unevaluated argument expressions;  e.g. ...

f <- function(...){
   match.call()
}
> f(a = 'red', b = sin(zzz))
f(a = "red", b = sin(zzz))

The return value is an object of class call that can be subscripted as (or
converted by as.list() to) a list to extract the argument expressions:
> f(a = 'red', b = sin(zzz))$b
sin(zzz)

You'll note that the $b component is again of class "call". So you may wish
to convert it to character or expression or whatever for further
processing, depending on context. Obviously, I haven't thought about this
carefully.

You raise an important point about robustness. I believe this approach to
extracting the call expressions should be fairly robust, but I do get
confused about the lay of the land when you add promises with default
arguments that may not yet have been forced before match.call() is called.
You may have to wrestle with sys.call() and it's "wh" argument to make
things work the way you want in that situation. I leave such delights to
wiser heads, as well as any corrections or refinements to anything that
I've said here.

Cheers,
Bert

On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:

> I think Bert Gunter is right, but do you want partial matches (not found
> by match), and how robust do you want the code to be?
>
>
>
> f <- function(?)
>
> { pos <- match('a', ...names())
>
>   if (is.na(pos))
>
>     stop("a is required.")
>
>   ?elt(pos)
>
> }
>
>
>
> Incidentally, what is the best way to extract the expression without
> evaluating it?
>
>
>
> g <- function(...)
>
> { pos <- match('a',...names())
>
>   if (is.na(pos))
>
>     stop("a is missing.")
>
>   (function(a,...) substitute(a)) (...)
>
> }
>
>
>
> Regards,
>
> Jorgen Harmse.
>
>
>
> Message: 8
> Date: Sun, 5 Jan 2025 11:17:02 -0800
> From: Bert Gunter <bgunter.4567 at gmail.com>
> To: Iris Simmons <ikwsimmo at gmail.com>
> Cc: R-help <R-help at r-project.org>
> Subject: Re: [R] Extracting specific arguments from "..."
> Message-ID:
>         <
> CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Thanks, Iris.
> That is what I suspected, but it wasn't clear to me from the docs.
>
> Best,
> Bert
>
> On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
> >
> > I would use two because it does not force the evaluation of the other
> arguments in the ... list.
> >
> >
> >
> > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
> >>
> >> Consider:
> >>
> >> f1 <- function(...){
> >>   one <- list(...)[['a']]
> >>   two <- ...elt(match('a', ...names()))
> >>   c(one, two)
> >> }
> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
> >> unknown position.
> >>
> >> > f1(b=5, a = 2, c=7)
> >> [1] 2 2
> >>
> >> Which is better for extracting a specific named argument, one<- or
> >> two<- ?  Or a third alternative that is better than both?
> >> Comments and critiques welcome.
> >>
> >> Cheers,
> >> Bert
> >>
> >> ______________________________________________
> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> PLEASE do read the posting guide
> https://www.r-project.org/posting-guide.html
> >> and provide commented, minimal, self-contained, reproducible code.
>
>
>
>

	[[alternative HTML version deleted]]


From j@ork|n @end|ng |rom @om@um@ry|@nd@edu  Tue Jan  7 00:26:25 2025
From: j@ork|n @end|ng |rom @om@um@ry|@nd@edu (Sorkin, John)
Date: Mon, 6 Jan 2025 23:26:25 +0000
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
 <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
Message-ID: <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>

Bert and other on this Chain,

The original question asked by Bert Gunter, highlights one of my long standing wishes. Perhaps my wish has already been fulfilled (if it has, please let me know where I can look of fulfill my wish), if it hasn't perhaps someone can grant me my wish.

I have tried to understand how to write a function (beyond a basic function), get values of the parameters, and process the parameters. I have looked for a source that clearly describes how his may be done (with examples), but I have yet to find one. Yes, one can look at a function (e.g. lm) look at the statements that are used and use the help system to research each of the statements (I have done this), but doing this is not the most efficient way to learn the topic. It would be very helpful if someone Knowledgeable would put together a primer on writing functions and processing function arguments. If such a document exist, I would be happy to have someone send me its URL.

Thank you,
John

John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




________________________________________
From: R-help <r-help-bounces at r-project.org> on behalf of Bert Gunter <bgunter.4567 at gmail.com>
Sent: Monday, January 6, 2025 5:22 PM
To: Jorgen Harmse
Cc: r-help at r-project.org
Subject: Re: [R] Extracting specific arguments from "..."

Thanks Jorgen.

I thought your approach to getting the argument expressions was clever, but
somewhat convoluted. I think the usual simple way is to use match.call()
(or sys.call() )to get the unevaluated argument expressions;  e.g. ...

f <- function(...){
   match.call()
}
> f(a = 'red', b = sin(zzz))
f(a = "red", b = sin(zzz))

The return value is an object of class call that can be subscripted as (or
converted by as.list() to) a list to extract the argument expressions:
> f(a = 'red', b = sin(zzz))$b
sin(zzz)

You'll note that the $b component is again of class "call". So you may wish
to convert it to character or expression or whatever for further
processing, depending on context. Obviously, I haven't thought about this
carefully.

You raise an important point about robustness. I believe this approach to
extracting the call expressions should be fairly robust, but I do get
confused about the lay of the land when you add promises with default
arguments that may not yet have been forced before match.call() is called.
You may have to wrestle with sys.call() and it's "wh" argument to make
things work the way you want in that situation. I leave such delights to
wiser heads, as well as any corrections or refinements to anything that
I've said here.

Cheers,
Bert

On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:

> I think Bert Gunter is right, but do you want partial matches (not found
> by match), and how robust do you want the code to be?
>
>
>
> f <- function(?)
>
> { pos <- match('a', ...names())
>
>   if (is.na(pos))
>
>     stop("a is required.")
>
>   ?elt(pos)
>
> }
>
>
>
> Incidentally, what is the best way to extract the expression without
> evaluating it?
>
>
>
> g <- function(...)
>
> { pos <- match('a',...names())
>
>   if (is.na(pos))
>
>     stop("a is missing.")
>
>   (function(a,...) substitute(a)) (...)
>
> }
>
>
>
> Regards,
>
> Jorgen Harmse.
>
>
>
> Message: 8
> Date: Sun, 5 Jan 2025 11:17:02 -0800
> From: Bert Gunter <bgunter.4567 at gmail.com>
> To: Iris Simmons <ikwsimmo at gmail.com>
> Cc: R-help <R-help at r-project.org>
> Subject: Re: [R] Extracting specific arguments from "..."
> Message-ID:
>         <
> CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Thanks, Iris.
> That is what I suspected, but it wasn't clear to me from the docs.
>
> Best,
> Bert
>
> On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
> >
> > I would use two because it does not force the evaluation of the other
> arguments in the ... list.
> >
> >
> >
> > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
> >>
> >> Consider:
> >>
> >> f1 <- function(...){
> >>   one <- list(...)[['a']]
> >>   two <- ...elt(match('a', ...names()))
> >>   c(one, two)
> >> }
> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
> >> unknown position.
> >>
> >> > f1(b=5, a = 2, c=7)
> >> [1] 2 2
> >>
> >> Which is better for extracting a specific named argument, one<- or
> >> two<- ?  Or a third alternative that is better than both?
> >> Comments and critiques welcome.
> >>
> >> Cheers,
> >> Bert
> >>
> >> ______________________________________________
> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> PLEASE do read the posting guide
> https://www.r-project.org/posting-guide.html
> >> and provide commented, minimal, self-contained, reproducible code.
>
>
>
>

        [[alternative HTML version deleted]]

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.

From bgunter@4567 @end|ng |rom gm@||@com  Tue Jan  7 00:48:55 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Mon, 6 Jan 2025 15:48:55 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
 <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
 <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <CAGxFJbTLgFLgehCnG=V5BDaSPe1AT7vQO_NvAmgJpwAdiN5BZA@mail.gmail.com>

I am frankly at a loss.

Have you read "An Introduction to R," which is shipped with R, especially
Ch. 10. Or any of Hadley's (free, online) books. Or looked at Posit's or
the web's tutorials? There is so much out there...

I would say that the Help docs are meant to be concise references on how to
use particular functions, *not* tutorials on how to write functions in R.
(That said, I have found some of R's Help resources sufficient to learn
techniques that I was ignorant of, regular expressions for example.
However, that is not their purpose, as I said).

Or have I entirely misunderstood you?!

NB. Terminology: Function "arguments" not "parameters". "Parameters"
actually means something different in R.

Cheers,
Bert

On Mon, Jan 6, 2025 at 3:26?PM Sorkin, John <jsorkin at som.umaryland.edu>
wrote:

> Bert and other on this Chain,
>
> The original question asked by Bert Gunter, highlights one of my long
> standing wishes. Perhaps my wish has already been fulfilled (if it has,
> please let me know where I can look of fulfill my wish), if it hasn't
> perhaps someone can grant me my wish.
>
> I have tried to understand how to write a function (beyond a basic
> function), get values of the parameters, and process the parameters. I have
> looked for a source that clearly describes how his may be done (with
> examples), but I have yet to find one. Yes, one can look at a function
> (e.g. lm) look at the statements that are used and use the help system to
> research each of the statements (I have done this), but doing this is not
> the most efficient way to learn the topic. It would be very helpful if
> someone Knowledgeable would put together a primer on writing functions and
> processing function arguments. If such a document exist, I would be happy
> to have someone send me its URL.
>
> Thank you,
> John
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical
> Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of
> Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
>
> ________________________________________
> From: R-help <r-help-bounces at r-project.org> on behalf of Bert Gunter <
> bgunter.4567 at gmail.com>
> Sent: Monday, January 6, 2025 5:22 PM
> To: Jorgen Harmse
> Cc: r-help at r-project.org
> Subject: Re: [R] Extracting specific arguments from "..."
>
> Thanks Jorgen.
>
> I thought your approach to getting the argument expressions was clever, but
> somewhat convoluted. I think the usual simple way is to use match.call()
> (or sys.call() )to get the unevaluated argument expressions;  e.g. ...
>
> f <- function(...){
>    match.call()
> }
> > f(a = 'red', b = sin(zzz))
> f(a = "red", b = sin(zzz))
>
> The return value is an object of class call that can be subscripted as (or
> converted by as.list() to) a list to extract the argument expressions:
> > f(a = 'red', b = sin(zzz))$b
> sin(zzz)
>
> You'll note that the $b component is again of class "call". So you may wish
> to convert it to character or expression or whatever for further
> processing, depending on context. Obviously, I haven't thought about this
> carefully.
>
> You raise an important point about robustness. I believe this approach to
> extracting the call expressions should be fairly robust, but I do get
> confused about the lay of the land when you add promises with default
> arguments that may not yet have been forced before match.call() is called.
> You may have to wrestle with sys.call() and it's "wh" argument to make
> things work the way you want in that situation. I leave such delights to
> wiser heads, as well as any corrections or refinements to anything that
> I've said here.
>
> Cheers,
> Bert
>
> On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:
>
> > I think Bert Gunter is right, but do you want partial matches (not found
> > by match), and how robust do you want the code to be?
> >
> >
> >
> > f <- function(?)
> >
> > { pos <- match('a', ...names())
> >
> >   if (is.na(pos))
> >
> >     stop("a is required.")
> >
> >   ?elt(pos)
> >
> > }
> >
> >
> >
> > Incidentally, what is the best way to extract the expression without
> > evaluating it?
> >
> >
> >
> > g <- function(...)
> >
> > { pos <- match('a',...names())
> >
> >   if (is.na(pos))
> >
> >     stop("a is missing.")
> >
> >   (function(a,...) substitute(a)) (...)
> >
> > }
> >
> >
> >
> > Regards,
> >
> > Jorgen Harmse.
> >
> >
> >
> > Message: 8
> > Date: Sun, 5 Jan 2025 11:17:02 -0800
> > From: Bert Gunter <bgunter.4567 at gmail.com>
> > To: Iris Simmons <ikwsimmo at gmail.com>
> > Cc: R-help <R-help at r-project.org>
> > Subject: Re: [R] Extracting specific arguments from "..."
> > Message-ID:
> >         <
> > CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
> > Content-Type: text/plain; charset="utf-8"
> >
> > Thanks, Iris.
> > That is what I suspected, but it wasn't clear to me from the docs.
> >
> > Best,
> > Bert
> >
> > On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
> > >
> > > I would use two because it does not force the evaluation of the other
> > arguments in the ... list.
> > >
> > >
> > >
> > > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
> > >>
> > >> Consider:
> > >>
> > >> f1 <- function(...){
> > >>   one <- list(...)[['a']]
> > >>   two <- ...elt(match('a', ...names()))
> > >>   c(one, two)
> > >> }
> > >> ## Here "..." is an argument list with "a" somewhere in it, but in an
> > >> unknown position.
> > >>
> > >> > f1(b=5, a = 2, c=7)
> > >> [1] 2 2
> > >>
> > >> Which is better for extracting a specific named argument, one<- or
> > >> two<- ?  Or a third alternative that is better than both?
> > >> Comments and critiques welcome.
> > >>
> > >> Cheers,
> > >> Bert
> > >>
> > >> ______________________________________________
> > >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > >> https://stat.ethz.ch/mailman/listinfo/r-help
> > >> PLEASE do read the posting guide
> > https://www.r-project.org/posting-guide.html
> > >> and provide commented, minimal, self-contained, reproducible code.
> >
> >
> >
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.r-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Tue Jan  7 01:04:16 2025
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Mon, 06 Jan 2025 16:04:16 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
 <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
 <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <8220C27D-591E-4B3D-BFDA-1F28044CC344@dcn.davis.ca.us>

It is a pretty tricky topic, but IMO Advanced R [1] steps you through it systematically... you just have to be prepared to follow along in R with the examples as you read it. In particular, the chapter on Functions goes through this.

The subtleties of how base R gives you control over these topics is what lead to the tidyverse creating new packages to build such function interfaces. Manipulating object evaluation from arbitrary environments is still complex, and the more you learn about it the more you learn to avoid it for certain types of tasks. String literals are surprisingly simple alternatives that don't bite you in the butt nearly so often as NSE does.

[1] https://adv-r.hadley.nz/

On January 6, 2025 3:26:25 PM PST, "Sorkin, John" <jsorkin at som.umaryland.edu> wrote:
>Bert and other on this Chain,
>
>The original question asked by Bert Gunter, highlights one of my long standing wishes. Perhaps my wish has already been fulfilled (if it has, please let me know where I can look of fulfill my wish), if it hasn't perhaps someone can grant me my wish.
>
>I have tried to understand how to write a function (beyond a basic function), get values of the parameters, and process the parameters. I have looked for a source that clearly describes how his may be done (with examples), but I have yet to find one. Yes, one can look at a function (e.g. lm) look at the statements that are used and use the help system to research each of the statements (I have done this), but doing this is not the most efficient way to learn the topic. It would be very helpful if someone Knowledgeable would put together a primer on writing functions and processing function arguments. If such a document exist, I would be happy to have someone send me its URL.
>
>Thank you,
>John
>
>John David Sorkin M.D., Ph.D.
>Professor of Medicine, University of Maryland School of Medicine;
>Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
>PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
>Senior Statistician University of Maryland Center for Vascular Research;
>
>Division of Gerontology and Paliative Care,
>10 North Greene Street
>GRECC (BT/18/GR)
>Baltimore, MD 21201-1524
>Cell phone 443-418-5382
>
>
>
>
>________________________________________
>From: R-help <r-help-bounces at r-project.org> on behalf of Bert Gunter <bgunter.4567 at gmail.com>
>Sent: Monday, January 6, 2025 5:22 PM
>To: Jorgen Harmse
>Cc: r-help at r-project.org
>Subject: Re: [R] Extracting specific arguments from "..."
>
>Thanks Jorgen.
>
>I thought your approach to getting the argument expressions was clever, but
>somewhat convoluted. I think the usual simple way is to use match.call()
>(or sys.call() )to get the unevaluated argument expressions;  e.g. ...
>
>f <- function(...){
>   match.call()
>}
>> f(a = 'red', b = sin(zzz))
>f(a = "red", b = sin(zzz))
>
>The return value is an object of class call that can be subscripted as (or
>converted by as.list() to) a list to extract the argument expressions:
>> f(a = 'red', b = sin(zzz))$b
>sin(zzz)
>
>You'll note that the $b component is again of class "call". So you may wish
>to convert it to character or expression or whatever for further
>processing, depending on context. Obviously, I haven't thought about this
>carefully.
>
>You raise an important point about robustness. I believe this approach to
>extracting the call expressions should be fairly robust, but I do get
>confused about the lay of the land when you add promises with default
>arguments that may not yet have been forced before match.call() is called.
>You may have to wrestle with sys.call() and it's "wh" argument to make
>things work the way you want in that situation. I leave such delights to
>wiser heads, as well as any corrections or refinements to anything that
>I've said here.
>
>Cheers,
>Bert
>
>On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:
>
>> I think Bert Gunter is right, but do you want partial matches (not found
>> by match), and how robust do you want the code to be?
>>
>>
>>
>> f <- function(?)
>>
>> { pos <- match('a', ...names())
>>
>>   if (is.na(pos))
>>
>>     stop("a is required.")
>>
>>   ?elt(pos)
>>
>> }
>>
>>
>>
>> Incidentally, what is the best way to extract the expression without
>> evaluating it?
>>
>>
>>
>> g <- function(...)
>>
>> { pos <- match('a',...names())
>>
>>   if (is.na(pos))
>>
>>     stop("a is missing.")
>>
>>   (function(a,...) substitute(a)) (...)
>>
>> }
>>
>>
>>
>> Regards,
>>
>> Jorgen Harmse.
>>
>>
>>
>> Message: 8
>> Date: Sun, 5 Jan 2025 11:17:02 -0800
>> From: Bert Gunter <bgunter.4567 at gmail.com>
>> To: Iris Simmons <ikwsimmo at gmail.com>
>> Cc: R-help <R-help at r-project.org>
>> Subject: Re: [R] Extracting specific arguments from "..."
>> Message-ID:
>>         <
>> CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> Thanks, Iris.
>> That is what I suspected, but it wasn't clear to me from the docs.
>>
>> Best,
>> Bert
>>
>> On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
>> >
>> > I would use two because it does not force the evaluation of the other
>> arguments in the ... list.
>> >
>> >
>> >
>> > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
>> >>
>> >> Consider:
>> >>
>> >> f1 <- function(...){
>> >>   one <- list(...)[['a']]
>> >>   two <- ...elt(match('a', ...names()))
>> >>   c(one, two)
>> >> }
>> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> >> unknown position.
>> >>
>> >> > f1(b=5, a = 2, c=7)
>> >> [1] 2 2
>> >>
>> >> Which is better for extracting a specific named argument, one<- or
>> >> two<- ?  Or a third alternative that is better than both?
>> >> Comments and critiques welcome.
>> >>
>> >> Cheers,
>> >> Bert
>> >>
>> >> ______________________________________________
>> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> >> https://stat.ethz.ch/mailman/listinfo/r-help
>> >> PLEASE do read the posting guide
>> https://www.r-project.org/posting-guide.html
>> >> and provide commented, minimal, self-contained, reproducible code.
>>
>>
>>
>>
>
>        [[alternative HTML version deleted]]
>
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.

-- 
Sent from my phone. Please excuse my brevity.


From bgunter@4567 @end|ng |rom gm@||@com  Tue Jan  7 02:15:59 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Mon, 6 Jan 2025 17:15:59 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <8220C27D-591E-4B3D-BFDA-1F28044CC344@dcn.davis.ca.us>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
 <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
 <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
 <8220C27D-591E-4B3D-BFDA-1F28044CC344@dcn.davis.ca.us>
Message-ID: <CAGxFJbS1iUr-Tu5oTXGU=gtXh1B9GgznEcxvMh-P434j-UFELQ@mail.gmail.com>

Jeff:
Would you care to offer an example of:

"String literals are surprisingly simple alternatives that don't bite you
in the butt nearly so often as NSE does."

"No" is a perfectly acceptable answer.

I would generally agree with you about NSE, but my original query was
motivated by something simple. I like to use lattice graphics when I fool
around with graphing data, as I'm retired and don't have to worry about
adhering to organizational or journal standards built around the ggplot
graphics grammar or require it's very extensive and sophisticated
capabilities. But I do often create custom panel displays, which typically
requires that I have to pass around long default lists of graphics
arguments via "..." that I modify to suit my aesthetic and analytical
preferences. Ergo my query about how to check what's in the "..." list
without requiring evaluation, which Iris helped me with.

I would also suggest that as a personal user of R for "data science stuff",
one can avoid a lot of the complexities to which you allude; while as a
developer of "tools" (chiefly packages) for others, one has to wade into a
lot of those complexities. This is just a software clich? I think.
Unfortunately, S and therefore R, were originally designed for a pretty
sophisticated audience (ATT labs researchers) and intentionally, and to me
rather seductively, blurred the line between "user" and "developer."  All
IMO, of course. YMMV.

Cheers,
Bert


On Mon, Jan 6, 2025 at 4:04?PM Jeff Newmiller <jdnewmil at dcn.davis.ca.us>
wrote:

> It is a pretty tricky topic, but IMO Advanced R [1] steps you through it
> systematically... you just have to be prepared to follow along in R with
> the examples as you read it. In particular, the chapter on Functions goes
> through this.
>
> The subtleties of how base R gives you control over these topics is what
> lead to the tidyverse creating new packages to build such function
> interfaces. Manipulating object evaluation from arbitrary environments is
> still complex, and the more you learn about it the more you learn to avoid
> it for certain types of tasks. String literals are surprisingly simple
> alternatives that don't bite you in the butt nearly so often as NSE does.
>
> [1] https://adv-r.hadley.nz/
>
> On January 6, 2025 3:26:25 PM PST, "Sorkin, John" <
> jsorkin at som.umaryland.edu> wrote:
> >Bert and other on this Chain,
> >
> >The original question asked by Bert Gunter, highlights one of my long
> standing wishes. Perhaps my wish has already been fulfilled (if it has,
> please let me know where I can look of fulfill my wish), if it hasn't
> perhaps someone can grant me my wish.
> >
> >I have tried to understand how to write a function (beyond a basic
> function), get values of the parameters, and process the parameters. I have
> looked for a source that clearly describes how his may be done (with
> examples), but I have yet to find one. Yes, one can look at a function
> (e.g. lm) look at the statements that are used and use the help system to
> research each of the statements (I have done this), but doing this is not
> the most efficient way to learn the topic. It would be very helpful if
> someone Knowledgeable would put together a primer on writing functions and
> processing function arguments. If such a document exist, I would be happy
> to have someone send me its URL.
> >
> >Thank you,
> >John
> >
> >John David Sorkin M.D., Ph.D.
> >Professor of Medicine, University of Maryland School of Medicine;
> >Associate Director for Biostatistics and Informatics, Baltimore VA
> Medical Center Geriatrics Research, Education, and Clinical Center;
> >PI Biostatistics and Informatics Core, University of Maryland School of
> Medicine Claude D. Pepper Older Americans Independence Center;
> >Senior Statistician University of Maryland Center for Vascular Research;
> >
> >Division of Gerontology and Paliative Care,
> >10 North Greene Street
> >GRECC (BT/18/GR)
> >Baltimore, MD 21201-1524
> >Cell phone 443-418-5382
> >
> >
> >
> >
> >________________________________________
> >From: R-help <r-help-bounces at r-project.org> on behalf of Bert Gunter <
> bgunter.4567 at gmail.com>
> >Sent: Monday, January 6, 2025 5:22 PM
> >To: Jorgen Harmse
> >Cc: r-help at r-project.org
> >Subject: Re: [R] Extracting specific arguments from "..."
> >
> >Thanks Jorgen.
> >
> >I thought your approach to getting the argument expressions was clever,
> but
> >somewhat convoluted. I think the usual simple way is to use match.call()
> >(or sys.call() )to get the unevaluated argument expressions;  e.g. ...
> >
> >f <- function(...){
> >   match.call()
> >}
> >> f(a = 'red', b = sin(zzz))
> >f(a = "red", b = sin(zzz))
> >
> >The return value is an object of class call that can be subscripted as (or
> >converted by as.list() to) a list to extract the argument expressions:
> >> f(a = 'red', b = sin(zzz))$b
> >sin(zzz)
> >
> >You'll note that the $b component is again of class "call". So you may
> wish
> >to convert it to character or expression or whatever for further
> >processing, depending on context. Obviously, I haven't thought about this
> >carefully.
> >
> >You raise an important point about robustness. I believe this approach to
> >extracting the call expressions should be fairly robust, but I do get
> >confused about the lay of the land when you add promises with default
> >arguments that may not yet have been forced before match.call() is called.
> >You may have to wrestle with sys.call() and it's "wh" argument to make
> >things work the way you want in that situation. I leave such delights to
> >wiser heads, as well as any corrections or refinements to anything that
> >I've said here.
> >
> >Cheers,
> >Bert
> >
> >On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:
> >
> >> I think Bert Gunter is right, but do you want partial matches (not found
> >> by match), and how robust do you want the code to be?
> >>
> >>
> >>
> >> f <- function(?)
> >>
> >> { pos <- match('a', ...names())
> >>
> >>   if (is.na(pos))
> >>
> >>     stop("a is required.")
> >>
> >>   ?elt(pos)
> >>
> >> }
> >>
> >>
> >>
> >> Incidentally, what is the best way to extract the expression without
> >> evaluating it?
> >>
> >>
> >>
> >> g <- function(...)
> >>
> >> { pos <- match('a',...names())
> >>
> >>   if (is.na(pos))
> >>
> >>     stop("a is missing.")
> >>
> >>   (function(a,...) substitute(a)) (...)
> >>
> >> }
> >>
> >>
> >>
> >> Regards,
> >>
> >> Jorgen Harmse.
> >>
> >>
> >>
> >> Message: 8
> >> Date: Sun, 5 Jan 2025 11:17:02 -0800
> >> From: Bert Gunter <bgunter.4567 at gmail.com>
> >> To: Iris Simmons <ikwsimmo at gmail.com>
> >> Cc: R-help <R-help at r-project.org>
> >> Subject: Re: [R] Extracting specific arguments from "..."
> >> Message-ID:
> >>         <
> >> CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
> >> Content-Type: text/plain; charset="utf-8"
> >>
> >> Thanks, Iris.
> >> That is what I suspected, but it wasn't clear to me from the docs.
> >>
> >> Best,
> >> Bert
> >>
> >> On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com>
> wrote:
> >> >
> >> > I would use two because it does not force the evaluation of the other
> >> arguments in the ... list.
> >> >
> >> >
> >> >
> >> > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com>
> wrote:
> >> >>
> >> >> Consider:
> >> >>
> >> >> f1 <- function(...){
> >> >>   one <- list(...)[['a']]
> >> >>   two <- ...elt(match('a', ...names()))
> >> >>   c(one, two)
> >> >> }
> >> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
> >> >> unknown position.
> >> >>
> >> >> > f1(b=5, a = 2, c=7)
> >> >> [1] 2 2
> >> >>
> >> >> Which is better for extracting a specific named argument, one<- or
> >> >> two<- ?  Or a third alternative that is better than both?
> >> >> Comments and critiques welcome.
> >> >>
> >> >> Cheers,
> >> >> Bert
> >> >>
> >> >> ______________________________________________
> >> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> >> PLEASE do read the posting guide
> >> https://www.r-project.org/posting-guide.html
> >> >> and provide commented, minimal, self-contained, reproducible code.
> >>
> >>
> >>
> >>
> >
> >        [[alternative HTML version deleted]]
> >
> >______________________________________________
> >R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >https://stat.ethz.ch/mailman/listinfo/r-help
> >PLEASE do read the posting guide
> https://www.r-project.org/posting-guide.html
> >and provide commented, minimal, self-contained, reproducible code.
> >______________________________________________
> >R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >https://stat.ethz.ch/mailman/listinfo/r-help
> >PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> >and provide commented, minimal, self-contained, reproducible code.
>
> --
> Sent from my phone. Please excuse my brevity.
>

	[[alternative HTML version deleted]]


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Tue Jan  7 08:23:34 2025
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Mon, 06 Jan 2025 23:23:34 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAGxFJbS1iUr-Tu5oTXGU=gtXh1B9GgznEcxvMh-P434j-UFELQ@mail.gmail.com>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
 <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
 <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
 <8220C27D-591E-4B3D-BFDA-1F28044CC344@dcn.davis.ca.us>
 <CAGxFJbS1iUr-Tu5oTXGU=gtXh1B9GgznEcxvMh-P434j-UFELQ@mail.gmail.com>
Message-ID: <DC69F297-832A-4591-9BB6-CBEC215D4968@dcn.davis.ca.us>

I have no particular example in mind, though if your data are in lists (e.g. data frames) or better yet you want to add new data to a list then a particular trap for inexperienced analysts is trying to capture the name of the not-yet-created item from a symbol instead of simply giving the function a string to label the new item with.

I must say playing around with ... seems tediously unpleasant to me... to each their own though. I prefer to let R handle that... if I want to tweak a variable being passed I just declare the parameter explicitly and pass it along explicitly. As long as it has a default value the calling function shouldn't care... unless it is also abusing ....

On January 6, 2025 5:15:59 PM PST, Bert Gunter <bgunter.4567 at gmail.com> wrote:
>Jeff:
>Would you care to offer an example of:
>
>"String literals are surprisingly simple alternatives that don't bite you
>in the butt nearly so often as NSE does."
>
>"No" is a perfectly acceptable answer.
>
>I would generally agree with you about NSE, but my original query was
>motivated by something simple. I like to use lattice graphics when I fool
>around with graphing data, as I'm retired and don't have to worry about
>adhering to organizational or journal standards built around the ggplot
>graphics grammar or require it's very extensive and sophisticated
>capabilities. But I do often create custom panel displays, which typically
>requires that I have to pass around long default lists of graphics
>arguments via "..." that I modify to suit my aesthetic and analytical
>preferences. Ergo my query about how to check what's in the "..." list
>without requiring evaluation, which Iris helped me with.
>
>I would also suggest that as a personal user of R for "data science stuff",
>one can avoid a lot of the complexities to which you allude; while as a
>developer of "tools" (chiefly packages) for others, one has to wade into a
>lot of those complexities. This is just a software clich? I think.
>Unfortunately, S and therefore R, were originally designed for a pretty
>sophisticated audience (ATT labs researchers) and intentionally, and to me
>rather seductively, blurred the line between "user" and "developer."  All
>IMO, of course. YMMV.
>
>Cheers,
>Bert
>
>
>On Mon, Jan 6, 2025 at 4:04?PM Jeff Newmiller <jdnewmil at dcn.davis.ca.us>
>wrote:
>
>> It is a pretty tricky topic, but IMO Advanced R [1] steps you through it
>> systematically... you just have to be prepared to follow along in R with
>> the examples as you read it. In particular, the chapter on Functions goes
>> through this.
>>
>> The subtleties of how base R gives you control over these topics is what
>> lead to the tidyverse creating new packages to build such function
>> interfaces. Manipulating object evaluation from arbitrary environments is
>> still complex, and the more you learn about it the more you learn to avoid
>> it for certain types of tasks. String literals are surprisingly simple
>> alternatives that don't bite you in the butt nearly so often as NSE does.
>>
>> [1] https://adv-r.hadley.nz/
>>
>> On January 6, 2025 3:26:25 PM PST, "Sorkin, John" <
>> jsorkin at som.umaryland.edu> wrote:
>> >Bert and other on this Chain,
>> >
>> >The original question asked by Bert Gunter, highlights one of my long
>> standing wishes. Perhaps my wish has already been fulfilled (if it has,
>> please let me know where I can look of fulfill my wish), if it hasn't
>> perhaps someone can grant me my wish.
>> >
>> >I have tried to understand how to write a function (beyond a basic
>> function), get values of the parameters, and process the parameters. I have
>> looked for a source that clearly describes how his may be done (with
>> examples), but I have yet to find one. Yes, one can look at a function
>> (e.g. lm) look at the statements that are used and use the help system to
>> research each of the statements (I have done this), but doing this is not
>> the most efficient way to learn the topic. It would be very helpful if
>> someone Knowledgeable would put together a primer on writing functions and
>> processing function arguments. If such a document exist, I would be happy
>> to have someone send me its URL.
>> >
>> >Thank you,
>> >John
>> >
>> >John David Sorkin M.D., Ph.D.
>> >Professor of Medicine, University of Maryland School of Medicine;
>> >Associate Director for Biostatistics and Informatics, Baltimore VA
>> Medical Center Geriatrics Research, Education, and Clinical Center;
>> >PI Biostatistics and Informatics Core, University of Maryland School of
>> Medicine Claude D. Pepper Older Americans Independence Center;
>> >Senior Statistician University of Maryland Center for Vascular Research;
>> >
>> >Division of Gerontology and Paliative Care,
>> >10 North Greene Street
>> >GRECC (BT/18/GR)
>> >Baltimore, MD 21201-1524
>> >Cell phone 443-418-5382
>> >
>> >
>> >
>> >
>> >________________________________________
>> >From: R-help <r-help-bounces at r-project.org> on behalf of Bert Gunter <
>> bgunter.4567 at gmail.com>
>> >Sent: Monday, January 6, 2025 5:22 PM
>> >To: Jorgen Harmse
>> >Cc: r-help at r-project.org
>> >Subject: Re: [R] Extracting specific arguments from "..."
>> >
>> >Thanks Jorgen.
>> >
>> >I thought your approach to getting the argument expressions was clever,
>> but
>> >somewhat convoluted. I think the usual simple way is to use match.call()
>> >(or sys.call() )to get the unevaluated argument expressions;  e.g. ...
>> >
>> >f <- function(...){
>> >   match.call()
>> >}
>> >> f(a = 'red', b = sin(zzz))
>> >f(a = "red", b = sin(zzz))
>> >
>> >The return value is an object of class call that can be subscripted as (or
>> >converted by as.list() to) a list to extract the argument expressions:
>> >> f(a = 'red', b = sin(zzz))$b
>> >sin(zzz)
>> >
>> >You'll note that the $b component is again of class "call". So you may
>> wish
>> >to convert it to character or expression or whatever for further
>> >processing, depending on context. Obviously, I haven't thought about this
>> >carefully.
>> >
>> >You raise an important point about robustness. I believe this approach to
>> >extracting the call expressions should be fairly robust, but I do get
>> >confused about the lay of the land when you add promises with default
>> >arguments that may not yet have been forced before match.call() is called.
>> >You may have to wrestle with sys.call() and it's "wh" argument to make
>> >things work the way you want in that situation. I leave such delights to
>> >wiser heads, as well as any corrections or refinements to anything that
>> >I've said here.
>> >
>> >Cheers,
>> >Bert
>> >
>> >On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:
>> >
>> >> I think Bert Gunter is right, but do you want partial matches (not found
>> >> by match), and how robust do you want the code to be?
>> >>
>> >>
>> >>
>> >> f <- function(?)
>> >>
>> >> { pos <- match('a', ...names())
>> >>
>> >>   if (is.na(pos))
>> >>
>> >>     stop("a is required.")
>> >>
>> >>   ?elt(pos)
>> >>
>> >> }
>> >>
>> >>
>> >>
>> >> Incidentally, what is the best way to extract the expression without
>> >> evaluating it?
>> >>
>> >>
>> >>
>> >> g <- function(...)
>> >>
>> >> { pos <- match('a',...names())
>> >>
>> >>   if (is.na(pos))
>> >>
>> >>     stop("a is missing.")
>> >>
>> >>   (function(a,...) substitute(a)) (...)
>> >>
>> >> }
>> >>
>> >>
>> >>
>> >> Regards,
>> >>
>> >> Jorgen Harmse.
>> >>
>> >>
>> >>
>> >> Message: 8
>> >> Date: Sun, 5 Jan 2025 11:17:02 -0800
>> >> From: Bert Gunter <bgunter.4567 at gmail.com>
>> >> To: Iris Simmons <ikwsimmo at gmail.com>
>> >> Cc: R-help <R-help at r-project.org>
>> >> Subject: Re: [R] Extracting specific arguments from "..."
>> >> Message-ID:
>> >>         <
>> >> CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
>> >> Content-Type: text/plain; charset="utf-8"
>> >>
>> >> Thanks, Iris.
>> >> That is what I suspected, but it wasn't clear to me from the docs.
>> >>
>> >> Best,
>> >> Bert
>> >>
>> >> On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com>
>> wrote:
>> >> >
>> >> > I would use two because it does not force the evaluation of the other
>> >> arguments in the ... list.
>> >> >
>> >> >
>> >> >
>> >> > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com>
>> wrote:
>> >> >>
>> >> >> Consider:
>> >> >>
>> >> >> f1 <- function(...){
>> >> >>   one <- list(...)[['a']]
>> >> >>   two <- ...elt(match('a', ...names()))
>> >> >>   c(one, two)
>> >> >> }
>> >> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> >> >> unknown position.
>> >> >>
>> >> >> > f1(b=5, a = 2, c=7)
>> >> >> [1] 2 2
>> >> >>
>> >> >> Which is better for extracting a specific named argument, one<- or
>> >> >> two<- ?  Or a third alternative that is better than both?
>> >> >> Comments and critiques welcome.
>> >> >>
>> >> >> Cheers,
>> >> >> Bert
>> >> >>
>> >> >> ______________________________________________
>> >> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> >> >> https://stat.ethz.ch/mailman/listinfo/r-help
>> >> >> PLEASE do read the posting guide
>> >> https://www.r-project.org/posting-guide.html
>> >> >> and provide commented, minimal, self-contained, reproducible code.
>> >>
>> >>
>> >>
>> >>
>> >
>> >        [[alternative HTML version deleted]]
>> >
>> >______________________________________________
>> >R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> >https://stat.ethz.ch/mailman/listinfo/r-help
>> >PLEASE do read the posting guide
>> https://www.r-project.org/posting-guide.html
>> >and provide commented, minimal, self-contained, reproducible code.
>> >______________________________________________
>> >R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> >https://stat.ethz.ch/mailman/listinfo/r-help
>> >PLEASE do read the posting guide
>> https://www.R-project.org/posting-guide.html
>> >and provide commented, minimal, self-contained, reproducible code.
>>
>> --
>> Sent from my phone. Please excuse my brevity.
>>

-- 
Sent from my phone. Please excuse my brevity.


From m||@nd_j @end|ng |rom hotm@||@com  Mon Jan  6 12:03:46 2025
From: m||@nd_j @end|ng |rom hotm@||@com (Miland Joshi)
Date: Mon, 6 Jan 2025 11:03:46 +0000
Subject: [R] Possible bug in direct.evidence.plot?
In-Reply-To: <CAGgJW74LDza5WL2FRXODpobe9GSTA1a5L04d3ODORwvBHHtKpg@mail.gmail.com>
References: <DB7PR09MB2506A927224E142AC89E9DFEF9172@DB7PR09MB2506.eurprd09.prod.outlook.com>
 <CAGgJW74LDza5WL2FRXODpobe9GSTA1a5L04d3ODORwvBHHtKpg@mail.gmail.com>
Message-ID: <DB7PR09MB2506480D2D7136FA27C7306EF9102@DB7PR09MB2506.eurprd09.prod.outlook.com>

Hello

In R when I looked at the class of nb1 I got:
> class(nb1)
[1] "netmetabin" "netmeta"

which suggests that netmeta might work but netmetabin may cause problems. I'll notify Mathias Harrer!

BW
Miland

________________________________
From: Eric Berger <ericjberger at gmail.com>
Sent: 06 January 2025 08:24
To: Miland Joshi <miland_j at hotmail.com>
Cc: r-help at R-project.org <r-help at r-project.org>
Subject: Re: [R] Possible bug in direct.evidence.plot?

The explanation is likely that class(x) returns a character vector of length > 1.
If you go into the code you can achieve what is probably intended without triggering this error by replacing that statement with the following:

if (inherits(x,"netmeta")) ...

HTH,
Eric


On Mon, Jan 6, 2025 at 9:57?AM Miland Joshi <miland_j at hotmail.com<mailto:miland_j at hotmail.com>> wrote:
I succeeded in getting netmetabin to work, but when trying to use direct.evidence.plot I ran into a problem:

> nb1evid <- direct.evidence.plot(nb1)
Error in if (class(x) != "netmeta") { : the condition has length > 1

I tried updating netmeta and dmetar (and dmetafor) from R, but the problem remains.
Has anyone come across this, and could it be a bug?

Regards
Miland Joshi

        [[alternative HTML version deleted]]

______________________________________________
R-help at r-project.org<mailto:R-help at r-project.org> mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.

	[[alternative HTML version deleted]]


From JH@rm@e @end|ng |rom roku@com  Tue Jan  7 19:47:11 2025
From: JH@rm@e @end|ng |rom roku@com (Jorgen Harmse)
Date: Tue, 7 Jan 2025 18:47:11 +0000
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
Message-ID: <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>

Interesting discussion. A few things occurred to me.

Apologies to Iris Simmons: I mixed up his answer with Bert's question.

Bert raises questions about promises, and I think they are related to John Sorkin's question. A big difference between R and most other languages is that function arguments are computed lazily. match.call & substitute tell us what expressions will be evaluated if function arguments are needed but not the environments in which that will happen. The usual suspects are environment() and parent.frame(), but parent.frame(k) & maybe even other environments are possible. If you are really determined then I guess you can keep evaluating match.call() in parent frames until you have accounted for all the inputs.

It's not clear to what extent John Sorkin is concerned about writing functions as opposed to using functions. Lazy computation has advantages but leads to some issues.
Exactly matching the function's default expression for an input is not necessarily the same as omitting the input. The evaluation environment is different.
If the caller uses an expression with side effects then there is no guarantee that the side effects will happen. If there are side effects from two or more inputs then the order is uncertain. (If an argument is not supplied and the default has side effects then they might not happen either. However, I don't know why the function writer would specify any side effect except stop(), and then he or she has probably arranged for it to happen exactly when it should.)
If a default value depends on another input and that input is modified inside the function then order of evaluation of inputs becomes important. Even if you know exactly what you're doing when you write the function, you should make it clear to future maintainers. An explicit call to force clarifies that the input needs to be computed with the existing values of anything that is used in the default, even if the code is refactored so that the value is not used immediately. If you really want to modify another input before evaluating the default then specify that in a comment.

Jeff Newmiller makes a good point. You can still change your mind about inspecting a particular input without breaking old code that uses your function, and you don?t necessarily need default values.

Old definition: f <- function(?) {<code that passes ? to other functions and does some other things>}

New definition:
f <- function(?, a = <default expression, possibly stop()>)
{ <pass ?, a=a to another function>
  <do something with the output>
}

OR

f <- function(?, a)
{ if (missing(a)) # OK, this becomes clunky if there are several such inputs
  { < pass ? to another function >}
  else
 { <inspect or modify a> # Pitfall: Changing the order of evaluation may break old code, but then the design was probably too devious in the first place.
    <pass ?, a=a to another function>
  }
  <do something with the output>
}

Regards,
Jorgen Harmse.




	[[alternative HTML version deleted]]


From j@ork|n @end|ng |rom @om@um@ry|@nd@edu  Tue Jan  7 23:03:02 2025
From: j@ork|n @end|ng |rom @om@um@ry|@nd@edu (Sorkin, John)
Date: Tue, 7 Jan 2025 22:03:02 +0000
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
 <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
Message-ID: <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>

Colleagues,

My interest is not in writing ad hoc functions (which I might use once to analyze my data), but rather what I will call a system function that might be part of a package. The lm function is a paradigm of what I call a system function. 

The lm function begins by processing the arguments passed to the function (represented in the function as parameters, see code below.) Much of this processing is only peripherally related to running a regression, but the code is necessary to determine exactly what the user of the system function wants the function to do. It would be helpful if there was a document that would describe best practices when writing system functions, with clear explanations of what each step in system function is designed to do and how the line accomplishes its task. It would also be nice if the system function had documentation. I have pushed my way through the lm function, and with the help of R help files, I have come to understand how the function works, but this is not an efficient way to learn best practices that should be used when writing a system function. 

Perhaps there is a document that does what I would like to see done, but I do not know of one.  

John

lmlm
function (formula, data, subset, weights, na.action, method = "qr",
    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
    contrasts = NULL, offset, ...)
{
    ret.x <- x
    ret.y <- y
    cl <- match.call()
    mf <- match.call(expand.dots = FALSE)
    m <- match(c("formula", "data", "subset", "weights", "na.action",
        "offset"), names(mf), 0L)
    mf <- mf[c(1L, m)]
    mf$drop.unused.levels <- TRUE
    mf[[1L]] <- quote(stats::model.frame)
    mf <- eval(mf, parent.frame())
    if (method == "model.frame")
        return(mf)
    else if (method != "qr")
        warning(gettextf("method = '%s' is not supported. Using 'qr'",
            method), domain = NA)
    mt <- attr(mf, "terms")
    y <- model.response(mf, "numeric")
    w <- as.vector(model.weights(mf))
    if (!is.null(w) && !is.numeric(w))
        stop("'weights' must be a numeric vector")
    offset <- model.offset(mf)
    mlm <- is.matrix(y)
    ny <- if (mlm)
        nrow(y)
    else length(y)
    if (!is.null(offset)) {
        if (!mlm)
            offset <- as.vector(offset)
        if (NROW(offset) != ny)
            stop(gettextf("number of offsets is %d, should equal %d (number of observations)",
                NROW(offset), ny), domain = NA)
    }
    if (is.empty.model(mt)) {
        x <- NULL
        z <- list(coefficients = if (mlm) matrix(NA_real_, 0,
            ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
            y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w !=
            0) else ny)
        if (!is.null(offset)) {
            z$fitted.values <- offset
            z$residuals <- y - offset
        }
    }
    else {
        x <- model.matrix(mt, mf, contrasts)
        z <- if (is.null(w))
            lm.fit(x, y, offset = offset, singular.ok = singular.ok,
                ...)
        else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
            ...)
    }
    class(z) <- c(if (mlm) "mlm", "lm")
    z$na.action <- attr(mf, "na.action")
    z$offset <- offset
    z$contrasts <- attr(x, "contrasts")
    z$xlevels <- .getXlevels(mt, mf)
    z$call <- cl
    z$terms <- mt
    if (model)
        z$model <- mf
    if (ret.x)
        z$x <- x
    if (ret.y)
        z$y <- y
    if (!qr)
        z$qr <- NULL
    z
}



John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;?
PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




________________________________________
From: Jorgen Harmse <JHarmse at roku.com>
Sent: Tuesday, January 7, 2025 1:47 PM
To: r-help at r-project.org; ikwsimmo at gmail.com; Bert Gunter; Sorkin, John; jdnewmil at dcn.davis.ca.us
Subject: Re: Extracting specific arguments from "..."

Interesting discussion. A few things occurred to me.

Apologies to Iris Simmons: I mixed up his answer with Bert's question.

Bert raises questions about promises, and I think they are related to John Sorkin's question. A big difference between R and most other languages is that function arguments are computed lazily. match.call & substitute tell us what expressions will be evaluated if function arguments are needed but not the environments in which that will happen. The usual suspects are environment() and parent.frame(), but parent.frame(k) & maybe even other environments are possible. If you are really determined then I guess you can keep evaluating match.call() in parent frames until you have accounted for all the inputs.

It's not clear to what extent John Sorkin is concerned about writing functions as opposed to using functions. Lazy computation has advantages but leads to some issues.
Exactly matching the function's default expression for an input is not necessarily the same as omitting the input. The evaluation environment is different.
If the caller uses an expression with side effects then there is no guarantee that the side effects will happen. If there are side effects from two or more inputs then the order is uncertain. (If an argument is not supplied and the default has side effects then they might not happen either. However, I don't know why the function writer would specify any side effect except stop(), and then he or she has probably arranged for it to happen exactly when it should.)
If a default value depends on another input and that input is modified inside the function then order of evaluation of inputs becomes important. Even if you know exactly what you're doing when you write the function, you should make it clear to future maintainers. An explicit call to force clarifies that the input needs to be computed with the existing values of anything that is used in the default, even if the code is refactored so that the value is not used immediately. If you really want to modify another input before evaluating the default then specify that in a comment.

Jeff Newmiller makes a good point. You can still change your mind about inspecting a particular input without breaking old code that uses your function, and you don?t necessarily need default values.

Old definition: f <- function(?) {<code that passes ? to other functions and does some other things>}

New definition:
f <- function(?, a = <default expression, possibly stop()>)
{ <pass ?, a=a to another function>
  <do something with the output>
}

OR

f <- function(?, a)
{ if (missing(a)) # OK, this becomes clunky if there are several such inputs
  { < pass ? to another function >}
  else
 { <inspect or modify a> # Pitfall: Changing the order of evaluation may break old code, but then the design was probably too devious in the first place.
    <pass ?, a=a to another function>
  }
  <do something with the output>
}

Regards,
Jorgen Harmse.





From bbo|ker @end|ng |rom gm@||@com  Tue Jan  7 23:06:08 2025
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Tue, 7 Jan 2025 17:06:08 -0500
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
 <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
 <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <719c700b-f706-458c-8e4e-8cc223c8b5df@gmail.com>


   There's an ancient (2003) document on the CRAN "developers' page" 
https://developer.r-project.org/model-fitting-functions.html that is 
sort of (but not exactly) what you're looking for ...


On 2025-01-07 5:03 p.m., Sorkin, John wrote:
> Colleagues,
> 
> My interest is not in writing ad hoc functions (which I might use once to analyze my data), but rather what I will call a system function that might be part of a package. The lm function is a paradigm of what I call a system function.
> 
> The lm function begins by processing the arguments passed to the function (represented in the function as parameters, see code below.) Much of this processing is only peripherally related to running a regression, but the code is necessary to determine exactly what the user of the system function wants the function to do. It would be helpful if there was a document that would describe best practices when writing system functions, with clear explanations of what each step in system function is designed to do and how the line accomplishes its task. It would also be nice if the system function had documentation. I have pushed my way through the lm function, and with the help of R help files, I have come to understand how the function works, but this is not an efficient way to learn best practices that should be used when writing a system function.
> 
> Perhaps there is a document that does what I would like to see done, but I do not know of one.
> 
> John
> 
> lmlm
> function (formula, data, subset, weights, na.action, method = "qr",
>      model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
>      contrasts = NULL, offset, ...)
> {
>      ret.x <- x
>      ret.y <- y
>      cl <- match.call()
>      mf <- match.call(expand.dots = FALSE)
>      m <- match(c("formula", "data", "subset", "weights", "na.action",
>          "offset"), names(mf), 0L)
>      mf <- mf[c(1L, m)]
>      mf$drop.unused.levels <- TRUE
>      mf[[1L]] <- quote(stats::model.frame)
>      mf <- eval(mf, parent.frame())
>      if (method == "model.frame")
>          return(mf)
>      else if (method != "qr")
>          warning(gettextf("method = '%s' is not supported. Using 'qr'",
>              method), domain = NA)
>      mt <- attr(mf, "terms")
>      y <- model.response(mf, "numeric")
>      w <- as.vector(model.weights(mf))
>      if (!is.null(w) && !is.numeric(w))
>          stop("'weights' must be a numeric vector")
>      offset <- model.offset(mf)
>      mlm <- is.matrix(y)
>      ny <- if (mlm)
>          nrow(y)
>      else length(y)
>      if (!is.null(offset)) {
>          if (!mlm)
>              offset <- as.vector(offset)
>          if (NROW(offset) != ny)
>              stop(gettextf("number of offsets is %d, should equal %d (number of observations)",
>                  NROW(offset), ny), domain = NA)
>      }
>      if (is.empty.model(mt)) {
>          x <- NULL
>          z <- list(coefficients = if (mlm) matrix(NA_real_, 0,
>              ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
>              y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w !=
>              0) else ny)
>          if (!is.null(offset)) {
>              z$fitted.values <- offset
>              z$residuals <- y - offset
>          }
>      }
>      else {
>          x <- model.matrix(mt, mf, contrasts)
>          z <- if (is.null(w))
>              lm.fit(x, y, offset = offset, singular.ok = singular.ok,
>                  ...)
>          else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
>              ...)
>      }
>      class(z) <- c(if (mlm) "mlm", "lm")
>      z$na.action <- attr(mf, "na.action")
>      z$offset <- offset
>      z$contrasts <- attr(x, "contrasts")
>      z$xlevels <- .getXlevels(mt, mf)
>      z$call <- cl
>      z$terms <- mt
>      if (model)
>          z$model <- mf
>      if (ret.x)
>          z$x <- x
>      if (ret.y)
>          z$y <- y
>      if (!qr)
>          z$qr <- NULL
>      z
> }
> 
> 
> 
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
> 
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
> 
> 
> 
> 
> ________________________________________
> From: Jorgen Harmse <JHarmse at roku.com>
> Sent: Tuesday, January 7, 2025 1:47 PM
> To: r-help at r-project.org; ikwsimmo at gmail.com; Bert Gunter; Sorkin, John; jdnewmil at dcn.davis.ca.us
> Subject: Re: Extracting specific arguments from "..."
> 
> Interesting discussion. A few things occurred to me.
> 
> Apologies to Iris Simmons: I mixed up his answer with Bert's question.
> 
> Bert raises questions about promises, and I think they are related to John Sorkin's question. A big difference between R and most other languages is that function arguments are computed lazily. match.call & substitute tell us what expressions will be evaluated if function arguments are needed but not the environments in which that will happen. The usual suspects are environment() and parent.frame(), but parent.frame(k) & maybe even other environments are possible. If you are really determined then I guess you can keep evaluating match.call() in parent frames until you have accounted for all the inputs.
> 
> It's not clear to what extent John Sorkin is concerned about writing functions as opposed to using functions. Lazy computation has advantages but leads to some issues.
> Exactly matching the function's default expression for an input is not necessarily the same as omitting the input. The evaluation environment is different.
> If the caller uses an expression with side effects then there is no guarantee that the side effects will happen. If there are side effects from two or more inputs then the order is uncertain. (If an argument is not supplied and the default has side effects then they might not happen either. However, I don't know why the function writer would specify any side effect except stop(), and then he or she has probably arranged for it to happen exactly when it should.)
> If a default value depends on another input and that input is modified inside the function then order of evaluation of inputs becomes important. Even if you know exactly what you're doing when you write the function, you should make it clear to future maintainers. An explicit call to force clarifies that the input needs to be computed with the existing values of anything that is used in the default, even if the code is refactored so that the value is not used immediately. If you really want to modify another input before evaluating the default then specify that in a comment.
> 
> Jeff Newmiller makes a good point. You can still change your mind about inspecting a particular input without breaking old code that uses your function, and you don?t necessarily need default values.
> 
> Old definition: f <- function(?) {<code that passes ? to other functions and does some other things>}
> 
> New definition:
> f <- function(?, a = <default expression, possibly stop()>)
> { <pass ?, a=a to another function>
>    <do something with the output>
> }
> 
> OR
> 
> f <- function(?, a)
> { if (missing(a)) # OK, this becomes clunky if there are several such inputs
>    { < pass ? to another function >}
>    else
>   { <inspect or modify a> # Pitfall: Changing the order of evaluation may break old code, but then the design was probably too devious in the first place.
>      <pass ?, a=a to another function>
>    }
>    <do something with the output>
> }
> 
> Regards,
> Jorgen Harmse.
> 
> 
> 
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

-- 
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
 > E-mail is sent at my convenience; I don't expect replies outside of 
working hours.


From j@ork|n @end|ng |rom @om@um@ry|@nd@edu  Wed Jan  8 00:54:22 2025
From: j@ork|n @end|ng |rom @om@um@ry|@nd@edu (Sorkin, John)
Date: Tue, 7 Jan 2025 23:54:22 +0000
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <719c700b-f706-458c-8e4e-8cc223c8b5df@gmail.com>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
 <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
 <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
 <719c700b-f706-458c-8e4e-8cc223c8b5df@gmail.com>
Message-ID: <DM6PR03MB504908006EC49D9E6C4809C2E2112@DM6PR03MB5049.namprd03.prod.outlook.com>

Ben,
As always, thank you.
You are correct, it is something like what I want, but not exactly. Perhaps someday someone will write a more complete guide.
Thank you,
John


John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




________________________________________
From: R-help <r-help-bounces at r-project.org> on behalf of Ben Bolker <bbolker at gmail.com>
Sent: Tuesday, January 7, 2025 5:06 PM
To: r-help at r-project.org
Subject: Re: [R] Extracting specific arguments from "..."


   There's an ancient (2003) document on the CRAN "developers' page"
https://developer.r-project.org/model-fitting-functions.html that is
sort of (but not exactly) what you're looking for ...


On 2025-01-07 5:03 p.m., Sorkin, John wrote:
> Colleagues,
>
> My interest is not in writing ad hoc functions (which I might use once to analyze my data), but rather what I will call a system function that might be part of a package. The lm function is a paradigm of what I call a system function.
>
> The lm function begins by processing the arguments passed to the function (represented in the function as parameters, see code below.) Much of this processing is only peripherally related to running a regression, but the code is necessary to determine exactly what the user of the system function wants the function to do. It would be helpful if there was a document that would describe best practices when writing system functions, with clear explanations of what each step in system function is designed to do and how the line accomplishes its task. It would also be nice if the system function had documentation. I have pushed my way through the lm function, and with the help of R help files, I have come to understand how the function works, but this is not an efficient way to learn best practices that should be used when writing a system function.
>
> Perhaps there is a document that does what I would like to see done, but I do not know of one.
>
> John
>
> lmlm
> function (formula, data, subset, weights, na.action, method = "qr",
>      model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
>      contrasts = NULL, offset, ...)
> {
>      ret.x <- x
>      ret.y <- y
>      cl <- match.call()
>      mf <- match.call(expand.dots = FALSE)
>      m <- match(c("formula", "data", "subset", "weights", "na.action",
>          "offset"), names(mf), 0L)
>      mf <- mf[c(1L, m)]
>      mf$drop.unused.levels <- TRUE
>      mf[[1L]] <- quote(stats::model.frame)
>      mf <- eval(mf, parent.frame())
>      if (method == "model.frame")
>          return(mf)
>      else if (method != "qr")
>          warning(gettextf("method = '%s' is not supported. Using 'qr'",
>              method), domain = NA)
>      mt <- attr(mf, "terms")
>      y <- model.response(mf, "numeric")
>      w <- as.vector(model.weights(mf))
>      if (!is.null(w) && !is.numeric(w))
>          stop("'weights' must be a numeric vector")
>      offset <- model.offset(mf)
>      mlm <- is.matrix(y)
>      ny <- if (mlm)
>          nrow(y)
>      else length(y)
>      if (!is.null(offset)) {
>          if (!mlm)
>              offset <- as.vector(offset)
>          if (NROW(offset) != ny)
>              stop(gettextf("number of offsets is %d, should equal %d (number of observations)",
>                  NROW(offset), ny), domain = NA)
>      }
>      if (is.empty.model(mt)) {
>          x <- NULL
>          z <- list(coefficients = if (mlm) matrix(NA_real_, 0,
>              ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
>              y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w !=
>              0) else ny)
>          if (!is.null(offset)) {
>              z$fitted.values <- offset
>              z$residuals <- y - offset
>          }
>      }
>      else {
>          x <- model.matrix(mt, mf, contrasts)
>          z <- if (is.null(w))
>              lm.fit(x, y, offset = offset, singular.ok = singular.ok,
>                  ...)
>          else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
>              ...)
>      }
>      class(z) <- c(if (mlm) "mlm", "lm")
>      z$na.action <- attr(mf, "na.action")
>      z$offset <- offset
>      z$contrasts <- attr(x, "contrasts")
>      z$xlevels <- .getXlevels(mt, mf)
>      z$call <- cl
>      z$terms <- mt
>      if (model)
>          z$model <- mf
>      if (ret.x)
>          z$x <- x
>      if (ret.y)
>          z$y <- y
>      if (!qr)
>          z$qr <- NULL
>      z
> }
>
>
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
>
> ________________________________________
> From: Jorgen Harmse <JHarmse at roku.com>
> Sent: Tuesday, January 7, 2025 1:47 PM
> To: r-help at r-project.org; ikwsimmo at gmail.com; Bert Gunter; Sorkin, John; jdnewmil at dcn.davis.ca.us
> Subject: Re: Extracting specific arguments from "..."
>
> Interesting discussion. A few things occurred to me.
>
> Apologies to Iris Simmons: I mixed up his answer with Bert's question.
>
> Bert raises questions about promises, and I think they are related to John Sorkin's question. A big difference between R and most other languages is that function arguments are computed lazily. match.call & substitute tell us what expressions will be evaluated if function arguments are needed but not the environments in which that will happen. The usual suspects are environment() and parent.frame(), but parent.frame(k) & maybe even other environments are possible. If you are really determined then I guess you can keep evaluating match.call() in parent frames until you have accounted for all the inputs.
>
> It's not clear to what extent John Sorkin is concerned about writing functions as opposed to using functions. Lazy computation has advantages but leads to some issues.
> Exactly matching the function's default expression for an input is not necessarily the same as omitting the input. The evaluation environment is different.
> If the caller uses an expression with side effects then there is no guarantee that the side effects will happen. If there are side effects from two or more inputs then the order is uncertain. (If an argument is not supplied and the default has side effects then they might not happen either. However, I don't know why the function writer would specify any side effect except stop(), and then he or she has probably arranged for it to happen exactly when it should.)
> If a default value depends on another input and that input is modified inside the function then order of evaluation of inputs becomes important. Even if you know exactly what you're doing when you write the function, you should make it clear to future maintainers. An explicit call to force clarifies that the input needs to be computed with the existing values of anything that is used in the default, even if the code is refactored so that the value is not used immediately. If you really want to modify another input before evaluating the default then specify that in a comment.
>
> Jeff Newmiller makes a good point. You can still change your mind about inspecting a particular input without breaking old code that uses your function, and you don?t necessarily need default values.
>
> Old definition: f <- function(?) {<code that passes ? to other functions and does some other things>}
>
> New definition:
> f <- function(?, a = <default expression, possibly stop()>)
> { <pass ?, a=a to another function>
>    <do something with the output>
> }
>
> OR
>
> f <- function(?, a)
> { if (missing(a)) # OK, this becomes clunky if there are several such inputs
>    { < pass ? to another function >}
>    else
>   { <inspect or modify a> # Pitfall: Changing the order of evaluation may break old code, but then the design was probably too devious in the first place.
>      <pass ?, a=a to another function>
>    }
>    <do something with the output>
> }
>
> Regards,
> Jorgen Harmse.
>
>
>
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

--
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
 > E-mail is sent at my convenience; I don't expect replies outside of
working hours.

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From @vi@e@gross m@iii@g oii gm@ii@com  Wed Jan  8 03:51:09 2025
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Tue, 7 Jan 2025 21:51:09 -0500
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <DM6PR03MB504908006EC49D9E6C4809C2E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
 <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
 <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
 <719c700b-f706-458c-8e4e-8cc223c8b5df@gmail.com>
 <DM6PR03MB504908006EC49D9E6C4809C2E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <00ae01db6178$2bcb11a0$836134e0$@gmail.com>

Like many things in R, the original way things were done may have ossified
in place and even if largely unknown packages came along, may not be known
by many.

The topic John is talking about is NOT in my mind about systems programming
at all. It is about writing any function where you want control over
evaluating arguments. There may be a better way from a programmers
perspective.

I can imagine a set of functions in a package that are well designed and
hide all the details so they can be easily used. I suspect aspects of what I
am talking about have been done. They could include some "logical" functions
that test if an option has been specified, or even if it is just the
default, without evaluating anything. Other functions would return a
specified argument. Yet others would remove a specified argument so further
evaluation does not see it, including removing it from ... so that in the
end, you can pass along a reduced ... to other functions you call.

I understand some R evaluations can be tricky or even have side effects. But
something better than what I have seen seems quite possible.

Other languages have variants such as getopt() that are a tad different but
quite useful.

-----Original Message-----
From: R-help <r-help-bounces at r-project.org> On Behalf Of Sorkin, John
Sent: Tuesday, January 7, 2025 6:54 PM
To: Ben Bolker <bbolker at gmail.com>; r-help at r-project.org
Subject: Re: [R] Extracting specific arguments from "..."

Ben,
As always, thank you.
You are correct, it is something like what I want, but not exactly. Perhaps
someday someone will write a more complete guide.
Thank you,
John


John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical
Center Geriatrics Research, Education, and Clinical Center;
PI Biostatistics and Informatics Core, University of Maryland School of
Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




________________________________________
From: R-help <r-help-bounces at r-project.org> on behalf of Ben Bolker
<bbolker at gmail.com>
Sent: Tuesday, January 7, 2025 5:06 PM
To: r-help at r-project.org
Subject: Re: [R] Extracting specific arguments from "..."


   There's an ancient (2003) document on the CRAN "developers' page"
https://developer.r-project.org/model-fitting-functions.html that is
sort of (but not exactly) what you're looking for ...


On 2025-01-07 5:03 p.m., Sorkin, John wrote:
> Colleagues,
>
> My interest is not in writing ad hoc functions (which I might use once to
analyze my data), but rather what I will call a system function that might
be part of a package. The lm function is a paradigm of what I call a system
function.
>
> The lm function begins by processing the arguments passed to the function
(represented in the function as parameters, see code below.) Much of this
processing is only peripherally related to running a regression, but the
code is necessary to determine exactly what the user of the system function
wants the function to do. It would be helpful if there was a document that
would describe best practices when writing system functions, with clear
explanations of what each step in system function is designed to do and how
the line accomplishes its task. It would also be nice if the system function
had documentation. I have pushed my way through the lm function, and with
the help of R help files, I have come to understand how the function works,
but this is not an efficient way to learn best practices that should be used
when writing a system function.
>
> Perhaps there is a document that does what I would like to see done, but I
do not know of one.
>
> John
>
> lmlm
> function (formula, data, subset, weights, na.action, method = "qr",
>      model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
>      contrasts = NULL, offset, ...)
> {
>      ret.x <- x
>      ret.y <- y
>      cl <- match.call()
>      mf <- match.call(expand.dots = FALSE)
>      m <- match(c("formula", "data", "subset", "weights", "na.action",
>          "offset"), names(mf), 0L)
>      mf <- mf[c(1L, m)]
>      mf$drop.unused.levels <- TRUE
>      mf[[1L]] <- quote(stats::model.frame)
>      mf <- eval(mf, parent.frame())
>      if (method == "model.frame")
>          return(mf)
>      else if (method != "qr")
>          warning(gettextf("method = '%s' is not supported. Using 'qr'",
>              method), domain = NA)
>      mt <- attr(mf, "terms")
>      y <- model.response(mf, "numeric")
>      w <- as.vector(model.weights(mf))
>      if (!is.null(w) && !is.numeric(w))
>          stop("'weights' must be a numeric vector")
>      offset <- model.offset(mf)
>      mlm <- is.matrix(y)
>      ny <- if (mlm)
>          nrow(y)
>      else length(y)
>      if (!is.null(offset)) {
>          if (!mlm)
>              offset <- as.vector(offset)
>          if (NROW(offset) != ny)
>              stop(gettextf("number of offsets is %d, should equal %d
(number of observations)",
>                  NROW(offset), ny), domain = NA)
>      }
>      if (is.empty.model(mt)) {
>          x <- NULL
>          z <- list(coefficients = if (mlm) matrix(NA_real_, 0,
>              ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
>              y, weights = w, rank = 0L, df.residual = if (!is.null(w))
sum(w !=
>              0) else ny)
>          if (!is.null(offset)) {
>              z$fitted.values <- offset
>              z$residuals <- y - offset
>          }
>      }
>      else {
>          x <- model.matrix(mt, mf, contrasts)
>          z <- if (is.null(w))
>              lm.fit(x, y, offset = offset, singular.ok = singular.ok,
>                  ...)
>          else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
>              ...)
>      }
>      class(z) <- c(if (mlm) "mlm", "lm")
>      z$na.action <- attr(mf, "na.action")
>      z$offset <- offset
>      z$contrasts <- attr(x, "contrasts")
>      z$xlevels <- .getXlevels(mt, mf)
>      z$call <- cl
>      z$terms <- mt
>      if (model)
>          z$model <- mf
>      if (ret.x)
>          z$x <- x
>      if (ret.y)
>          z$y <- y
>      if (!qr)
>          z$qr <- NULL
>      z
> }
>
>
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical
Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of
Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
>
> ________________________________________
> From: Jorgen Harmse <JHarmse at roku.com>
> Sent: Tuesday, January 7, 2025 1:47 PM
> To: r-help at r-project.org; ikwsimmo at gmail.com; Bert Gunter; Sorkin, John;
jdnewmil at dcn.davis.ca.us
> Subject: Re: Extracting specific arguments from "..."
>
> Interesting discussion. A few things occurred to me.
>
> Apologies to Iris Simmons: I mixed up his answer with Bert's question.
>
> Bert raises questions about promises, and I think they are related to John
Sorkin's question. A big difference between R and most other languages is
that function arguments are computed lazily. match.call & substitute tell us
what expressions will be evaluated if function arguments are needed but not
the environments in which that will happen. The usual suspects are
environment() and parent.frame(), but parent.frame(k) & maybe even other
environments are possible. If you are really determined then I guess you can
keep evaluating match.call() in parent frames until you have accounted for
all the inputs.
>
> It's not clear to what extent John Sorkin is concerned about writing
functions as opposed to using functions. Lazy computation has advantages but
leads to some issues.
> Exactly matching the function's default expression for an input is not
necessarily the same as omitting the input. The evaluation environment is
different.
> If the caller uses an expression with side effects then there is no
guarantee that the side effects will happen. If there are side effects from
two or more inputs then the order is uncertain. (If an argument is not
supplied and the default has side effects then they might not happen either.
However, I don't know why the function writer would specify any side effect
except stop(), and then he or she has probably arranged for it to happen
exactly when it should.)
> If a default value depends on another input and that input is modified
inside the function then order of evaluation of inputs becomes important.
Even if you know exactly what you're doing when you write the function, you
should make it clear to future maintainers. An explicit call to force
clarifies that the input needs to be computed with the existing values of
anything that is used in the default, even if the code is refactored so that
the value is not used immediately. If you really want to modify another
input before evaluating the default then specify that in a comment.
>
> Jeff Newmiller makes a good point. You can still change your mind about
inspecting a particular input without breaking old code that uses your
function, and you don't necessarily need default values.
>
> Old definition: f <- function(.) {<code that passes . to other functions
and does some other things>}
>
> New definition:
> f <- function(., a = <default expression, possibly stop()>)
> { <pass ., a=a to another function>
>    <do something with the output>
> }
>
> OR
>
> f <- function(., a)
> { if (missing(a)) # OK, this becomes clunky if there are several such
inputs
>    { < pass . to another function >}
>    else
>   { <inspect or modify a> # Pitfall: Changing the order of evaluation may
break old code, but then the design was probably too devious in the first
place.
>      <pass ., a=a to another function>
>    }
>    <do something with the output>
> }
>
> Regards,
> Jorgen Harmse.
>
>
>
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
https://www.r-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

--
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
 > E-mail is sent at my convenience; I don't expect replies outside of
working hours.

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide
https://www.r-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide
https://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Wed Jan  8 11:21:40 2025
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Wed, 8 Jan 2025 11:21:40 +0100
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
 <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
 <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <26494.20916.648344.868223@stat.math.ethz.ch>

>>>>> Sorkin, John 
>>>>>     on Tue, 7 Jan 2025 22:03:02 +0000 writes:

    > Colleagues,
    > My interest is not in writing ad hoc functions (which I might use once to analyze my data), but rather what I will call a system function that might be part of a package. The lm function is a paradigm of what I call a system function. 

    > The lm function begins by processing the arguments passed to the function (represented in the function as parameters, see code below.) Much of this processing is only peripherally related to running a regression, but the code is necessary to determine exactly what the user of the system function wants the function to do. It would be helpful if there was a document that would describe best practices when writing system functions, with clear explanations of what each step in system function is designed to do and how the line accomplishes its task. It would also be nice if the system function had documentation. I have pushed my way through the lm function, and with the help of R help files, I have come to understand how the function works, but this is not an efficient way to learn best practices that should be used when writing a system function. 

    > Perhaps there is a document that does what I would like to see done, but I do not know of one.  

    > John

Note that the following is *not* the source of the lm() function, but a
print out to your console of what has become from the original source.
Notably all comments *and* all original author formatting has
been lost (as the "system functions" are *not* installed with
     	   something like options(keep.source = TRUE)).

For a long time, many have strongly advised to use the source
(e.g. https://en.wiktionary.org/wiki/UTSL   "Use The Source, Luke!")
instead. Here's the always latest (development / R-devel) source
for lm() *and* related functions ... also with comments etc:
  --> https://svn.r-project.org/R/trunk/src/library/stats/R/lm.R

(or you use one of its github mirrors ..)

Martin


    > lm

    > function (formula, data, subset, weights, na.action, method = "qr",
    > model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
    > contrasts = NULL, offset, ...)
    > {
    > ret.x <- x
    > ret.y <- y
    > cl <- match.call()
    > mf <- match.call(expand.dots = FALSE)
    > m <- match(c("formula", "data", "subset", "weights", "na.action",
    > "offset"), names(mf), 0L)
    > mf <- mf[c(1L, m)]
    > mf$drop.unused.levels <- TRUE
    > mf[[1L]] <- quote(stats::model.frame)
    > mf <- eval(mf, parent.frame())
    > if (method == "model.frame")
    > return(mf)
    > else if (method != "qr")
    > warning(gettextf("method = '%s' is not supported. Using 'qr'",
    > method), domain = NA)
    > mt <- attr(mf, "terms")
    > y <- model.response(mf, "numeric")
    > w <- as.vector(model.weights(mf))
    > if (!is.null(w) && !is.numeric(w))
    > stop("'weights' must be a numeric vector")
    > offset <- model.offset(mf)
    > mlm <- is.matrix(y)
    > ny <- if (mlm)
    > nrow(y)
    > else length(y)
    > if (!is.null(offset)) {
    > if (!mlm)
    > offset <- as.vector(offset)
    > if (NROW(offset) != ny)
    > stop(gettextf("number of offsets is %d, should equal %d (number of observations)",
    > NROW(offset), ny), domain = NA)
    > }
    > if (is.empty.model(mt)) {
    > x <- NULL
    > z <- list(coefficients = if (mlm) matrix(NA_real_, 0,
    > ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
    > y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w !=
    > 0) else ny)
    > if (!is.null(offset)) {
    > z$fitted.values <- offset
    > z$residuals <- y - offset
    > }
    > }
    > else {
    > x <- model.matrix(mt, mf, contrasts)
    > z <- if (is.null(w))
    > lm.fit(x, y, offset = offset, singular.ok = singular.ok,
    > ...)
    > else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
    > ...)
    > }
    > class(z) <- c(if (mlm) "mlm", "lm")
    > z$na.action <- attr(mf, "na.action")
    > z$offset <- offset
    > z$contrasts <- attr(x, "contrasts")
    > z$xlevels <- .getXlevels(mt, mf)
    > z$call <- cl
    > z$terms <- mt
    > if (model)
    > z$model <- mf
    > if (ret.x)
    > z$x <- x
    > if (ret.y)
    > z$y <- y
    > if (!qr)
    > z$qr <- NULL
    > z
    > }



    > John David Sorkin M.D., Ph.D.
    > Professor of Medicine, University of Maryland School of Medicine;
    > Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;?
    > PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
    > Senior Statistician University of Maryland Center for Vascular Research;

    > Division of Gerontology and Paliative Care,
    > 10 North Greene Street
    > GRECC (BT/18/GR)
    > Baltimore, MD 21201-1524
    > Cell phone 443-418-5382




    > ________________________________________
    > From: Jorgen Harmse <JHarmse at roku.com>
    > Sent: Tuesday, January 7, 2025 1:47 PM
    > To: r-help at r-project.org; ikwsimmo at gmail.com; Bert Gunter; Sorkin, John; jdnewmil at dcn.davis.ca.us
    > Subject: Re: Extracting specific arguments from "..."

    > Interesting discussion. A few things occurred to me.

    > Apologies to Iris Simmons: I mixed up his answer with Bert's question.

    > Bert raises questions about promises, and I think they are related to John Sorkin's question. A big difference between R and most other languages is that function arguments are computed lazily. match.call & substitute tell us what expressions will be evaluated if function arguments are needed but not the environments in which that will happen. The usual suspects are environment() and parent.frame(), but parent.frame(k) & maybe even other environments are possible. If you are really determined then I guess you can keep evaluating match.call() in parent frames until you have accounted for all the inputs.

    > It's not clear to what extent John Sorkin is concerned about writing functions as opposed to using functions. Lazy computation has advantages but leads to some issues.
    > Exactly matching the function's default expression for an input is not necessarily the same as omitting the input. The evaluation environment is different.
    > If the caller uses an expression with side effects then there is no guarantee that the side effects will happen. If there are side effects from two or more inputs then the order is uncertain. (If an argument is not supplied and the default has side effects then they might not happen either. However, I don't know why the function writer would specify any side effect except stop(), and then he or she has probably arranged for it to happen exactly when it should.)
    > If a default value depends on another input and that input is modified inside the function then order of evaluation of inputs becomes important. Even if you know exactly what you're doing when you write the function, you should make it clear to future maintainers. An explicit call to force clarifies that the input needs to be computed with the existing values of anything that is used in the default, even if the code is refactored so that the value is not used immediately. If you really want to modify another input before evaluating the default then specify that in a comment.

    > Jeff Newmiller makes a good point. You can still change your mind about inspecting a particular input without breaking old code that uses your function, and you don?t necessarily need default values.

    > Old definition: f <- function(?) {<code that passes ? to other functions and does some other things>}

    > New definition:
    > f <- function(?, a = <default expression, possibly stop()>)
    > { <pass ?, a=a to another function>
    > <do something with the output>
    > }

    > OR

    > f <- function(?, a)
    > { if (missing(a)) # OK, this becomes clunky if there are several such inputs
    > { < pass ? to another function >}
    > else
    > { <inspect or modify a> # Pitfall: Changing the order of evaluation may break old code, but then the design was probably too devious in the first place.
    > <pass ?, a=a to another function>
    > }
    > <do something with the output>
    > }

    > Regards,
    > Jorgen Harmse.




    > ______________________________________________
    > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
    > https://stat.ethz.ch/mailman/listinfo/r-help
    > PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
    > and provide commented, minimal, self-contained, reproducible code.


From h@w|ckh@m @end|ng |rom gm@||@com  Wed Jan  8 21:50:53 2025
From: h@w|ckh@m @end|ng |rom gm@||@com (Hadley Wickham)
Date: Wed, 8 Jan 2025 14:50:53 -0600
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
Message-ID: <CABdHhvHVOBfmTFbDOeApBh0=vt9QYH86=a4xNvjK+BbQL1i5YQ@mail.gmail.com>

I'd propose an alternative that I think is superior: rely on the semantics
of ... to do the work for you:

f1 <- function(...){
  one <- list(...)[['a']]
  two <- ...elt(match('a', ...names()))
  c(one, two, three(...))
}

three <- function(a, ...) {
  a
}

f1(a = 1, b = 2, c = 3)
#> [1] 1 1 1


On Sun, Jan 5, 2025 at 12:00?PM Bert Gunter <bgunter.4567 at gmail.com> wrote:

> Consider:
>
> f1 <- function(...){
>   one <- list(...)[['a']]
>   two <- ...elt(match('a', ...names()))
>   c(one, two)
> }
> ## Here "..." is an argument list with "a" somewhere in it, but in an
> unknown position.
>
> > f1(b=5, a = 2, c=7)
> [1] 2 2
>
> Which is better for extracting a specific named argument, one<- or
> two<- ?  Or a third alternative that is better than both?
> Comments and critiques welcome.
>
> Cheers,
> Bert
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


-- 
http://hadley.nz

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Wed Jan  8 23:57:36 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Wed, 8 Jan 2025 14:57:36 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CABdHhvHVOBfmTFbDOeApBh0=vt9QYH86=a4xNvjK+BbQL1i5YQ@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
 <CABdHhvHVOBfmTFbDOeApBh0=vt9QYH86=a4xNvjK+BbQL1i5YQ@mail.gmail.com>
Message-ID: <CAGxFJbTdpmyGKEB5L2Rj3AuW3uZ1wv=XQAhCZkvsDojx=2csRA@mail.gmail.com>

That's very nice, Hadley. Simple and clean. Never would have thought of it
myself.

As usual, however, in the course of my churnings, I have a further
complication to add. But first ...

**TO ALL**: Feel free to ignore the following, as I'm just fooling around
here and don't want to waste your time with my stupid stuff.

Anyway, the complication is motivated by the use of formals() or otherwise
that *programmatically* generates a character representation of the
arguments I want to select. So, for example:

> z <- "a"
## Then:
f1 <- function(...){
    ...elt(match(z, ...names())) ## since z gets evaluated in the call
}
## still works.
> f1(b =2, a=1, c=3)
[1] 1

But I haven't figured out how to modify your suggestion -- at least in a
simple way -- to do the same. Likely I've missed something, though.


Cheers,
Bert






On Wed, Jan 8, 2025 at 12:51?PM Hadley Wickham <h.wickham at gmail.com> wrote:

> I'd propose an alternative that I think is superior: rely on the semantics
> of ... to do the work for you:
>
> f1 <- function(...){
>   one <- list(...)[['a']]
>   two <- ...elt(match('a', ...names()))
>   c(one, two, three(...))
> }
>
> three <- function(a, ...) {
>   a
> }
>
> f1(a = 1, b = 2, c = 3)
> #> [1] 1 1 1
>
>
> On Sun, Jan 5, 2025 at 12:00?PM Bert Gunter <bgunter.4567 at gmail.com>
> wrote:
>
>> Consider:
>>
>> f1 <- function(...){
>>   one <- list(...)[['a']]
>>   two <- ...elt(match('a', ...names()))
>>   c(one, two)
>> }
>> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> unknown position.
>>
>> > f1(b=5, a = 2, c=7)
>> [1] 2 2
>>
>> Which is better for extracting a specific named argument, one<- or
>> two<- ?  Or a third alternative that is better than both?
>> Comments and critiques welcome.
>>
>> Cheers,
>> Bert
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide
>> https://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>>
>
>
> --
> http://hadley.nz
>

	[[alternative HTML version deleted]]


From |@n@|@rm @end|ng |rom m@|ne@edu  Thu Jan  9 14:12:00 2025
From: |@n@|@rm @end|ng |rom m@|ne@edu (Ian Farm)
Date: Thu, 9 Jan 2025 08:12:00 -0500
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAGxFJbTdpmyGKEB5L2Rj3AuW3uZ1wv=XQAhCZkvsDojx=2csRA@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
 <CABdHhvHVOBfmTFbDOeApBh0=vt9QYH86=a4xNvjK+BbQL1i5YQ@mail.gmail.com>
 <CAGxFJbTdpmyGKEB5L2Rj3AuW3uZ1wv=XQAhCZkvsDojx=2csRA@mail.gmail.com>
Message-ID: <CAP8nD2xJhtwtYHR2yySFZoi=Uyo_mt=GOpjAr1yTrW=JLLvhLw@mail.gmail.com>

I might add that there seems to be a subtle difference between using
`...elt()` and `match.call()`, which is that the former causes `a` itself
to be evaluated while the latter doesn't:
```
# Some approaches that have been suggested:

# 1. Using `list()` (Bert Gunter)
f1 <- function(...) list(...)[["a"]]
# 2. Using `...elt()` (Bert Gunter)
f2 <- function(...) ...elt(match("a", ...names()))
# 3. Using argument matching (Hadley Wickham)
f3 <- function(...) (\(a, ...) a)(...)
# 4. Using `match.call()`
f4 <- function(...) eval(match.call()[["a"]], parent.frame())

ff <- list(f1 = f1, f2 = f2, f3 = f3, f4 = f4)

sapply(ff, \(f) {
  f(b = 2, a = 1, c = 3)
})
#> f1 f2 f3 f4
#>  1  1  1  1

# View the (defused) arguments after `a` has been accessed:

# returns an expression if the argument has not been evaluated, and a
number if it has
check_forced_args <- function(f) {
  body(f) <- call("{", body(f), quote(rlang::enexprs(...)))
  # pass `f()` some expressions to see which are evaluated
  f(a = cos(0), b = sqrt(4))
}
# make a data frame showing the defused arguments for each function
lapply(ff, check_forced_args) |> do.call(rbind, args = _) |> as.data.frame()

#>         a       b
#> f1      1       2    # all the arguments are forced
#> f2      1 sqrt(4)    # only `a` is forced
#> f3      1 sqrt(4)    # only `a` is forced
#> f4 cos(0) sqrt(4)    # none of the arguments are forced
```

Also, here's a possible way to adapt Hadley Wickham's approach so that it
takes the name of the argument as a string, though it does lose the
elegance:
```
pick_arg <- function(nm) {
  as.function(c(
    setNames(alist(. = , . = ), c(nm, "...")),
    as.symbol(nm)
  ))
}

z <- "a"
f5 <- function(...) {
  pick_arg(z)(...)
}
f5(b = 2, a = 1, c = 3)
#> [1] 1
```

Regards,
Ian
____
Ian Farm, Laboratory Manager
University of Maine Agroecology Lab


On Wed, Jan 8, 2025 at 5:58?PM Bert Gunter <bgunter.4567 at gmail.com> wrote:

> That's very nice, Hadley. Simple and clean. Never would have thought of it
> myself.
>
> As usual, however, in the course of my churnings, I have a further
> complication to add. But first ...
>
> **TO ALL**: Feel free to ignore the following, as I'm just fooling around
> here and don't want to waste your time with my stupid stuff.
>
> Anyway, the complication is motivated by the use of formals() or otherwise
> that *programmatically* generates a character representation of the
> arguments I want to select. So, for example:
>
> > z <- "a"
> ## Then:
> f1 <- function(...){
>     ...elt(match(z, ...names())) ## since z gets evaluated in the call
> }
> ## still works.
> > f1(b =2, a=1, c=3)
> [1] 1
>
> But I haven't figured out how to modify your suggestion -- at least in a
> simple way -- to do the same. Likely I've missed something, though.
>
>
> Cheers,
> Bert
>
>
>
>
>
>
> On Wed, Jan 8, 2025 at 12:51?PM Hadley Wickham <h.wickham at gmail.com>
> wrote:
>
> > I'd propose an alternative that I think is superior: rely on the
> semantics
> > of ... to do the work for you:
> >
> > f1 <- function(...){
> >   one <- list(...)[['a']]
> >   two <- ...elt(match('a', ...names()))
> >   c(one, two, three(...))
> > }
> >
> > three <- function(a, ...) {
> >   a
> > }
> >
> > f1(a = 1, b = 2, c = 3)
> > #> [1] 1 1 1
> >
> >
> > On Sun, Jan 5, 2025 at 12:00?PM Bert Gunter <bgunter.4567 at gmail.com>
> > wrote:
> >
> >> Consider:
> >>
> >> f1 <- function(...){
> >>   one <- list(...)[['a']]
> >>   two <- ...elt(match('a', ...names()))
> >>   c(one, two)
> >> }
> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
> >> unknown position.
> >>
> >> > f1(b=5, a = 2, c=7)
> >> [1] 2 2
> >>
> >> Which is better for extracting a specific named argument, one<- or
> >> two<- ?  Or a third alternative that is better than both?
> >> Comments and critiques welcome.
> >>
> >> Cheers,
> >> Bert
> >>
> >> ______________________________________________
> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> PLEASE do read the posting guide
> >> https://www.R-project.org/posting-guide.html
> >> and provide commented, minimal, self-contained, reproducible code.
> >>
> >
> >
> > --
> > http://hadley.nz
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Thu Jan  9 21:59:07 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Thu, 9 Jan 2025 12:59:07 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAP8nD2xJhtwtYHR2yySFZoi=Uyo_mt=GOpjAr1yTrW=JLLvhLw@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
 <CABdHhvHVOBfmTFbDOeApBh0=vt9QYH86=a4xNvjK+BbQL1i5YQ@mail.gmail.com>
 <CAGxFJbTdpmyGKEB5L2Rj3AuW3uZ1wv=XQAhCZkvsDojx=2csRA@mail.gmail.com>
 <CAP8nD2xJhtwtYHR2yySFZoi=Uyo_mt=GOpjAr1yTrW=JLLvhLw@mail.gmail.com>
Message-ID: <CAGxFJbTZe7qz0R58tROZqBAHeqUkbrqhDSFvu6LuowVBEkzqSA@mail.gmail.com>

Thanks Ian (and others),

Taking the advice of ?"..." (which I should have done at the outset ...
duhh!),  the following seems to be the simplest solution, adequate for my
needs at least:

f <- function(x, ...){
   lapply(seq_along(x), \(i)switch(x[i], ..., NA))
}

(the usual argument checking etc. should be added, of course.)

Comparing this to the ...xx() functions that I previously gave, which are
the same as names(list(...)) etc. without the overhead of unnecessary
evaluation, gives:

g <- function(...){
   one <- f(z,...)
   two <- lapply(charmatch(z, ...names()), \(i)...elt(i))
  list(one = one, two = two)
}

> k <- 5
> z <- c("a","c")
> g(b=2, a=1, c = k)
$one
$one[[1]]
[1] 1

$one[[2]]
[1] 5


$two
$two[[1]]
[1] 1

$two[[2]]
[1] 5

As always, corrections and comments welcomed.

Cheers,
Bert



On Thu, Jan 9, 2025 at 5:12?AM Ian Farm <ian.farm at maine.edu> wrote:

> I might add that there seems to be a subtle difference between using
> `...elt()` and `match.call()`, which is that the former causes `a` itself
> to be evaluated while the latter doesn't:
> ```
> # Some approaches that have been suggested:
>
> # 1. Using `list()` (Bert Gunter)
> f1 <- function(...) list(...)[["a"]]
> # 2. Using `...elt()` (Bert Gunter)
> f2 <- function(...) ...elt(match("a", ...names()))
> # 3. Using argument matching (Hadley Wickham)
> f3 <- function(...) (\(a, ...) a)(...)
> # 4. Using `match.call()`
> f4 <- function(...) eval(match.call()[["a"]], parent.frame())
>
> ff <- list(f1 = f1, f2 = f2, f3 = f3, f4 = f4)
>
> sapply(ff, \(f) {
>   f(b = 2, a = 1, c = 3)
> })
> #> f1 f2 f3 f4
> #>  1  1  1  1
>
> # View the (defused) arguments after `a` has been accessed:
>
> # returns an expression if the argument has not been evaluated, and a
> number if it has
> check_forced_args <- function(f) {
>   body(f) <- call("{", body(f), quote(rlang::enexprs(...)))
>   # pass `f()` some expressions to see which are evaluated
>   f(a = cos(0), b = sqrt(4))
> }
> # make a data frame showing the defused arguments for each function
> lapply(ff, check_forced_args) |> do.call(rbind, args = _) |>
> as.data.frame()
>
> #>         a       b
> #> f1      1       2    # all the arguments are forced
> #> f2      1 sqrt(4)    # only `a` is forced
> #> f3      1 sqrt(4)    # only `a` is forced
> #> f4 cos(0) sqrt(4)    # none of the arguments are forced
> ```
>
> Also, here's a possible way to adapt Hadley Wickham's approach so that it
> takes the name of the argument as a string, though it does lose the
> elegance:
> ```
> pick_arg <- function(nm) {
>   as.function(c(
>     setNames(alist(. = , . = ), c(nm, "...")),
>     as.symbol(nm)
>   ))
> }
>
> z <- "a"
> f5 <- function(...) {
>   pick_arg(z)(...)
> }
> f5(b = 2, a = 1, c = 3)
> #> [1] 1
> ```
>
> Regards,
> Ian
> ____
> Ian Farm, Laboratory Manager
> University of Maine Agroecology Lab
>
>
> On Wed, Jan 8, 2025 at 5:58?PM Bert Gunter <bgunter.4567 at gmail.com> wrote:
>
>> That's very nice, Hadley. Simple and clean. Never would have thought of it
>> myself.
>>
>> As usual, however, in the course of my churnings, I have a further
>> complication to add. But first ...
>>
>> **TO ALL**: Feel free to ignore the following, as I'm just fooling around
>> here and don't want to waste your time with my stupid stuff.
>>
>> Anyway, the complication is motivated by the use of formals() or otherwise
>> that *programmatically* generates a character representation of the
>> arguments I want to select. So, for example:
>>
>> > z <- "a"
>> ## Then:
>> f1 <- function(...){
>>     ...elt(match(z, ...names())) ## since z gets evaluated in the call
>> }
>> ## still works.
>> > f1(b =2, a=1, c=3)
>> [1] 1
>>
>> But I haven't figured out how to modify your suggestion -- at least in a
>> simple way -- to do the same. Likely I've missed something, though.
>>
>>
>> Cheers,
>> Bert
>>
>>
>>
>>
>>
>>
>> On Wed, Jan 8, 2025 at 12:51?PM Hadley Wickham <h.wickham at gmail.com>
>> wrote:
>>
>> > I'd propose an alternative that I think is superior: rely on the
>> semantics
>> > of ... to do the work for you:
>> >
>> > f1 <- function(...){
>> >   one <- list(...)[['a']]
>> >   two <- ...elt(match('a', ...names()))
>> >   c(one, two, three(...))
>> > }
>> >
>> > three <- function(a, ...) {
>> >   a
>> > }
>> >
>> > f1(a = 1, b = 2, c = 3)
>> > #> [1] 1 1 1
>> >
>> >
>> > On Sun, Jan 5, 2025 at 12:00?PM Bert Gunter <bgunter.4567 at gmail.com>
>> > wrote:
>> >
>> >> Consider:
>> >>
>> >> f1 <- function(...){
>> >>   one <- list(...)[['a']]
>> >>   two <- ...elt(match('a', ...names()))
>> >>   c(one, two)
>> >> }
>> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> >> unknown position.
>> >>
>> >> > f1(b=5, a = 2, c=7)
>> >> [1] 2 2
>> >>
>> >> Which is better for extracting a specific named argument, one<- or
>> >> two<- ?  Or a third alternative that is better than both?
>> >> Comments and critiques welcome.
>> >>
>> >> Cheers,
>> >> Bert
>> >>
>> >> ______________________________________________
>> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> >> https://stat.ethz.ch/mailman/listinfo/r-help
>> >> PLEASE do read the posting guide
>> >> https://www.R-project.org/posting-guide.html
>> >> and provide commented, minimal, self-contained, reproducible code.
>> >>
>> >
>> >
>> > --
>> > http://hadley.nz
>> >
>>
>>         [[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide
>> https://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>>
>

	[[alternative HTML version deleted]]


From S@d@mhu@en@Hu@en| @end|ng |rom genp@ct@com  Mon Jan 13 15:34:20 2025
From: S@d@mhu@en@Hu@en| @end|ng |rom genp@ct@com (Huseni, Sadamhusen)
Date: Mon, 13 Jan 2025 14:34:20 +0000
Subject: [R] Regarding Issue Running Parallel Computing on Linux RHEL
 version 8
Message-ID: <PN2PR01MB413718F6DEB2F2A8B72E8B10E21F2@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>

Hi Team,

I am writing to bring to your attention an issue we have encountered following the recent update of our Linux server from RHEL 7 to RHEL 8. We have an R script designed to create demand forecasts utilizing parallel computing on the Linux server.

Before the version update, the script executed successfully within approximately two hours. However, since updating to RHEL 8, the script has been hanging and not completing its execution even after running for 17 hours.

Here are some details about the problem:

Script Purpose: Demand forecasting using parallel computing.
Previous Environment: Linux server version RHEL 7.
Current Environment: Linux server version RHEL 8.
Issue Observed: The script hangs and does not complete execution post-update. Previously, it took around two hours; now it runs for over 17 hours without finishing.
We need assistance in diagnosing and resolving this issue as soon as possible. I will share detailed logs and any other necessary information upon request.

List of libraries used as below.
  library(foreach)
  library(parallel)
  library(parallelly)
  library(forecast)
  library(tseries)
  library(prophet)
  library(lubridate)
  library(tis)
  library(tsoutliers)


Thanks,
Sadam


	[[alternative HTML version deleted]]


From |kry|ov @end|ng |rom d|@root@org  Tue Jan 14 09:22:52 2025
From: |kry|ov @end|ng |rom d|@root@org (Ivan Krylov)
Date: Tue, 14 Jan 2025 11:22:52 +0300
Subject: [R] Regarding Issue Running Parallel Computing on Linux RHEL
 version 8
In-Reply-To: <PN2PR01MB413718F6DEB2F2A8B72E8B10E21F2@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>
References: <PN2PR01MB413718F6DEB2F2A8B72E8B10E21F2@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>
Message-ID: <20250114112252.14b90d22@Tarkus>

Dear Sadam,

? Mon, 13 Jan 2025 14:34:20 +0000
"Huseni, Sadamhusen" <Sadamhusen.Huseni at genpact.com> ?????:

> Issue Observed: The script hangs and does not complete execution
> post-update. Previously, it took around two hours; now it runs for
> over 17 hours without finishing.

Do you still have the RHEL 7 machine? Could you please share the
sessionInfo() output at least from the RHEL 8 machine but, if possible,
also from the RHEL 7 machine?

>   library(foreach)
>   library(parallel)
>   library(parallelly)
>   library(forecast)
>   library(tseries)
>   library(prophet)
>   library(lubridate)
>   library(tis)
>   library(tsoutliers)

Could you identify and share the parts of the script that launch the
computation in parallel?

-- 
Best regards,
Ivan


From @k@h@y_e4 @end|ng |rom hotm@||@com  Tue Jan 14 10:07:41 2025
From: @k@h@y_e4 @end|ng |rom hotm@||@com (akshay kulkarni)
Date: Tue, 14 Jan 2025 09:07:41 +0000
Subject: [R] Regarding Issue Running Parallel Computing on Linux RHEL
 version 8
In-Reply-To: <20250114112252.14b90d22@Tarkus>
References: <PN2PR01MB413718F6DEB2F2A8B72E8B10E21F2@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>
 <20250114112252.14b90d22@Tarkus>
Message-ID: <PU4P216MB156853B95746B9642B759577C8182@PU4P216MB1568.KORP216.PROD.OUTLOOK.COM>

dear Ivan,
                  THe present problem had been encountered by me also about 1 and a half years ago. You had solved the issue then. Can't we search this mail list according to some keywords? It helps people with problems already solved in the mailing list.

THanking you,
Yours sincerely,
AKSHAY M KULKARNI

________________________________
From: R-help <r-help-bounces at r-project.org> on behalf of Ivan Krylov via R-help <r-help at r-project.org>
Sent: Tuesday, January 14, 2025 1:52 PM
To: Huseni, Sadamhusen <Sadamhusen.Huseni at genpact.com>
Cc: r-help at R-project.org <r-help at R-project.org>
Subject: Re: [R] Regarding Issue Running Parallel Computing on Linux RHEL version 8

Dear Sadam,

? Mon, 13 Jan 2025 14:34:20 +0000
"Huseni, Sadamhusen" <Sadamhusen.Huseni at genpact.com> ?????:

> Issue Observed: The script hangs and does not complete execution
> post-update. Previously, it took around two hours; now it runs for
> over 17 hours without finishing.

Do you still have the RHEL 7 machine? Could you please share the
sessionInfo() output at least from the RHEL 8 machine but, if possible,
also from the RHEL 7 machine?

>   library(foreach)
>   library(parallel)
>   library(parallelly)
>   library(forecast)
>   library(tseries)
>   library(prophet)
>   library(lubridate)
>   library(tis)
>   library(tsoutliers)

Could you identify and share the parts of the script that launch the
computation in parallel?

--
Best regards,
Ivan

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.

[https://s-install.avcdn.net/ipm/preview/icons/icon-envelope-tick-round-orange-animated-no-repeat-v1.gif]<https://www.avast.com/sig-email?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=webmail>  Virus-free.www.avast.com<https://www.avast.com/sig-email?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=webmail>

	[[alternative HTML version deleted]]


From rhe|p @end|ng |rom eoo@@dd@@n|  Tue Jan 14 10:39:39 2025
From: rhe|p @end|ng |rom eoo@@dd@@n| (Jan van der Laan)
Date: Tue, 14 Jan 2025 10:39:39 +0100
Subject: [R] Regarding Issue Running Parallel Computing on Linux RHEL
 version 8
In-Reply-To: <PU4P216MB156853B95746B9642B759577C8182@PU4P216MB1568.KORP216.PROD.OUTLOOK.COM>
References: <PN2PR01MB413718F6DEB2F2A8B72E8B10E21F2@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>
 <20250114112252.14b90d22@Tarkus>
 <PU4P216MB156853B95746B9642B759577C8182@PU4P216MB1568.KORP216.PROD.OUTLOOK.COM>
Message-ID: <5b6c4566-5e77-4611-919e-36bbb831f000@eoos.dds.nl>


On 1/14/25 10:07, akshay kulkarni wrote:
> dear Ivan,
>                    THe present problem had been encountered by me also about 1 and a half years ago. You had solved the issue then. Can't we search this mail list according to some keywords? It helps people with problems already solved in the mailing list.

Using a search engine and adding `site:stat.ethz.ch` (the mail archives 
are hosted there) seems to work. For example:

https://duckduckgo.com/?q=AKSHAY++KULKARNI+parallel+site%3Astat.ethz.ch&t=ftsa&ia=web

Is any of these results what you are referring to?

Jan


From @k@h@y_e4 @end|ng |rom hotm@||@com  Tue Jan 14 11:42:44 2025
From: @k@h@y_e4 @end|ng |rom hotm@||@com (akshay kulkarni)
Date: Tue, 14 Jan 2025 10:42:44 +0000
Subject: [R] Regarding Issue Running Parallel Computing on Linux RHEL
 version 8
In-Reply-To: <5b6c4566-5e77-4611-919e-36bbb831f000@eoos.dds.nl>
References: <PN2PR01MB413718F6DEB2F2A8B72E8B10E21F2@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>
 <20250114112252.14b90d22@Tarkus>
 <PU4P216MB156853B95746B9642B759577C8182@PU4P216MB1568.KORP216.PROD.OUTLOOK.COM>
 <5b6c4566-5e77-4611-919e-36bbb831f000@eoos.dds.nl>
Message-ID: <PU4P216MB1568F80078ABDF195935EA67C8182@PU4P216MB1568.KORP216.PROD.OUTLOOK.COM>

Dear Jan,
                  Seems like it is. Can one search for posts without the posters name? Like in stack overflow?

THanking you,
Yours sincerely,
AKSHAY M KULKARNI
________________________________
From: R-help <r-help-bounces at r-project.org> on behalf of Jan van der Laan <rhelp at eoos.dds.nl>
Sent: Tuesday, January 14, 2025 3:09 PM
To: r-help at r-project.org <r-help at r-project.org>
Subject: Re: [R] Regarding Issue Running Parallel Computing on Linux RHEL version 8


On 1/14/25 10:07, akshay kulkarni wrote:
> dear Ivan,
>                    THe present problem had been encountered by me also about 1 and a half years ago. You had solved the issue then. Can't we search this mail list according to some keywords? It helps people with problems already solved in the mailing list.

Using a search engine and adding `site:stat.ethz.ch` (the mail archives
are hosted there) seems to work. For example:

https://duckduckgo.com/?q=AKSHAY++KULKARNI+parallel+site%3Astat.ethz.ch&t=ftsa&ia=web

Is any of these results what you are referring to?

Jan

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.

	[[alternative HTML version deleted]]


From S@d@mhu@en@Hu@en| @end|ng |rom genp@ct@com  Tue Jan 14 15:23:54 2025
From: S@d@mhu@en@Hu@en| @end|ng |rom genp@ct@com (Huseni, Sadamhusen)
Date: Tue, 14 Jan 2025 14:23:54 +0000
Subject: [R] Regarding Issue Running Parallel Computing on Linux RHEL
 version 8
In-Reply-To: <20250114112252.14b90d22@Tarkus>
References: <PN2PR01MB413718F6DEB2F2A8B72E8B10E21F2@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>
 <20250114112252.14b90d22@Tarkus>
Message-ID: <PN2PR01MB413744391F0017580A1A5BF4E2182@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>

Hi Ivan,

I am sharing the session information as below. Also, I will be sharing the code which is utilized to do parallel computing.
Note: we are using different version of R on Linux version 7 & 8.

###***Session information from Linux version 8
R version 4.4.1 (2024-06-14)
Platform: x86_64-redhat-linux-gnu
Running under: Red Hat Enterprise Linux 8.10 (Ootpa)
 
Matrix products: default
BLAS/LAPACK: /usr/lib64/libopenblaso-r0.3.15.so;  LAPACK version 3.9.0
 
locale:
[1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C
[3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8
[5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8
[7] LC_PAPER=en_US.UTF-8       LC_NAME=C
[9] LC_ADDRESS=C               LC_TELEPHONE=C
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C
 
time zone: America/New_York
tzcode source: system (glibc)
 
attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base
 
loaded via a namespace (and not attached):
[1] compiler_4.4.1

###***Session information from Linux version 7

R version 3.6.0 (2019-04-26)
Platform: x86_64-redhat-linux-gnu (64-bit)
Running under: Red Hat Enterprise Linux
 
Matrix products: default
BLAS/LAPACK: /usr/lib64/R/lib/libRblas.so
 
locale:
[1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C
[3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8
[5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8
[7] LC_PAPER=en_US.UTF-8       LC_NAME=C
[9] LC_ADDRESS=C               LC_TELEPHONE=C
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C
 
attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base
 
loaded via a namespace (and not attached):
[1] compiler_3.6.0


Thanks,
Sadam

-----Original Message-----
From: Ivan Krylov <ikrylov at disroot.org> 
Sent: Tuesday, January 14, 2025 1:53 PM
To: Huseni, Sadamhusen <Sadamhusen.Huseni at genpact.com>
Cc: r-help at R-project.org
Subject: Re: [R] Regarding Issue Running Parallel Computing on Linux RHEL version 8

>

Dear Sadam,

? Mon, 13 Jan 2025 14:34:20 +0000
"Huseni, Sadamhusen" <Sadamhusen.Huseni at genpact.com> ?????:

> Issue Observed: The script hangs and does not complete execution 
> post-update. Previously, it took around two hours; now it runs for 
> over 17 hours without finishing.

Do you still have the RHEL 7 machine? Could you please share the
sessionInfo() output at least from the RHEL 8 machine but, if possible, also from the RHEL 7 machine?

>   library(foreach)
>   library(parallel)
>   library(parallelly)
>   library(forecast)
>   library(tseries)
>   library(prophet)
>   library(lubridate)
>   library(tis)
>   library(tsoutliers)

Could you identify and share the parts of the script that launch the computation in parallel?

--
Best regards,
Ivan


From n@@@j@v@nderve|den @end|ng |rom gm@||@com  Mon Jan 13 17:05:46 2025
From: n@@@j@v@nderve|den @end|ng |rom gm@||@com (Niels van der Velden)
Date: Mon, 13 Jan 2025 12:05:46 -0400
Subject: [R] [R-pkgs] Announcing geneviewer v0.1.10 Now Available on CRAN
Message-ID: <CANBF2awsFFWuB6YjwxZuZSEtrC0beevxR_GqpMqX+_NMtS3Uew@mail.gmail.com>

Dear all,

I am happy to announce that {geneviewer*}* v0.1.10 is now on CRAN.

*{geneviewer}* is an R package for plotting gene clusters and transcripts.
It imports data from GenBank, FASTA, and GFF files, performs BlastP and
MUMmer alignments, and displays results on gene arrow maps. The package
offers extensive customization options, including legends, labels,
annotations, scales, colors, tooltips, and more.

   - *CRAN:* https://cran.r-project.org/web/packages/geneviewer/index.html
   - *GitHub Repository:* https://github.com/nvelden/geneviewer
   - *Package website:  *https://nvelden.github.io/geneviewer/
   <https://github.com/nvelden/geneviewer/issues>
   - *Bug Reports:* https://github.com/nvelden/geneviewer/issues

I hope you find {*geneviewer}* helpful.

Please feel free to reach out with feedback or questions.

Thanks,

Niels van der Velden

	[[alternative HTML version deleted]]

_______________________________________________
R-packages mailing list
R-packages at r-project.org
https://stat.ethz.ch/mailman/listinfo/r-packages


From |kry|ov @end|ng |rom d|@root@org  Tue Jan 14 20:48:43 2025
From: |kry|ov @end|ng |rom d|@root@org (Ivan Krylov)
Date: Tue, 14 Jan 2025 22:48:43 +0300
Subject: [R] Regarding Issue Running Parallel Computing on Linux RHEL
 version 8
In-Reply-To: <PN2PR01MB413744391F0017580A1A5BF4E2182@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>
References: <PN2PR01MB413718F6DEB2F2A8B72E8B10E21F2@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>
 <20250114112252.14b90d22@Tarkus>
 <PN2PR01MB413744391F0017580A1A5BF4E2182@PN2PR01MB4137.INDPRD01.PROD.OUTLOOK.COM>
Message-ID: <20250114224843.067e4500@Tarkus>

? Tue, 14 Jan 2025 14:23:54 +0000
"Huseni, Sadamhusen" <Sadamhusen.Huseni at genpact.com> ?????:

> ###***Session information from Linux version 8
> R version 4.4.1 (2024-06-14)
> Platform: x86_64-redhat-linux-gnu
> Running under: Red Hat Enterprise Linux 8.10 (Ootpa)
>  
> Matrix products: default
> BLAS/LAPACK: /usr/lib64/libopenblaso-r0.3.15.so;  LAPACK version 3.9.0
 
> ###***Session information from Linux version 7
> 
> R version 3.6.0 (2019-04-26)
> Platform: x86_64-redhat-linux-gnu (64-bit)
> Running under: Red Hat Enterprise Linux
>  
> Matrix products: default
> BLAS/LAPACK: /usr/lib64/R/lib/libRblas.so

On RHEL 7, R was using the reference BLAS (linear algebra library).
On RHEL 8, R is using OpenBLAS compiled with OpenMP support. It is
probably creating its own threads, one per CPU, in every child process,
which gives you N^2 processes contending for N CPUs.

Try running your script with the environment variable
OPENBLAS_NUM_THREADS set to the string "1".

It might be possible to speed up the script by setting
OPENBLAS_NUM_THREADS=2 and dividing the number of child processes by
the same number.

-- 
Best regards,
Ivan


From n@re@h_gurbux@n| @end|ng |rom hotm@||@com  Wed Jan 15 00:08:31 2025
From: n@re@h_gurbux@n| @end|ng |rom hotm@||@com (Naresh Gurbuxani)
Date: Tue, 14 Jan 2025 23:08:31 +0000
Subject: [R] Need help with time series
In-Reply-To: <BY3PR09MB8260C6D0388D8E716A81A0D4BF182@BY3PR09MB8260.namprd09.prod.outlook.com>
References: <BY3PR09MB8260C6D0388D8E716A81A0D4BF182@BY3PR09MB8260.namprd09.prod.outlook.com>
Message-ID: <IA1P223MB0499674BFE095259AD4DD33FFA182@IA1P223MB0499.NAMP223.PROD.OUTLOOK.COM>

For below data, I find strange results in basic time series analysis.  Why does acf() function find missing values?  When crossprod(xmat) is invertible, why does arima() find system exactly singular?

Thanks,
Naresh

x <- c(24957, 10577, -18516, 2940, -1458, 32704, -26697, -46902, 48413, -11937, 2043, 26431, -55336, -16838, 89651, 25363,    -50388, -41012, -28242, -18213, 58759, -15290, -7413, 124098)

myts <- zoo::zoo(x,                 seq.Date(as.Date("2022-12-31"), as.Date("2024-11-30"), by = "1 month"))

> myts

2022-12-31 2023-01-31 2023-03-03 2023-03-31 2023-05-01 2023-05-31 2023-07-01

     24957      10577     -18516       2940      -1458      32704     -26697

2023-07-31 2023-08-31 2023-10-01 2023-10-31 2023-12-01 2023-12-31 2024-01-31

    -46902      48413     -11937       2043      26431     -55336     -16838

2024-03-02 2024-03-31 2024-05-01 2024-05-31 2024-07-01 2024-07-31 2024-08-31

     89651      25363     -50388     -41012     -28242     -18213      58759

2024-10-01 2024-10-31

    -15290      -7413

> coredata(myts) |> class()

[1] "numeric"

> acf(myts, lag.max = 2)

Error in na.fail.default(as.ts(x)) : missing values in object

> arima(myts, order = c(1, 0, 0))

Error in solve.default(res$hessian * n.used, A) :

  Lapack routine dgesv: system is exactly singular: U[1,1] = 0

> xmat <- na.omit(cbind(x = myts, xlag1 = lag(myts, k = -1)))

> crossprod(xmat) |> solve()

                 x        xlag1

x     3.488838e-11 1.949958e-12

xlag1 1.949958e-12 3.421268e-11



	[[alternative HTML version deleted]]


From po|c1410 @end|ng |rom gm@||@com  Wed Jan 15 00:50:48 2025
From: po|c1410 @end|ng |rom gm@||@com (CALUM POLWART)
Date: Tue, 14 Jan 2025 23:50:48 +0000
Subject: [R] Need help with time series
In-Reply-To: <IA1P223MB0499674BFE095259AD4DD33FFA182@IA1P223MB0499.NAMP223.PROD.OUTLOOK.COM>
References: <BY3PR09MB8260C6D0388D8E716A81A0D4BF182@BY3PR09MB8260.namprd09.prod.outlook.com>
 <IA1P223MB0499674BFE095259AD4DD33FFA182@IA1P223MB0499.NAMP223.PROD.OUTLOOK.COM>
Message-ID: <CA+etgPnSZYWnX4MsyCnXVE458WWp5E78qcAqHdipLEGgtALxHg@mail.gmail.com>

acf wants a time series, so tries to make one:

as.ts(myts)

Time Series:
Start = 19357
End = 20027
Frequency = 1
  [1]  24957     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [11]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [21]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [31]     NA  10577     NA     NA     NA     NA     NA     NA     NA     NA
 [41]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [51]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [61]     NA     NA -18516     NA     NA     NA     NA     NA     NA     NA
 [71]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [81]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [91]   2940     NA     NA     NA     NA     NA     NA     NA     NA     NA
[101]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
[111]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
[121]     NA  -1458     NA     NA     NA     NA     NA     NA     NA     NA
[131]     NA     NA


I'm not familiar enough with TS to know how you make them 31d month
units...


On Tue, 14 Jan 2025, 23:08 Naresh Gurbuxani, <naresh_gurbuxani at hotmail.com>
wrote:

> For below data, I find strange results in basic time series analysis.  Why
> does acf() function find missing values?  When crossprod(xmat) is
> invertible, why does arima() find system exactly singular?
>
> Thanks,
> Naresh
>
> x <- c(24957, 10577, -18516, 2940, -1458, 32704, -26697, -46902, 48413,
> -11937, 2043, 26431, -55336, -16838, 89651, 25363,    -50388, -41012,
> -28242, -18213, 58759, -15290, -7413, 124098)
>
> myts <- zoo::zoo(x,                 seq.Date(as.Date("2022-12-31"),
> as.Date("2024-11-30"), by = "1 month"))
>
> > myts
>
> 2022-12-31 2023-01-31 2023-03-03 2023-03-31 2023-05-01 2023-05-31
> 2023-07-01
>
>      24957      10577     -18516       2940      -1458      32704
>  -26697
>
> 2023-07-31 2023-08-31 2023-10-01 2023-10-31 2023-12-01 2023-12-31
> 2024-01-31
>
>     -46902      48413     -11937       2043      26431     -55336
>  -16838
>
> 2024-03-02 2024-03-31 2024-05-01 2024-05-31 2024-07-01 2024-07-31
> 2024-08-31
>
>      89651      25363     -50388     -41012     -28242     -18213
> 58759
>
> 2024-10-01 2024-10-31
>
>     -15290      -7413
>
> > coredata(myts) |> class()
>
> [1] "numeric"
>
> > acf(myts, lag.max = 2)
>
> Error in na.fail.default(as.ts(x)) : missing values in object
>
> > arima(myts, order = c(1, 0, 0))
>
> Error in solve.default(res$hessian * n.used, A) :
>
>   Lapack routine dgesv: system is exactly singular: U[1,1] = 0
>
> > xmat <- na.omit(cbind(x = myts, xlag1 = lag(myts, k = -1)))
>
> > crossprod(xmat) |> solve()
>
>                  x        xlag1
>
> x     3.488838e-11 1.949958e-12
>
> xlag1 1.949958e-12 3.421268e-11
>
>
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From w@||y @end|ng |rom m@ge|@@org  Tue Jan 14 19:39:19 2025
From: w@||y @end|ng |rom m@ge|@@org (Jani =?UTF-8?B?VsOkbGltYWE=?=)
Date: Tue, 14 Jan 2025 20:39:19 +0200
Subject: [R] Weird and changed  as.roman() behavior
Message-ID: <20250114203919.1b387d3c.wally@mageia.org>

Hello,

I don't know what's changed or how to figure out why as.roman() started
to work different way lately on Mageia Cauldron. Cauldron is the
latest development version of Mageia Linux.

Expected bahavior:
> as.roman(strrep("I", 1:5))
[1] I   II  III IV  V  

Current behavior:
> as.roman(strrep("I", 1:5))
[1] I    II   III  IV   <NA>
Warning message:
In .roman2numeric(x) : invalid roman numeral: IIIII

as.roman() doesn't handle "IIIII" -> "V" anymore and thus 'make check'
fails when building any 4.3.x or 4.4.x versions from the sources.

Any hints?

-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP-allekirjoitus
URL: <https://stat.ethz.ch/pipermail/r-help/attachments/20250114/13f7017c/attachment.sig>

From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Wed Jan 15 11:41:34 2025
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Wed, 15 Jan 2025 11:41:34 +0100
Subject: [R] Weird and changed  as.roman() behavior
In-Reply-To: <20250114203919.1b387d3c.wally@mageia.org>
References: <20250114203919.1b387d3c.wally@mageia.org>
Message-ID: <26503.37086.16888.723297@stat.math.ethz.ch>

>>>>> Jani V?limaa 
>>>>>     on Tue, 14 Jan 2025 20:39:19 +0200 writes:

    > Hello,
    > I don't know what's changed or how to figure out why as.roman() started
    > to work different way lately on Mageia Cauldron. Cauldron is the
    > latest development version of Mageia Linux.

    > Expected bahavior:
    >> as.roman(strrep("I", 1:5))
    > [1] I   II  III IV  V  

    > Current behavior:
    >> as.roman(strrep("I", 1:5))
    > [1] I    II   III  IV   <NA>
    > Warning message:
    > In .roman2numeric(x) : invalid roman numeral: IIIII

    > as.roman() doesn't handle "IIIII" -> "V" anymore and thus 'make check'
    > fails when building any 4.3.x or 4.4.x versions from the sources.

Not yet.
For me, (on Linux Fedora 40),
on current R-4.4.2,  R-patched and R-devel  I get the same good
results from

 (cc <- strrep("I", 1:5)); (rr <- as.roman(cc)); dput(rr)
 
  > (cc <- strrep("I", 1:5)); (rr <- as.roman(cc)); dput(rr)
  [1] "I"     "II"    "III"   "IIII"  "IIIII"
  [1] I   II  III IV  V  
  structure(1:5, class = "roman")
  >

The code behind this uses grep() and grepl()
and I assume this somehow does not work correctly on your
platform?

Digging a bit further, the crucial part in this case happens in
the (namespace hidden) function   utils ::: .roman2numeric
which you probably already know from the above warning.
For me,

 (cc <- strrep("I", 1:5)); (r2 <- utils:::.roman2numeric(cc)); dput(r2)

gives

  > (cc <- strrep("I", 1:5)); (r2 <- utils:::.roman2numeric(cc))
  [1] "I"     "II"    "III"   "IIII"  "IIIII"
  [1] 1 2 3 4 5
  >

this must be different in your case.

You can use
	debug(utils:::.roman2numeric)
and
	utils:::.roman2numeric(cc)

to find out where the problem happens.
This will show almost surely that the problem is indeed in a
grepl() call.

I'm close to sure it is this:

> grepl("^M{,3}D?C{,4}L?X{,4}V?I{,4}$", cc)
[1] TRUE TRUE TRUE TRUE TRUE

where you don't get the same, but probably

  [1] TRUE TRUE TRUE TRUE FALSE

which I *do* get, too if I use  grepl(....., perl=TRUE)
.. see also below.


The code we use is our own tweaked version of 'TRE' (in <Rsrc>/extra/tre/ ),
and I do think we've occasionally seen platform dependencies.

Also, yes, in 2022 there have been several changes, related to
fixing bugs, though several ones *before* releasing R 4.3.0.

Last, but not (at all!) least:

Actually, I *am* confused a bit why this ever worked (and still
works for most of us):

I'm using {,2} instead of {,4}  to make things faster to grasp;
I see

  > grepl("^I{,2}$", c("II", "III", "IIII"))
  [1]  TRUE  TRUE FALSE
  >

and I wonder why 'I{,2}' matches 3 "I"s. ... I'd thought {,2} to
mean " up to 2 occurrences (of the previous <entity>)"
(where here <entity> = character).

In our real example,  I{,4} matched 5 "I"s

and as I mentioned above, the somewhat more maintained
perl=TRUE option does *not*.

We could change the code to use  I{,5}  to make 5x"I", i.e. "IIIII" 
work for you .. but then that would also match
"IIIIII" (6 x "I") for "everybody" else with our current TRE engine..


From @te|@nML @end|ng |rom co||oc@t|on@@de  Wed Jan 15 13:18:03 2025
From: @te|@nML @end|ng |rom co||oc@t|on@@de (Stephanie Evert)
Date: Wed, 15 Jan 2025 13:18:03 +0100
Subject: [R] Weird and changed  as.roman() behavior
In-Reply-To: <26503.37086.16888.723297@stat.math.ethz.ch>
References: <20250114203919.1b387d3c.wally@mageia.org>
 <26503.37086.16888.723297@stat.math.ethz.ch>
Message-ID: <B7E191AD-E864-4293-A693-9C98B2CD7ADF@collocations.de>

Well, the real issue then seems to be that .roman2numeric uses an invalid regular expression:

>> grepl("^M{,3}D?C{,4}L?X{,4}V?I{,4}$", cc)
> [1] TRUE TRUE TRUE TRUE TRUE

or 

>> grepl("^I{,2}$", c("II", "III", "IIII"))
>  [1]  TRUE  TRUE FALSE


Both the TRE and the PCRE specification only allow repetition quantifiers of the form

	{a}
	{a,b}
	{a,}

https://laurikari.net/tre/documentation/regex-syntax/
https://www.pcre.org/original/doc/html/pcrepattern.html#SEC17

{,2} and {,4} are thus invalid and seem to result in undefined behaviour (which PCRE and TRE fill in different ways, but consistently not what was intended). 

> > grepl("^I{,2}$", c("II", "III", "IIII"))
> [1]  TRUE  TRUE FALSE

> > grepl("^I{,2}$", c("II", "III", "IIII"), perl=TRUE)
> [1] FALSE FALSE FALSE

Fix thus is easy: {,4} => {0,4}

Best,
Stephanie

From e||@n@m@d|@on @end|ng |rom |@u@edu  Tue Jan 14 18:29:50 2025
From: e||@n@m@d|@on @end|ng |rom |@u@edu (Eliana Madison)
Date: Tue, 14 Jan 2025 10:29:50 -0700
Subject: [R] Installing R and RStudio - Contact Software Manufacturer Error
 URGENT
Message-ID: <CACbUi+Epg9BCvAyFMTWMCWkAvqy0x+dY4-jogCVCbHc=Z0JQZg@mail.gmail.com>

Good morning, I am currently trying to download R and RStudio to my MacOS
13.3 as it is a requirement for a statistics class I am taking this
semester.

I have checked and I have plenty of storage available however after the
downloading process is complete and I go to install the program this error
pops up: The installation failed. The Installer encountered an error that
caused the installation to fail. Contact the software manufacturer for
assistance.

Please provide guidance on how to remedy this issue so I can complete the
installation process and get started on my coursework.

I look forward to hearing from you as soon as possible!

Thank you,

-- 

Eliana Madison
ASISU Secretary | Social Work Student
Pronouns: She, Her, Hers

elianamadison at isu.edu
Idaho State University[image: Idaho State University]

Idaho State University (Pocatello) acknowledges that it is located within
the boundaries of the original Fort Hall Reservation on the traditional
lands of the Shoshone and Bannock peoples.Idaho State Universit

	[[alternative HTML version deleted]]


From @teven@|onzoe|||@ @end|ng |rom gm@||@com  Wed Jan 15 19:46:27 2025
From: @teven@|onzoe|||@ @end|ng |rom gm@||@com (Steven Ellis)
Date: Wed, 15 Jan 2025 13:46:27 -0500
Subject: [R] 
 Installing R and RStudio - Contact Software Manufacturer Error
 URGENT
In-Reply-To: <CACbUi+Epg9BCvAyFMTWMCWkAvqy0x+dY4-jogCVCbHc=Z0JQZg@mail.gmail.com>
References: <CACbUi+Epg9BCvAyFMTWMCWkAvqy0x+dY4-jogCVCbHc=Z0JQZg@mail.gmail.com>
Message-ID: <CAHOiV1o7-LvpUzggeAAo10YFsRTXJNN+D3GG=Ey8i5+DK+Vf2A@mail.gmail.com>

Hi Eliana,

What model Mac are you using? Are you the owner?

Thanks,
Steven

On Wed, Jan 15, 2025, 1:45?PM Eliana Madison <elianamadison at isu.edu> wrote:

> Good morning, I am currently trying to download R and RStudio to my MacOS
> 13.3 as it is a requirement for a statistics class I am taking this
> semester.
>
> I have checked and I have plenty of storage available however after the
> downloading process is complete and I go to install the program this error
> pops up: The installation failed. The Installer encountered an error that
> caused the installation to fail. Contact the software manufacturer for
> assistance.
>
> Please provide guidance on how to remedy this issue so I can complete the
> installation process and get started on my coursework.
>
> I look forward to hearing from you as soon as possible!
>
> Thank you,
>
> --
>
> Eliana Madison
> ASISU Secretary | Social Work Student
> Pronouns: She, Her, Hers
>
> elianamadison at isu.edu
> Idaho State University[image: Idaho State University]
>
> Idaho State University (Pocatello) acknowledges that it is located within
> the boundaries of the original Fort Hall Reservation on the traditional
> lands of the Shoshone and Bannock peoples.Idaho State Universit
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From m@rc_@chw@rtz @end|ng |rom me@com  Wed Jan 15 20:14:02 2025
From: m@rc_@chw@rtz @end|ng |rom me@com (Marc Schwartz)
Date: Wed, 15 Jan 2025 14:14:02 -0500
Subject: [R] 
 Installing R and RStudio - Contact Software Manufacturer Error
 URGENT
In-Reply-To: <CAHOiV1o7-LvpUzggeAAo10YFsRTXJNN+D3GG=Ey8i5+DK+Vf2A@mail.gmail.com>
References: <CACbUi+Epg9BCvAyFMTWMCWkAvqy0x+dY4-jogCVCbHc=Z0JQZg@mail.gmail.com>
 <CAHOiV1o7-LvpUzggeAAo10YFsRTXJNN+D3GG=Ey8i5+DK+Vf2A@mail.gmail.com>
Message-ID: <73D77E38-15E3-452B-8B30-F391EC5DDA68@me.com>

Hi Eliana,

It is not clear which application is causing the error.

As you are running macOS 13.3 (Ventura) and that you are trying to install both R and RStudio (two separate applications from two different entities), please confirm that you downloaded the correct version of R for your Mac from CRAN, as per:

  https://cran.r-project.org/bin/macosx/

If you are on an older x86 Intel based Mac, you need to be sure that you downloaded R-4.4.2-x86_64.pkg from CRAN, and pay attention to the installation note on the above CRAN page:

"macOS Ventura users: there is a known bug in Ventura preventing installations from some locations without a prompt. If the installation fails, move the downloaded file away from the Downloads folder (e.g., to your home or Desktop)."

If you are an Apple ARM (e.g. M1) based Mac, you need to be sure to download R-4.4.2-arm64.pkg from CRAN.

As Steven notes below, this all presumes that you have the relevant access privileges to install software on the Mac and are not otherwise restricted by, for example, any security policies implemented by the owner of the Mac, if that is not you.

I do not use RStudio, and you may need to contact Posit, the publishers of that application via their support site, if the error is from their application and not R itself.

  https://support.posit.co/

Regards,

Marc Schwartz


> On Jan 15, 2025, at 1:46?PM, Steven Ellis <stevenalonzoellis at gmail.com> wrote:
> 
> Hi Eliana,
> 
> What model Mac are you using? Are you the owner?
> 
> Thanks,
> Steven
> 
> On Wed, Jan 15, 2025, 1:45?PM Eliana Madison <elianamadison at isu.edu> wrote:
> 
>> Good morning, I am currently trying to download R and RStudio to my MacOS
>> 13.3 as it is a requirement for a statistics class I am taking this
>> semester.
>> 
>> I have checked and I have plenty of storage available however after the
>> downloading process is complete and I go to install the program this error
>> pops up: The installation failed. The Installer encountered an error that
>> caused the installation to fail. Contact the software manufacturer for
>> assistance.
>> 
>> Please provide guidance on how to remedy this issue so I can complete the
>> installation process and get started on my coursework.
>> 
>> I look forward to hearing from you as soon as possible!
>> 
>> Thank you,
>> 
>> --
>> 
>> Eliana Madison
>> ASISU Secretary | Social Work Student
>> Pronouns: She, Her, Hers
>> 
>> elianamadison at isu.edu
>> Idaho State University[image: Idaho State University]
>> 
>> Idaho State University (Pocatello) acknowledges that it is located within
>> the boundaries of the original Fort Hall Reservation on the traditional
>> lands of the Shoshone and Bannock peoples.Idaho State Universit
>> 
>>        [[alternative HTML version deleted]]
>> 
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide
>> https://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>> 
> 
> [[alternative HTML version deleted]]
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From n@re@h_gurbux@n| @end|ng |rom hotm@||@com  Thu Jan 16 02:10:19 2025
From: n@re@h_gurbux@n| @end|ng |rom hotm@||@com (Naresh Gurbuxani)
Date: Thu, 16 Jan 2025 01:10:19 +0000
Subject: [R] Need help with time series
In-Reply-To: <CA+etgPnSZYWnX4MsyCnXVE458WWp5E78qcAqHdipLEGgtALxHg@mail.gmail.com>
References: <BY3PR09MB8260C6D0388D8E716A81A0D4BF182@BY3PR09MB8260.namprd09.prod.outlook.com>
 <IA1P223MB0499674BFE095259AD4DD33FFA182@IA1P223MB0499.NAMP223.PROD.OUTLOOK.COM>
 <CA+etgPnSZYWnX4MsyCnXVE458WWp5E78qcAqHdipLEGgtALxHg@mail.gmail.com>
Message-ID: <IA1P223MB0499A4A5CA5EB1C4B93E1E1BFA1A2@IA1P223MB0499.NAMP223.PROD.OUTLOOK.COM>

Thanks for providing direction.  By redefining time using as.yearmon(), I got acf() working.

Sent from my iPhone

On Jan 14, 2025, at 6:51?PM, CALUM POLWART <polc1410 at gmail.com> wrote:

?
acf wants a time series, so tries to make one:

as.ts(myts)


Time Series:
Start = 19357
End = 20027
Frequency = 1
  [1]  24957     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [11]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [21]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [31]     NA  10577     NA     NA     NA     NA     NA     NA     NA     NA
 [41]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [51]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [61]     NA     NA -18516     NA     NA     NA     NA     NA     NA     NA
 [71]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [81]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
 [91]   2940     NA     NA     NA     NA     NA     NA     NA     NA     NA
[101]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
[111]     NA     NA     NA     NA     NA     NA     NA     NA     NA     NA
[121]     NA  -1458     NA     NA     NA     NA     NA     NA     NA     NA
[131]     NA     NA

I'm not familiar enough with TS to know how you make them 31d month units...


On Tue, 14 Jan 2025, 23:08 Naresh Gurbuxani, <naresh_gurbuxani at hotmail.com<mailto:naresh_gurbuxani at hotmail.com>> wrote:
For below data, I find strange results in basic time series analysis.  Why does acf() function find missing values?  When crossprod(xmat) is invertible, why does arima() find system exactly singular?

Thanks,
Naresh

x <- c(24957, 10577, -18516, 2940, -1458, 32704, -26697, -46902, 48413, -11937, 2043, 26431, -55336, -16838, 89651, 25363,    -50388, -41012, -28242, -18213, 58759, -15290, -7413, 124098)

myts <- zoo::zoo(x,                 seq.Date(as.Date("2022-12-31"), as.Date("2024-11-30"), by = "1 month"))

> myts

2022-12-31 2023-01-31 2023-03-03 2023-03-31 2023-05-01 2023-05-31 2023-07-01

     24957      10577     -18516       2940      -1458      32704     -26697

2023-07-31 2023-08-31 2023-10-01 2023-10-31 2023-12-01 2023-12-31 2024-01-31

    -46902      48413     -11937       2043      26431     -55336     -16838

2024-03-02 2024-03-31 2024-05-01 2024-05-31 2024-07-01 2024-07-31 2024-08-31

     89651      25363     -50388     -41012     -28242     -18213      58759

2024-10-01 2024-10-31

    -15290      -7413

> coredata(myts) |> class()

[1] "numeric"

> acf(myts, lag.max = 2)

Error in na.fail.default(as.ts(x)) : missing values in object

> arima(myts, order = c(1, 0, 0))

Error in solve.default(res$hessian * n.used, A) :

  Lapack routine dgesv: system is exactly singular: U[1,1] = 0

> xmat <- na.omit(cbind(x = myts, xlag1 = lag(myts, k = -1)))

> crossprod(xmat) |> solve()

                 x        xlag1

x     3.488838e-11 1.949958e-12

xlag1 1.949958e-12 3.421268e-11



        [[alternative HTML version deleted]]

______________________________________________
R-help at r-project.org<mailto:R-help at r-project.org> mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.

	[[alternative HTML version deleted]]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Jan 16 12:04:44 2025
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 16 Jan 2025 12:04:44 +0100
Subject: [R] Weird and changed  as.roman() behavior
In-Reply-To: <B7E191AD-E864-4293-A693-9C98B2CD7ADF@collocations.de>
References: <20250114203919.1b387d3c.wally@mageia.org>
 <26503.37086.16888.723297@stat.math.ethz.ch>
 <B7E191AD-E864-4293-A693-9C98B2CD7ADF@collocations.de>
Message-ID: <26504.59340.595600.98138@stat.math.ethz.ch>

>>>>> Stephanie Evert 
>>>>>     on Wed, 15 Jan 2025 13:18:03 +0100 writes:

    > Well, the real issue then seems to be that .roman2numeric uses an invalid regular expression:
    >>> grepl("^M{,3}D?C{,4}L?X{,4}V?I{,4}$", cc)
    >> [1] TRUE TRUE TRUE TRUE TRUE

    > or 

    >>> grepl("^I{,2}$", c("II", "III", "IIII"))
    >> [1]  TRUE  TRUE FALSE


    > Both the TRE and the PCRE specification only allow repetition quantifiers of the form

    > {a}
    > {a,b}
    > {a,}

    > https://laurikari.net/tre/documentation/regex-syntax/
    > https://www.pcre.org/original/doc/html/pcrepattern.html#SEC17

    > {,2} and {,4} are thus invalid and seem to result in undefined behaviour (which PCRE and TRE fill in different ways, but consistently not what was intended). 

    >> > grepl("^I{,2}$", c("II", "III", "IIII"))
    >> [1]  TRUE  TRUE FALSE

    >> > grepl("^I{,2}$", c("II", "III", "IIII"), perl=TRUE)
    >> [1] FALSE FALSE FALSE

    > Fix thus is easy: {,4} => {0,4}

    > Best,
    > Stephanie

Thanks a lot, Stephanie -- indeed, I think I would not have searched in
this direction at all
( To me it seemed "obvious" that if {3,} is well defined,  {,3}
  would be so, too...  But I was *wrong* and actually I also
  understand and that {,3} is not needed, and {0,3} is clearer,
  whereas {3,} is not easy to re-express ( '{0,inf}' or similar
  would make the code considerably more complicated and probably slower..)

Actually, to remain back compatible (see Jani's original report:
he'd like "IIIII" to work, as it did for many/most of us),
we should replace  {,4}  by {0,5}.

But there's more:  our current help page
    https://search.r-project.org/R/refmans/utils/html/roman.html
says

> Only numbers between 1 and 3999 have a unique representation
> as roman numbers, and hence others result in as.roman(NA). 
 
which is really not quite true, in more than one sense:

1.  as.roman(3899:3999)   # works fine

not producing any NA

2. I think, e.g.,  "MMMM"
is a pretty unique representation of 4000.

Also, one piece of other software (online)
    https://www.rapidtables.com/convert/number/date-to-roman-numerals.html

does convert _dates_ up to the year 4999, see,
  https://www.rapidtables.com/convert/number/date-to-roman-numerals.html?msel=January&dsel=1&year=4999&fmtsel=MM.DD.YYYY

giving  MMMMCMXCIX  for 4999.

Hence, I also think we should enlarge the valid range from current
{1 .. 3999}  to 
{1 .. 4999}

Martin


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Jan 16 12:21:33 2025
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 16 Jan 2025 12:21:33 +0100
Subject: [R] Weird and changed  as.roman() behavior
In-Reply-To: <26504.59340.595600.98138@stat.math.ethz.ch>
References: <20250114203919.1b387d3c.wally@mageia.org>
 <26503.37086.16888.723297@stat.math.ethz.ch>
 <B7E191AD-E864-4293-A693-9C98B2CD7ADF@collocations.de>
 <26504.59340.595600.98138@stat.math.ethz.ch>
Message-ID: <26504.60349.776115.960026@stat.math.ethz.ch>

>>>>> Martin Maechler 
>>>>>     on Thu, 16 Jan 2025 12:04:44 +0100 writes:

 [..............]

    > But there's more:  our current help page
    > https://search.r-project.org/R/refmans/utils/html/roman.html
    > says

    >> Only numbers between 1 and 3999 have a unique representation
    >> as roman numbers, and hence others result in as.roman(NA). 
 
    > which is really not quite true, in more than one sense:

    > 1.  as.roman(3899:3999)   # works fine

    > not producing any NA

The above (from "in more than one sense" on) must be somewhat
confusing.  I thought I read '3899' (instead of '3999') on one
version of the help page ...

I hope that everything else I wrote *does* make sense and is hopefully correct...

Martin


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Thu Jan 16 15:01:44 2025
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Thu, 16 Jan 2025 15:01:44 +0100
Subject: [R] 
 readLines on open connection reads only first write on MacOS
In-Reply-To: <6DE24FA0-6908-41B3-9201-5AF522055C5B@icloud.com>
References: <6DE24FA0-6908-41B3-9201-5AF522055C5B@icloud.com>
Message-ID: <9433b744-69bd-4a72-a3ec-e75823e68ca2@gmail.com>

Thanks for the report. I've fixed this in R-devel so that even on macOS, 
one can read data added to a file after end of the file has once been 
reached, which also changes the behavior of your example on macOS to 
match Linux (and Windows).

The difference comes from the C library shipped with the operating 
system. According to the C standard, functions for reading from file, 
such as fgetc() and fread(), should always fail to read data and 
indicate an end of file when the end of file indicator has already been 
set on the file. The C library on macOS behaves this way. On Linux and 
Windows, however, the read operations instead check again if any new 
data is present, even if the end-of-file indicator has been already set. 
That seems to be in violation of the standard, but it made the example 
program work without any attempt made on the R side to make it work (and 
this behavior is not documented). I've modified R-devel to clear the end 
of file indicator so that the behavior observed in R on Windows and 
Linux can now be observed also on macOS. Unless problems are found with 
this change, it would be part of the next (minor or major) R release.

Strictly speaking, the example program is not portable: it opens the 
same file twice in the same process, which is implementation-defined 
behavior according to the C standard, yet it happens to work on current 
platforms R is supported on. I understand it is just an example and the 
real use case is that two processes communicate this way. I don't know 
the exact use case, but it might be more reliable in principle to use a 
different communication mechanism, such as a fifo or multiple files 
(each read only once) or a combination of both.

Best
Tomas

On 10/27/24 13:13, martin gregory via R-help wrote:
> I was using readLines to read data from a file which is being written to by another
> process. readLines documentation says "If the connection is open it is read from its
> current position". With R 4.4.1 on Linux 5.15.160 this is true but does not seem to be the
> case as far as R 4.4.1 on MacOS 12.7.6 (Intel) is concerned. Here, the first write to the
> file is read correctly but subsequent reads return nothing. The minimal program below
> shows the behaviour and produces the following results:
>
> Linux:
> input 1: lines written/read: 4 / 4
> input 2: lines written/read: 3 / 3
> input 3: lines written/read: 2 / 2
>
> MacOS:
> input 1: lines written/read: 4 / 4
> input 2: lines written/read: 3 / 0
> input 3: lines written/read: 2 / 0
>
> I have searched NEWS and found only https://bugs.r-project.org/show_bug.cgi?id=18555, but
> I am not specifying an encoding so not sure whether it is relevant or not.
>
> I also tried with a 1 second delay between flush and read, but this had no effect.
>
> I have found an alternative, scan with skip of the number lines already read, and this
> works on both Linux and MacOS.  But I would still like to know how to have readLines work
> with open connections on MacOS.
>
> Regards,
> Martin
>
> ## Program to demonstrate the behaviour
> ## input data
> rL <- list(paste0("Line ", 1:4), paste0("Line ", 1:3), paste0("Line ", 1:2))
> ## create an empty file and open write and read connections to the file
> close(file("rL.log",open="w"))
> rLconn.w <- file("rL.log", open="a")
> rLconn.r <- file("rL.log", open="r")
> ## write the test data and read it
> for (i in 1:3) {
>      writeLines(rL[[i]], rLconn.w)
>      flush(rLconn.w)
>      out <- readLines(rLconn.r, warn=FALSE)
>      writeLines(c(paste0("input ", i, ": lines",
>                          " written/read: ", length(rL[[i]]),
>                          " / ", length(out))))
> }
> close(rLconn.w)
> close(rLconn.r)
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From w@||y @end|ng |rom m@ge|@@org  Thu Jan 16 16:34:42 2025
From: w@||y @end|ng |rom m@ge|@@org (Jani =?UTF-8?B?VsOkbGltYWE=?=)
Date: Thu, 16 Jan 2025 17:34:42 +0200
Subject: [R] Weird and changed  as.roman() behavior
In-Reply-To: <26503.37086.16888.723297@stat.math.ethz.ch>
References: <20250114203919.1b387d3c.wally@mageia.org>
 <26503.37086.16888.723297@stat.math.ethz.ch>
Message-ID: <20250116173442.4a2a8a3c.wally@mageia.org>

On Wed, 15 Jan 2025 11:41:34 +0100
Martin Maechler wrote:

> >>>>> Jani V?limaa 
> >>>>>     on Tue, 14 Jan 2025 20:39:19 +0200 writes:  
> 
>     > Hello,
>     > I don't know what's changed or how to figure out why as.roman() started
>     > to work different way lately on Mageia Cauldron. Cauldron is the
>     > latest development version of Mageia Linux.  
> 
>     > Expected bahavior:  
>     >> as.roman(strrep("I", 1:5))  
>     > [1] I   II  III IV  V    
> 
>     > Current behavior:  
>     >> as.roman(strrep("I", 1:5))  
>     > [1] I    II   III  IV   <NA>
>     > Warning message:
>     > In .roman2numeric(x) : invalid roman numeral: IIIII  
> 
>     > as.roman() doesn't handle "IIIII" -> "V" anymore and thus 'make check'
>     > fails when building any 4.3.x or 4.4.x versions from the sources.  
> 
> Not yet.
> For me, (on Linux Fedora 40),
> on current R-4.4.2,  R-patched and R-devel  I get the same good
> results from
> 
>  (cc <- strrep("I", 1:5)); (rr <- as.roman(cc)); dput(rr)
>  
>   > (cc <- strrep("I", 1:5)); (rr <- as.roman(cc)); dput(rr)  
>   [1] "I"     "II"    "III"   "IIII"  "IIIII"
>   [1] I   II  III IV  V  
>   structure(1:5, class = "roman")
>   >  
> 
> The code behind this uses grep() and grepl()
> and I assume this somehow does not work correctly on your
> platform?
> 
> Digging a bit further, the crucial part in this case happens in
> the (namespace hidden) function   utils ::: .roman2numeric
> which you probably already know from the above warning.
> For me,
> 
>  (cc <- strrep("I", 1:5)); (r2 <- utils:::.roman2numeric(cc)); dput(r2)
> 
> gives
> 
>   > (cc <- strrep("I", 1:5)); (r2 <- utils:::.roman2numeric(cc))  
>   [1] "I"     "II"    "III"   "IIII"  "IIIII"
>   [1] 1 2 3 4 5
>   >  
> 
> this must be different in your case.
> 
> You can use
> 	debug(utils:::.roman2numeric)
> and
> 	utils:::.roman2numeric(cc)
> 
> to find out where the problem happens.
> This will show almost surely that the problem is indeed in a
> grepl() call.
> 
> I'm close to sure it is this:
> 
> > grepl("^M{,3}D?C{,4}L?X{,4}V?I{,4}$", cc)  
> [1] TRUE TRUE TRUE TRUE TRUE
> 
> where you don't get the same, but probably
> 
>   [1] TRUE TRUE TRUE TRUE FALSE
> 
> which I *do* get, too if I use  grepl(....., perl=TRUE)
> .. see also below.
> 
> 
> The code we use is our own tweaked version of 'TRE' (in <Rsrc>/extra/tre/ ),
> and I do think we've occasionally seen platform dependencies.
> 
> Also, yes, in 2022 there have been several changes, related to
> fixing bugs, though several ones *before* releasing R 4.3.0.
> 
> Last, but not (at all!) least:
> 
> Actually, I *am* confused a bit why this ever worked (and still
> works for most of us):
> 
> I'm using {,2} instead of {,4}  to make things faster to grasp;
> I see
> 
>   > grepl("^I{,2}$", c("II", "III", "IIII"))  
>   [1]  TRUE  TRUE FALSE
>   >  
> 
> and I wonder why 'I{,2}' matches 3 "I"s. ... I'd thought {,2} to
> mean " up to 2 occurrences (of the previous <entity>)"
> (where here <entity> = character).
> 
> In our real example,  I{,4} matched 5 "I"s
> 
> and as I mentioned above, the somewhat more maintained
> perl=TRUE option does *not*.
> 
> We could change the code to use  I{,5}  to make 5x"I", i.e. "IIIII" 
> work for you .. but then that would also match
> "IIIIII" (6 x "I") for "everybody" else with our current TRE engine..
> 

Thanks for your insights.

Mageia uses system TRE with R via --with-system-tre configure option.
TRE was updated some time ago to version 0.9.0, and looks like the
'issue' started at the same time.

And indeed as.roman() works as before after I rebuilt R with bundled
TRE 0.8.0 using --with-system-tre=no.

So, something changed in TRE 0.9.0 and grepl().

-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP-allekirjoitus
URL: <https://stat.ethz.ch/pipermail/r-help/attachments/20250116/683b81f1/attachment.sig>

From r@oknz @end|ng |rom gm@||@com  Sat Jan 18 04:03:51 2025
From: r@oknz @end|ng |rom gm@||@com (Richard O'Keefe)
Date: Sat, 18 Jan 2025 16:03:51 +1300
Subject: [R] Weird and changed as.roman() behavior
In-Reply-To: <26504.59340.595600.98138@stat.math.ethz.ch>
References: <20250114203919.1b387d3c.wally@mageia.org>
 <26503.37086.16888.723297@stat.math.ethz.ch>
 <B7E191AD-E864-4293-A693-9C98B2CD7ADF@collocations.de>
 <26504.59340.595600.98138@stat.math.ethz.ch>
Message-ID: <CABcYAdJYK=svAPE=pD_FWuDppKERXRaaLnGOO0gQdn2FoWG6vQ@mail.gmail.com>

"Roman numerals" is actually a tricky subject, since there were
different versions at different times.
It is worth noting that the Unicode character set (and R does support
Unicode, does it not?) includes
the Roman numeral characters for 5,000 10,000 50,000 and 100,000 so
the idea that 3999 is an acceptable limit
doesn't quite make much sense any more.
It is also worth noting that Unicode also includes single-character
versions of 1-12.
The characters are U+2160 to U+2188.
For what it's worth, the Romans could express fractions that were
multiples of 1/12.

Converting between numbers and their Roman forms is not something that
regular expressions are a good tool for.

On Fri, 17 Jan 2025 at 00:05, Martin Maechler
<maechler at stat.math.ethz.ch> wrote:
>
> >>>>> Stephanie Evert
> >>>>>     on Wed, 15 Jan 2025 13:18:03 +0100 writes:
>
>     > Well, the real issue then seems to be that .roman2numeric uses an invalid regular expression:
>     >>> grepl("^M{,3}D?C{,4}L?X{,4}V?I{,4}$", cc)
>     >> [1] TRUE TRUE TRUE TRUE TRUE
>
>     > or
>
>     >>> grepl("^I{,2}$", c("II", "III", "IIII"))
>     >> [1]  TRUE  TRUE FALSE
>
>
>     > Both the TRE and the PCRE specification only allow repetition quantifiers of the form
>
>     > {a}
>     > {a,b}
>     > {a,}
>
>     > https://laurikari.net/tre/documentation/regex-syntax/
>     > https://www.pcre.org/original/doc/html/pcrepattern.html#SEC17
>
>     > {,2} and {,4} are thus invalid and seem to result in undefined behaviour (which PCRE and TRE fill in different ways, but consistently not what was intended).
>
>     >> > grepl("^I{,2}$", c("II", "III", "IIII"))
>     >> [1]  TRUE  TRUE FALSE
>
>     >> > grepl("^I{,2}$", c("II", "III", "IIII"), perl=TRUE)
>     >> [1] FALSE FALSE FALSE
>
>     > Fix thus is easy: {,4} => {0,4}
>
>     > Best,
>     > Stephanie
>
> Thanks a lot, Stephanie -- indeed, I think I would not have searched in
> this direction at all
> ( To me it seemed "obvious" that if {3,} is well defined,  {,3}
>   would be so, too...  But I was *wrong* and actually I also
>   understand and that {,3} is not needed, and {0,3} is clearer,
>   whereas {3,} is not easy to re-express ( '{0,inf}' or similar
>   would make the code considerably more complicated and probably slower..)
>
> Actually, to remain back compatible (see Jani's original report:
> he'd like "IIIII" to work, as it did for many/most of us),
> we should replace  {,4}  by {0,5}.
>
> But there's more:  our current help page
>     https://search.r-project.org/R/refmans/utils/html/roman.html
> says
>
> > Only numbers between 1 and 3999 have a unique representation
> > as roman numbers, and hence others result in as.roman(NA).
>
> which is really not quite true, in more than one sense:
>
> 1.  as.roman(3899:3999)   # works fine
>
> not producing any NA
>
> 2. I think, e.g.,  "MMMM"
> is a pretty unique representation of 4000.
>
> Also, one piece of other software (online)
>     https://www.rapidtables.com/convert/number/date-to-roman-numerals.html
>
> does convert _dates_ up to the year 4999, see,
>   https://www.rapidtables.com/convert/number/date-to-roman-numerals.html?msel=January&dsel=1&year=4999&fmtsel=MM.DD.YYYY
>
> giving  MMMMCMXCIX  for 4999.
>
> Hence, I also think we should enlarge the valid range from current
> {1 .. 3999}  to
> {1 .. 4999}
>
> Martin
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From jrkr|de@u @end|ng |rom gm@||@com  Sat Jan 18 19:56:47 2025
From: jrkr|de@u @end|ng |rom gm@||@com (John Kane)
Date: Sat, 18 Jan 2025 13:56:47 -0500
Subject: [R] 
 Installing R and RStudio - Contact Software Manufacturer Error
 URGENT
In-Reply-To: <73D77E38-15E3-452B-8B30-F391EC5DDA68@me.com>
References: <CACbUi+Epg9BCvAyFMTWMCWkAvqy0x+dY4-jogCVCbHc=Z0JQZg@mail.gmail.com>
 <CAHOiV1o7-LvpUzggeAAo10YFsRTXJNN+D3GG=Ey8i5+DK+Vf2A@mail.gmail.com>
 <73D77E38-15E3-452B-8B30-F391EC5DDA68@me.com>
Message-ID: <CAKZQJMC6JFt-VDkXBG9fQQs3h2f3diU+yKFGHeYq=HO5HCMfhg@mail.gmail.com>

You may also want to check out forum.posit.co/

On Wed, 15 Jan 2025 at 14:14, Marc Schwartz via R-help <r-help at r-project.org>
wrote:

> Hi Eliana,
>
> It is not clear which application is causing the error.
>
> As you are running macOS 13.3 (Ventura) and that you are trying to install
> both R and RStudio (two separate applications from two different entities),
> please confirm that you downloaded the correct version of R for your Mac
> from CRAN, as per:
>
>   https://cran.r-project.org/bin/macosx/
>
> If you are on an older x86 Intel based Mac, you need to be sure that you
> downloaded R-4.4.2-x86_64.pkg from CRAN, and pay attention to the
> installation note on the above CRAN page:
>
> "macOS Ventura users: there is a known bug in Ventura preventing
> installations from some locations without a prompt. If the installation
> fails, move the downloaded file away from the Downloads folder (e.g., to
> your home or Desktop)."
>
> If you are an Apple ARM (e.g. M1) based Mac, you need to be sure to
> download R-4.4.2-arm64.pkg from CRAN.
>
> As Steven notes below, this all presumes that you have the relevant access
> privileges to install software on the Mac and are not otherwise restricted
> by, for example, any security policies implemented by the owner of the Mac,
> if that is not you.
>
> I do not use RStudio, and you may need to contact Posit, the publishers of
> that application via their support site, if the error is from their
> application and not R itself.
>
>   https://support.posit.co/
>
> Regards,
>
> Marc Schwartz
>
>
> > On Jan 15, 2025, at 1:46?PM, Steven Ellis <stevenalonzoellis at gmail.com>
> wrote:
> >
> > Hi Eliana,
> >
> > What model Mac are you using? Are you the owner?
> >
> > Thanks,
> > Steven
> >
> > On Wed, Jan 15, 2025, 1:45?PM Eliana Madison <elianamadison at isu.edu>
> wrote:
> >
> >> Good morning, I am currently trying to download R and RStudio to my
> MacOS
> >> 13.3 as it is a requirement for a statistics class I am taking this
> >> semester.
> >>
> >> I have checked and I have plenty of storage available however after the
> >> downloading process is complete and I go to install the program this
> error
> >> pops up: The installation failed. The Installer encountered an error
> that
> >> caused the installation to fail. Contact the software manufacturer for
> >> assistance.
> >>
> >> Please provide guidance on how to remedy this issue so I can complete
> the
> >> installation process and get started on my coursework.
> >>
> >> I look forward to hearing from you as soon as possible!
> >>
> >> Thank you,
> >>
> >> --
> >>
> >> Eliana Madison
> >> ASISU Secretary | Social Work Student
> >> Pronouns: She, Her, Hers
> >>
> >> elianamadison at isu.edu
> >> Idaho State University[image: Idaho State University]
> >>
> >> Idaho State University (Pocatello) acknowledges that it is located
> within
> >> the boundaries of the original Fort Hall Reservation on the traditional
> >> lands of the Shoshone and Bannock peoples.Idaho State Universit
> >>
> >>        [[alternative HTML version deleted]]
> >>
> >> ______________________________________________
> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> PLEASE do read the posting guide
> >> https://www.R-project.org/posting-guide.html
> >> and provide commented, minimal, self-contained, reproducible code.
> >>
> >
> > [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


-- 
John Kane
Kingston ON Canada

	[[alternative HTML version deleted]]


From |vo@we|ch @end|ng |rom gm@||@com  Sun Jan 19 00:41:18 2025
From: |vo@we|ch @end|ng |rom gm@||@com (Ivo Welch)
Date: Sat, 18 Jan 2025 15:41:18 -0800
Subject: [R] Parser For Line Number Tracing
Message-ID: <CACi4-Jmb=wXfAH-Xmi=0CZrpSDnzaP0scGBvtsFyeE6g5gmz8w@mail.gmail.com>

I often find myself hunting where in my program an error has happened,
(of course, in R, many error messages are mysterious in themselves,
too, making it even harder.)  the way I do it is mostly with inserting
`message()` statements.

what I would really like to have is a parser that inserted 'curline
<<- ##' into the R code, where '##' is the filename and line number.
something like 'addtracker one.R two.R' and thereafter I can run two.R
and, when the program dies, use `print curline` to find out where my
error has roughly occurred.

has someone already written such an 'instrumenter'?


From |kw@|mmo @end|ng |rom gm@||@com  Sun Jan 19 00:46:08 2025
From: |kw@|mmo @end|ng |rom gm@||@com (Iris Simmons)
Date: Sat, 18 Jan 2025 18:46:08 -0500
Subject: [R] Parser For Line Number Tracing
In-Reply-To: <CACi4-Jmb=wXfAH-Xmi=0CZrpSDnzaP0scGBvtsFyeE6g5gmz8w@mail.gmail.com>
References: <CACi4-Jmb=wXfAH-Xmi=0CZrpSDnzaP0scGBvtsFyeE6g5gmz8w@mail.gmail.com>
Message-ID: <CADNULg-KLM9ZEA4qNpVaHyL1o9QEg8e0Uiz9SUCL7bQ6P3DsmQ@mail.gmail.com>

Hi Ivo,


I maintain 'package:this.path' that I believe does what you want. I
regularly add this to my own code when I need to:

warning(sprintf("remove this later at %s#%d",
this.path::try.this.path(), this.path::LINENO()), call. = FALSE,
immediate. = TRUE)

Of course, modify as needed.


Regards,
    Iris

On Sat, Jan 18, 2025 at 6:41?PM Ivo Welch <ivo.welch at gmail.com> wrote:
>
> I often find myself hunting where in my program an error has happened,
> (of course, in R, many error messages are mysterious in themselves,
> too, making it even harder.)  the way I do it is mostly with inserting
> `message()` statements.
>
> what I would really like to have is a parser that inserted 'curline
> <<- ##' into the R code, where '##' is the filename and line number.
> something like 'addtracker one.R two.R' and thereafter I can run two.R
> and, when the program dies, use `print curline` to find out where my
> error has roughly occurred.
>
> has someone already written such an 'instrumenter'?
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From |vo@we|ch @end|ng |rom gm@||@com  Sun Jan 19 01:09:02 2025
From: |vo@we|ch @end|ng |rom gm@||@com (Ivo Welch)
Date: Sat, 18 Jan 2025 16:09:02 -0800
Subject: [R] Parser For Line Number Tracing
In-Reply-To: <CADNULg-KLM9ZEA4qNpVaHyL1o9QEg8e0Uiz9SUCL7bQ6P3DsmQ@mail.gmail.com>
References: <CACi4-Jmb=wXfAH-Xmi=0CZrpSDnzaP0scGBvtsFyeE6g5gmz8w@mail.gmail.com>
 <CADNULg-KLM9ZEA4qNpVaHyL1o9QEg8e0Uiz9SUCL7bQ6P3DsmQ@mail.gmail.com>
Message-ID: <CACi4-JkHDKrvcTFPjj8+54rU3hnmiVTWq+VXeYzmQ6mgYzg2Sw@mail.gmail.com>

great.  wonderful.  will check it out, and hopefully widely recommend
it (to my students, too).  Non-descriptive R error messages have had
most of our school abandon R in favor of python.  :-(

On Sat, Jan 18, 2025 at 3:46?PM Iris Simmons <ikwsimmo at gmail.com> wrote:
>
> Hi Ivo,
>
>
> I maintain 'package:this.path' that I believe does what you want. I
> regularly add this to my own code when I need to:
>
> warning(sprintf("remove this later at %s#%d",
> this.path::try.this.path(), this.path::LINENO()), call. = FALSE,
> immediate. = TRUE)
>
> Of course, modify as needed.
>
>
> Regards,
>     Iris
>
> On Sat, Jan 18, 2025 at 6:41?PM Ivo Welch <ivo.welch at gmail.com> wrote:
> >
> > I often find myself hunting where in my program an error has happened,
> > (of course, in R, many error messages are mysterious in themselves,
> > too, making it even harder.)  the way I do it is mostly with inserting
> > `message()` statements.
> >
> > what I would really like to have is a parser that inserted 'curline
> > <<- ##' into the R code, where '##' is the filename and line number.
> > something like 'addtracker one.R two.R' and thereafter I can run two.R
> > and, when the program dies, use `print curline` to find out where my
> > error has roughly occurred.
> >
> > has someone already written such an 'instrumenter'?
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Sun Jan 19 01:27:31 2025
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Sat, 18 Jan 2025 16:27:31 -0800
Subject: [R] Parser For Line Number Tracing
In-Reply-To: <CACi4-Jmb=wXfAH-Xmi=0CZrpSDnzaP0scGBvtsFyeE6g5gmz8w@mail.gmail.com>
References: <CACi4-Jmb=wXfAH-Xmi=0CZrpSDnzaP0scGBvtsFyeE6g5gmz8w@mail.gmail.com>
Message-ID: <F6B323B9-0D62-429D-8D7D-4C30754D22C1@dcn.davis.ca.us>

I recommend making sure your code is built with functions and using the debugger and breakpoints (e.g. [1]) to follow the flow of the code to lead you to where your problem is.

If you are used to building thousand-line top-level scripts then you might not welcome this suggestion, but in that you already have problems you have not admitted to... such things (large top-level scripts) are monsters that will swallow you whole at the slightest change in R, packages, or data.

[1] https://rstudio-education.github.io/hopr/debug.html

On January 18, 2025 3:41:18 PM PST, Ivo Welch <ivo.welch at gmail.com> wrote:
>I often find myself hunting where in my program an error has happened,
>(of course, in R, many error messages are mysterious in themselves,
>too, making it even harder.)  the way I do it is mostly with inserting
>`message()` statements.
>
>what I would really like to have is a parser that inserted 'curline
><<- ##' into the R code, where '##' is the filename and line number.
>something like 'addtracker one.R two.R' and thereafter I can run two.R
>and, when the program dies, use `print curline` to find out where my
>error has roughly occurred.
>
>has someone already written such an 'instrumenter'?
>
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.

-- 
Sent from my phone. Please excuse my brevity.


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Jan 19 02:19:23 2025
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 18 Jan 2025 20:19:23 -0500
Subject: [R] Parser For Line Number Tracing
In-Reply-To: <CACi4-Jmb=wXfAH-Xmi=0CZrpSDnzaP0scGBvtsFyeE6g5gmz8w@mail.gmail.com>
References: <CACi4-Jmb=wXfAH-Xmi=0CZrpSDnzaP0scGBvtsFyeE6g5gmz8w@mail.gmail.com>
Message-ID: <cbba11bf-03cb-44c0-a93a-8cc45d034a9c@gmail.com>

On 2025-01-18 6:41 p.m., Ivo Welch wrote:
> I often find myself hunting where in my program an error has happened,
> (of course, in R, many error messages are mysterious in themselves,
> too, making it even harder.)  the way I do it is mostly with inserting
> `message()` statements.
> 
> what I would really like to have is a parser that inserted 'curline
> <<- ##' into the R code, where '##' is the filename and line number.
> something like 'addtracker one.R two.R' and thereafter I can run two.R
> and, when the program dies, use `print curline` to find out where my
> error has roughly occurred.
> 
> has someone already written such an 'instrumenter'?

The basic R parser already does that.

For example, try putting these lines in test.R:

x <- 1
y <- 2
stop("something bad!")
z <- 4

Then run source("test.R"), and it will die with the uninformative message

Error in eval(ei, envir) : something bad!

But then traceback() will show you the line:

 > traceback()
5: stop("something bad!") at test.R#3
4: eval(ei, envir)
3: eval(ei, envir)
2: withVisible(eval(ei, envir))
1: source("~/temp/test.R")

See the first line of the traceback?  It shows that the problem was on 
line 3 of test.R.

If that line was in a function that had been called from somewhere else, 
both the function line triggering the error and the line that called the 
function would have been shown in different parts of the traceback.

This all depends on calling source() with parameter keep.source = TRUE. 
The default value of that parameter is getOption("keep.source"), so if 
you're not seeing the line numbers, you may have set that option to FALSE.

Duncan Murdoch


From |vo@we|ch @end|ng |rom gm@||@com  Sun Jan 19 02:27:27 2025
From: |vo@we|ch @end|ng |rom gm@||@com (Ivo Welch)
Date: Sat, 18 Jan 2025 17:27:27 -0800
Subject: [R] Parser For Line Number Tracing
In-Reply-To: <cbba11bf-03cb-44c0-a93a-8cc45d034a9c@gmail.com>
References: <CACi4-Jmb=wXfAH-Xmi=0CZrpSDnzaP0scGBvtsFyeE6g5gmz8w@mail.gmail.com>
 <cbba11bf-03cb-44c0-a93a-8cc45d034a9c@gmail.com>
Message-ID: <CACi4-JmVAkAKZeRgC69Sje21Cfv3zC1XFOKsE2m1oJvFMtmaZw@mail.gmail.com>

I am afraid my errors are worse!  (so are my postings.  I should have
given an example.)

```
x <- 1
y <- 2
nofunction("something stupid I am doing!")
z <- 4
```

and

```
> source("where-is-my-water.R")
Error in nofunction("something stupid I am doing!") :
  could not find function "nofunction"
```

and no traceback is available.


