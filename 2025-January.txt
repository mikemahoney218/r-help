From j@p@rk4 @end|ng |rom u|c@edu  Sun Jan  5 17:58:16 2025
From: j@p@rk4 @end|ng |rom u|c@edu (Sparks, John)
Date: Sun, 5 Jan 2025 16:58:16 +0000
Subject: [R] Using library(TTR) Calculate ATR by Symbol
Message-ID: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>

Hi,

In looking at the documentation for the TTR library and particularly the example for calculating the ATR (average true range).  The example shows how to calculate ATR for a file of a single stock.

If I have multiple stocks in one file, isn't there a way to get the ATR for each of them?  Or does one have to break out each stock and calculate the ATR separately using some sort of loop.

In terms of a reproducible example, the file below contains open, high, low, close, etc. for AAPL and then MSFT.

If the ATR calculation were fully working, then there would be blanks for records 41 through 54 and then the ATR calculation would start up again.

Guidance would be very much appreciated.

--John Sparks


Hist<-
structure(list(symbol = c("AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
"AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
"AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
"AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
"AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
"AAPL", "AAPL", "AAPL", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
"MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
"MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
"MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
"MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
"MSFT", "MSFT", "MSFT"), date = structure(c(20033, 20034, 20035,
20038, 20039, 20040, 20041, 20042, 20045, 20046, 20047, 20048,
20049, 20052, 20053, 20054, 20056, 20059, 20060, 20061, 20062,
20063, 20066, 20067, 20068, 20069, 20070, 20073, 20074, 20075,
20076, 20077, 20080, 20081, 20083, 20084, 20087, 20088, 20090,
20091, 20033, 20034, 20035, 20038, 20039, 20040, 20041, 20042,
20045, 20046, 20047, 20048, 20049, 20052, 20053, 20054, 20056,
20059, 20060, 20061, 20062, 20063, 20066, 20067, 20068, 20069,
20070, 20073, 20074, 20075, 20076, 20077, 20080, 20081, 20083,
20084, 20087, 20088, 20090, 20091), class = "Date"), open = c(222.61,
224.63, 227.17, 225, 224.55, 224.01, 225.02, 226.4, 225.25, 226.98,
228.06, 228.88, 228.06, 231.46, 233.33, 234.47, 234.81, 237.27,
239.81, 242.87, 243.99, 242.91, 241.83, 246.89, 247.96, 246.89,
247.82, 247.99, 250.08, 252.16, 247.5, 248.04, 254.77, 255.49,
258.19, 257.83, 252.23, 252.44, 248.93, 243.36, 412.42, 421.28,
425.32, 422.52, 418.25, 421.64, 425, 419.82, 414.87, 413.11,
416.87, 419.5, 411.37, 418.38, 419.59, 425.11, 420.09, 421.57,
429.84, 433.03, 437.92, 442.3, 442.6, 444.39, 444.05, 449.11,
448.44, 447.27, 451.01, 451.32, 441.62, 433.11, 436.74, 434.65,
439.08, 434.6, 426.06, 426.1, 425.53, 421.08), high = c(226.07,
227.88, 228.66, 225.7, 225.59, 226.65, 228.87, 226.92, 229.74,
230.16, 229.93, 230.16, 230.72, 233.25, 235.57, 235.69, 237.81,
240.79, 242.76, 244.11, 244.54, 244.63, 247.24, 248.21, 250.8,
248.74, 249.29, 251.38, 253.83, 254.28, 252, 255, 255.65, 258.21,
260.1, 258.7, 253.5, 253.28, 249.1, 244.18, 420.45, 426.85, 426.5,
424.81, 424.44, 429.33, 428.17, 422.8, 418.4, 417.94, 417.29,
419.78, 417.4, 421.08, 429.04, 427.23, 424.88, 433, 432.47, 439.67,
444.66, 446.1, 448.33, 449.62, 450.35, 456.16, 451.43, 452.18,
455.29, 452.65, 443.18, 443.74, 437.65, 439.6, 440.94, 435.22,
427.55, 426.73, 426.07, 424.03), low = c(221.19, 224.57, 226.41,
221.5, 223.36, 222.76, 225, 224.27, 225.17, 226.66, 225.89, 225.71,
228.06, 229.74, 233.33, 233.81, 233.97, 237.16, 238.9, 241.25,
242.13, 242.08, 241.75, 245.34, 246.26, 245.68, 246.24, 247.65,
249.78, 247.74, 247.09, 245.69, 253.45, 255.29, 257.63, 253.06,
250.75, 249.43, 241.82, 241.89, 410.52, 419.88, 421.78, 416,
417.2, 418.21, 420, 413.64, 412.1, 411.55, 410.58, 410.29, 411.06,
414.85, 418.85, 422.02, 417.8, 421.31, 427.74, 432.63, 436.17,
441.77, 440.5, 441.6, 444.05, 449.11, 445.58, 445.28, 449.57,
437.02, 436.32, 428.63, 432.83, 434.19, 436.63, 426.35, 421.9,
420.66, 414.85, 419.54), close = c(222.72, 227.48, 226.96, 224.23,
224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
250.42, 243.85, 243.36, 420.18, 425.43, 422.54, 418.01, 423.03,
425.2, 426.89, 415, 415.76, 417.79, 415.49, 412.87, 417, 418.79,
427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62, 443.57,
446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46, 437.39,
437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83, 421.5,
418.58, 423.35), adjClose = c(222.48, 227.23, 226.96, 224.23,
224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
250.42, 243.85, 243.36, 419.34, 424.58, 421.7, 417.17, 422.18,
424.35, 426.04, 414.17, 414.93, 416.96, 414.66, 412.87, 417,
418.79, 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62,
443.57, 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46,
437.39, 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83,
421.5, 418.58, 423.35)), class = "data.frame", row.names = c(NA,
-80L))

library(TTR)
atr <- ATR(Hist[,c("high","low","close")], n=14)
atr






	[[alternative HTML version deleted]]


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Sun Jan  5 18:31:16 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 5 Jan 2025 11:31:16 -0600
Subject: [R] Using library(TTR) Calculate ATR by Symbol
In-Reply-To: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
References: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
Message-ID: <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>

Hi,

TTR/xts/quantmod maintainer here.

On Sun, Jan 5, 2025 at 10:58?AM Sparks, John <jspark4 at uic.edu> wrote:
>
> Hi,
>
> In looking at the documentation for the TTR library and particularly the
> example for calculating the ATR (average true range).  The example shows
> how to calculate ATR for a file of a single stock.
>
> If I have multiple stocks in one file, isn't there a way to get the ATR
> for each of them?  Or does one have to break out each stock and calculate
> the ATR separately using some sort of loop.
>
Yes, the TTR functions only work on a single stock at a time.

> In terms of a reproducible example, the file below contains open, high,
> low, close, etc. for AAPL and then MSFT.
>
Thanks for the reproducible data!

> If the ATR calculation were fully working, then there would be blanks for
> records 41 through 54 and then the ATR calculation would start up again.
>
> Guidance would be very much appreciated.
>
> --John Sparks
>
>
> Hist<-
> structure(list(symbol = c("AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT"), date = structure(c(20033, 20034, 20035,
> 20038, 20039, 20040, 20041, 20042, 20045, 20046, 20047, 20048,
> 20049, 20052, 20053, 20054, 20056, 20059, 20060, 20061, 20062,
> 20063, 20066, 20067, 20068, 20069, 20070, 20073, 20074, 20075,
> 20076, 20077, 20080, 20081, 20083, 20084, 20087, 20088, 20090,
> 20091, 20033, 20034, 20035, 20038, 20039, 20040, 20041, 20042,
> 20045, 20046, 20047, 20048, 20049, 20052, 20053, 20054, 20056,
> 20059, 20060, 20061, 20062, 20063, 20066, 20067, 20068, 20069,
> 20070, 20073, 20074, 20075, 20076, 20077, 20080, 20081, 20083,
> 20084, 20087, 20088, 20090, 20091), class = "Date"), open = c(222.61,
> 224.63, 227.17, 225, 224.55, 224.01, 225.02, 226.4, 225.25, 226.98,
> 228.06, 228.88, 228.06, 231.46, 233.33, 234.47, 234.81, 237.27,
> 239.81, 242.87, 243.99, 242.91, 241.83, 246.89, 247.96, 246.89,
> 247.82, 247.99, 250.08, 252.16, 247.5, 248.04, 254.77, 255.49,
> 258.19, 257.83, 252.23, 252.44, 248.93, 243.36, 412.42, 421.28,
> 425.32, 422.52, 418.25, 421.64, 425, 419.82, 414.87, 413.11,
> 416.87, 419.5, 411.37, 418.38, 419.59, 425.11, 420.09, 421.57,
> 429.84, 433.03, 437.92, 442.3, 442.6, 444.39, 444.05, 449.11,
> 448.44, 447.27, 451.01, 451.32, 441.62, 433.11, 436.74, 434.65,
> 439.08, 434.6, 426.06, 426.1, 425.53, 421.08), high = c(226.07,
> 227.88, 228.66, 225.7, 225.59, 226.65, 228.87, 226.92, 229.74,
> 230.16, 229.93, 230.16, 230.72, 233.25, 235.57, 235.69, 237.81,
> 240.79, 242.76, 244.11, 244.54, 244.63, 247.24, 248.21, 250.8,
> 248.74, 249.29, 251.38, 253.83, 254.28, 252, 255, 255.65, 258.21,
> 260.1, 258.7, 253.5, 253.28, 249.1, 244.18, 420.45, 426.85, 426.5,
> 424.81, 424.44, 429.33, 428.17, 422.8, 418.4, 417.94, 417.29,
> 419.78, 417.4, 421.08, 429.04, 427.23, 424.88, 433, 432.47, 439.67,
> 444.66, 446.1, 448.33, 449.62, 450.35, 456.16, 451.43, 452.18,
> 455.29, 452.65, 443.18, 443.74, 437.65, 439.6, 440.94, 435.22,
> 427.55, 426.73, 426.07, 424.03), low = c(221.19, 224.57, 226.41,
> 221.5, 223.36, 222.76, 225, 224.27, 225.17, 226.66, 225.89, 225.71,
> 228.06, 229.74, 233.33, 233.81, 233.97, 237.16, 238.9, 241.25,
> 242.13, 242.08, 241.75, 245.34, 246.26, 245.68, 246.24, 247.65,
> 249.78, 247.74, 247.09, 245.69, 253.45, 255.29, 257.63, 253.06,
> 250.75, 249.43, 241.82, 241.89, 410.52, 419.88, 421.78, 416,
> 417.2, 418.21, 420, 413.64, 412.1, 411.55, 410.58, 410.29, 411.06,
> 414.85, 418.85, 422.02, 417.8, 421.31, 427.74, 432.63, 436.17,
> 441.77, 440.5, 441.6, 444.05, 449.11, 445.58, 445.28, 449.57,
> 437.02, 436.32, 428.63, 432.83, 434.19, 436.63, 426.35, 421.9,
> 420.66, 414.85, 419.54), close = c(222.72, 227.48, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 420.18, 425.43, 422.54, 418.01, 423.03,
> 425.2, 426.89, 415, 415.76, 417.79, 415.49, 412.87, 417, 418.79,
> 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62, 443.57,
> 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46, 437.39,
> 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83, 421.5,
> 418.58, 423.35), adjClose = c(222.48, 227.23, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 419.34, 424.58, 421.7, 417.17, 422.18,
> 424.35, 426.04, 414.17, 414.93, 416.96, 414.66, 412.87, 417,
> 418.79, 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62,
> 443.57, 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46,
> 437.39, 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83,
> 421.5, 418.58, 423.35)), class = "data.frame", row.names = c(NA,
> -80L))
>
> library(TTR)
> atr <- ATR(Hist[,c("high","low","close")], n=14)
> atr
>
>
Here's a function that splits your data into a list by symbol, then
does the TTR calculation for each symbol and re-combines the result
into an object with the same structure as the input.

  library(quantmod)
  my_atr <- function(ohlc, n = 14, ...)
  {
      cn <- names(ohlc)
      # get all the necessary columns
      atr_cols <- c(which(grepl("date", cn, ignore.case = TRUE)),
                    has.HLC(ohlc, which = TRUE))
      # find the symbol column
      sym_col <- which(grepl("symbol", cn, ignore.case = TRUE))

      # convert the input data.frame into a list of xts objects
      # this ensures the data are correctly ordered by date
      xts_list <- lapply(split(ohlc[, atr_cols], ohlc[, sym_col]), as.xts)
      # calculate ATR for each symbol
      atr_list <- lapply(xts_list, ATR, n = n, ...)

      # convert the list results into data.frames
      to_df <- function(nm) {
          i <- atr_list[[nm]];
          data.frame(symbol = nm, date = index(i), coredata(i))
      }
      atr_df <- lapply(names(atr_list), to_df)

      # rbind all the list elements into a single data frame
      do.call(rbind, atr_df)
  }

Hope that helps.

-- 
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  www.fosstrading.com


From j@p@rk4 @end|ng |rom u|c@edu  Sun Jan  5 18:49:23 2025
From: j@p@rk4 @end|ng |rom u|c@edu (Sparks, John)
Date: Sun, 5 Jan 2025 17:49:23 +0000
Subject: [R] Using library(TTR) Calculate ATR by Symbol
In-Reply-To: <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>
References: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>
Message-ID: <BY5PR13MB363695BC10D86ED57E323AEEFA172@BY5PR13MB3636.namprd13.prod.outlook.com>

Thanks!  Appears helpful and the quick turnaround is very much appreciated.  I'll do some testing now.

--JJS
________________________________
From: Joshua Ulrich <josh.m.ulrich at gmail.com>
Sent: Sunday, January 5, 2025 11:31 AM
To: Sparks, John <jspark4 at uic.edu>
Cc: R-help at r-project.org <R-help at r-project.org>
Subject: Re: Using library(TTR) Calculate ATR by Symbol

CAUTION: External Sender

Hi,

TTR/xts/quantmod maintainer here.

On Sun, Jan 5, 2025 at 10:58?AM Sparks, John <jspark4 at uic.edu> wrote:
>
> Hi,
>
> In looking at the documentation for the TTR library and particularly the
> example for calculating the ATR (average true range).  The example shows
> how to calculate ATR for a file of a single stock.
>
> If I have multiple stocks in one file, isn't there a way to get the ATR
> for each of them?  Or does one have to break out each stock and calculate
> the ATR separately using some sort of loop.
>
Yes, the TTR functions only work on a single stock at a time.

> In terms of a reproducible example, the file below contains open, high,
> low, close, etc. for AAPL and then MSFT.
>
Thanks for the reproducible data!

> If the ATR calculation were fully working, then there would be blanks for
> records 41 through 54 and then the ATR calculation would start up again.
>
> Guidance would be very much appreciated.
>
> --John Sparks
>
>
> Hist<-
> structure(list(symbol = c("AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT"), date = structure(c(20033, 20034, 20035,
> 20038, 20039, 20040, 20041, 20042, 20045, 20046, 20047, 20048,
> 20049, 20052, 20053, 20054, 20056, 20059, 20060, 20061, 20062,
> 20063, 20066, 20067, 20068, 20069, 20070, 20073, 20074, 20075,
> 20076, 20077, 20080, 20081, 20083, 20084, 20087, 20088, 20090,
> 20091, 20033, 20034, 20035, 20038, 20039, 20040, 20041, 20042,
> 20045, 20046, 20047, 20048, 20049, 20052, 20053, 20054, 20056,
> 20059, 20060, 20061, 20062, 20063, 20066, 20067, 20068, 20069,
> 20070, 20073, 20074, 20075, 20076, 20077, 20080, 20081, 20083,
> 20084, 20087, 20088, 20090, 20091), class = "Date"), open = c(222.61,
> 224.63, 227.17, 225, 224.55, 224.01, 225.02, 226.4, 225.25, 226.98,
> 228.06, 228.88, 228.06, 231.46, 233.33, 234.47, 234.81, 237.27,
> 239.81, 242.87, 243.99, 242.91, 241.83, 246.89, 247.96, 246.89,
> 247.82, 247.99, 250.08, 252.16, 247.5, 248.04, 254.77, 255.49,
> 258.19, 257.83, 252.23, 252.44, 248.93, 243.36, 412.42, 421.28,
> 425.32, 422.52, 418.25, 421.64, 425, 419.82, 414.87, 413.11,
> 416.87, 419.5, 411.37, 418.38, 419.59, 425.11, 420.09, 421.57,
> 429.84, 433.03, 437.92, 442.3, 442.6, 444.39, 444.05, 449.11,
> 448.44, 447.27, 451.01, 451.32, 441.62, 433.11, 436.74, 434.65,
> 439.08, 434.6, 426.06, 426.1, 425.53, 421.08), high = c(226.07,
> 227.88, 228.66, 225.7, 225.59, 226.65, 228.87, 226.92, 229.74,
> 230.16, 229.93, 230.16, 230.72, 233.25, 235.57, 235.69, 237.81,
> 240.79, 242.76, 244.11, 244.54, 244.63, 247.24, 248.21, 250.8,
> 248.74, 249.29, 251.38, 253.83, 254.28, 252, 255, 255.65, 258.21,
> 260.1, 258.7, 253.5, 253.28, 249.1, 244.18, 420.45, 426.85, 426.5,
> 424.81, 424.44, 429.33, 428.17, 422.8, 418.4, 417.94, 417.29,
> 419.78, 417.4, 421.08, 429.04, 427.23, 424.88, 433, 432.47, 439.67,
> 444.66, 446.1, 448.33, 449.62, 450.35, 456.16, 451.43, 452.18,
> 455.29, 452.65, 443.18, 443.74, 437.65, 439.6, 440.94, 435.22,
> 427.55, 426.73, 426.07, 424.03), low = c(221.19, 224.57, 226.41,
> 221.5, 223.36, 222.76, 225, 224.27, 225.17, 226.66, 225.89, 225.71,
> 228.06, 229.74, 233.33, 233.81, 233.97, 237.16, 238.9, 241.25,
> 242.13, 242.08, 241.75, 245.34, 246.26, 245.68, 246.24, 247.65,
> 249.78, 247.74, 247.09, 245.69, 253.45, 255.29, 257.63, 253.06,
> 250.75, 249.43, 241.82, 241.89, 410.52, 419.88, 421.78, 416,
> 417.2, 418.21, 420, 413.64, 412.1, 411.55, 410.58, 410.29, 411.06,
> 414.85, 418.85, 422.02, 417.8, 421.31, 427.74, 432.63, 436.17,
> 441.77, 440.5, 441.6, 444.05, 449.11, 445.58, 445.28, 449.57,
> 437.02, 436.32, 428.63, 432.83, 434.19, 436.63, 426.35, 421.9,
> 420.66, 414.85, 419.54), close = c(222.72, 227.48, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 420.18, 425.43, 422.54, 418.01, 423.03,
> 425.2, 426.89, 415, 415.76, 417.79, 415.49, 412.87, 417, 418.79,
> 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62, 443.57,
> 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46, 437.39,
> 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83, 421.5,
> 418.58, 423.35), adjClose = c(222.48, 227.23, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 419.34, 424.58, 421.7, 417.17, 422.18,
> 424.35, 426.04, 414.17, 414.93, 416.96, 414.66, 412.87, 417,
> 418.79, 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62,
> 443.57, 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46,
> 437.39, 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83,
> 421.5, 418.58, 423.35)), class = "data.frame", row.names = c(NA,
> -80L))
>
> library(TTR)
> atr <- ATR(Hist[,c("high","low","close")], n=14)
> atr
>
>
Here's a function that splits your data into a list by symbol, then
does the TTR calculation for each symbol and re-combines the result
into an object with the same structure as the input.

  library(quantmod)
  my_atr <- function(ohlc, n = 14, ...)
  {
      cn <- names(ohlc)
      # get all the necessary columns
      atr_cols <- c(which(grepl("date", cn, ignore.case = TRUE)),
                    has.HLC(ohlc, which = TRUE))
      # find the symbol column
      sym_col <- which(grepl("symbol", cn, ignore.case = TRUE))

      # convert the input data.frame into a list of xts objects
      # this ensures the data are correctly ordered by date
      xts_list <- lapply(split(ohlc[, atr_cols], ohlc[, sym_col]), as.xts)
      # calculate ATR for each symbol
      atr_list <- lapply(xts_list, ATR, n = n, ...)

      # convert the list results into data.frames
      to_df <- function(nm) {
          i <- atr_list[[nm]];
          data.frame(symbol = nm, date = index(i), coredata(i))
      }
      atr_df <- lapply(names(atr_list), to_df)

      # rbind all the list elements into a single data frame
      do.call(rbind, atr_df)
  }

Hope that helps.

--
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  https://nam04.safelinks.protection.outlook.com/?url=http%3A%2F%2Fwww.fosstrading.com%2F&data=05%7C02%7Cjspark4%40uic.edu%7C2aac1a65ee7c4120930d08dd2daecd07%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638716950981045350%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=zXHcmYaGJN7iyOUvxLhRWr8E%2BjrDyG5ze3LB0uf4n%2BI%3D&reserved=0<http://www.fosstrading.com/>

This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.

	[[alternative HTML version deleted]]


From j@p@rk4 @end|ng |rom u|c@edu  Sun Jan  5 18:58:26 2025
From: j@p@rk4 @end|ng |rom u|c@edu (Sparks, John)
Date: Sun, 5 Jan 2025 17:58:26 +0000
Subject: [R] Using library(TTR) Calculate ATR by Symbol
In-Reply-To: <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>
References: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>
Message-ID: <BY5PR13MB36363E6763A62060DDDEEBD7FA172@BY5PR13MB3636.namprd13.prod.outlook.com>

I don't see atr_df appearing in my current directory.

Also, I assume that the input data frame is named ohlc?  Or am I missing something.

Thanks,
--JJS

________________________________
From: Joshua Ulrich <josh.m.ulrich at gmail.com>
Sent: Sunday, January 5, 2025 11:31 AM
To: Sparks, John <jspark4 at uic.edu>
Cc: R-help at r-project.org <R-help at r-project.org>
Subject: Re: Using library(TTR) Calculate ATR by Symbol

CAUTION: External Sender

Hi,

TTR/xts/quantmod maintainer here.

On Sun, Jan 5, 2025 at 10:58?AM Sparks, John <jspark4 at uic.edu> wrote:
>
> Hi,
>
> In looking at the documentation for the TTR library and particularly the
> example for calculating the ATR (average true range).  The example shows
> how to calculate ATR for a file of a single stock.
>
> If I have multiple stocks in one file, isn't there a way to get the ATR
> for each of them?  Or does one have to break out each stock and calculate
> the ATR separately using some sort of loop.
>
Yes, the TTR functions only work on a single stock at a time.

> In terms of a reproducible example, the file below contains open, high,
> low, close, etc. for AAPL and then MSFT.
>
Thanks for the reproducible data!

> If the ATR calculation were fully working, then there would be blanks for
> records 41 through 54 and then the ATR calculation would start up again.
>
> Guidance would be very much appreciated.
>
> --John Sparks
>
>
> Hist<-
> structure(list(symbol = c("AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> "AAPL", "AAPL", "AAPL", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> "MSFT", "MSFT", "MSFT"), date = structure(c(20033, 20034, 20035,
> 20038, 20039, 20040, 20041, 20042, 20045, 20046, 20047, 20048,
> 20049, 20052, 20053, 20054, 20056, 20059, 20060, 20061, 20062,
> 20063, 20066, 20067, 20068, 20069, 20070, 20073, 20074, 20075,
> 20076, 20077, 20080, 20081, 20083, 20084, 20087, 20088, 20090,
> 20091, 20033, 20034, 20035, 20038, 20039, 20040, 20041, 20042,
> 20045, 20046, 20047, 20048, 20049, 20052, 20053, 20054, 20056,
> 20059, 20060, 20061, 20062, 20063, 20066, 20067, 20068, 20069,
> 20070, 20073, 20074, 20075, 20076, 20077, 20080, 20081, 20083,
> 20084, 20087, 20088, 20090, 20091), class = "Date"), open = c(222.61,
> 224.63, 227.17, 225, 224.55, 224.01, 225.02, 226.4, 225.25, 226.98,
> 228.06, 228.88, 228.06, 231.46, 233.33, 234.47, 234.81, 237.27,
> 239.81, 242.87, 243.99, 242.91, 241.83, 246.89, 247.96, 246.89,
> 247.82, 247.99, 250.08, 252.16, 247.5, 248.04, 254.77, 255.49,
> 258.19, 257.83, 252.23, 252.44, 248.93, 243.36, 412.42, 421.28,
> 425.32, 422.52, 418.25, 421.64, 425, 419.82, 414.87, 413.11,
> 416.87, 419.5, 411.37, 418.38, 419.59, 425.11, 420.09, 421.57,
> 429.84, 433.03, 437.92, 442.3, 442.6, 444.39, 444.05, 449.11,
> 448.44, 447.27, 451.01, 451.32, 441.62, 433.11, 436.74, 434.65,
> 439.08, 434.6, 426.06, 426.1, 425.53, 421.08), high = c(226.07,
> 227.88, 228.66, 225.7, 225.59, 226.65, 228.87, 226.92, 229.74,
> 230.16, 229.93, 230.16, 230.72, 233.25, 235.57, 235.69, 237.81,
> 240.79, 242.76, 244.11, 244.54, 244.63, 247.24, 248.21, 250.8,
> 248.74, 249.29, 251.38, 253.83, 254.28, 252, 255, 255.65, 258.21,
> 260.1, 258.7, 253.5, 253.28, 249.1, 244.18, 420.45, 426.85, 426.5,
> 424.81, 424.44, 429.33, 428.17, 422.8, 418.4, 417.94, 417.29,
> 419.78, 417.4, 421.08, 429.04, 427.23, 424.88, 433, 432.47, 439.67,
> 444.66, 446.1, 448.33, 449.62, 450.35, 456.16, 451.43, 452.18,
> 455.29, 452.65, 443.18, 443.74, 437.65, 439.6, 440.94, 435.22,
> 427.55, 426.73, 426.07, 424.03), low = c(221.19, 224.57, 226.41,
> 221.5, 223.36, 222.76, 225, 224.27, 225.17, 226.66, 225.89, 225.71,
> 228.06, 229.74, 233.33, 233.81, 233.97, 237.16, 238.9, 241.25,
> 242.13, 242.08, 241.75, 245.34, 246.26, 245.68, 246.24, 247.65,
> 249.78, 247.74, 247.09, 245.69, 253.45, 255.29, 257.63, 253.06,
> 250.75, 249.43, 241.82, 241.89, 410.52, 419.88, 421.78, 416,
> 417.2, 418.21, 420, 413.64, 412.1, 411.55, 410.58, 410.29, 411.06,
> 414.85, 418.85, 422.02, 417.8, 421.31, 427.74, 432.63, 436.17,
> 441.77, 440.5, 441.6, 444.05, 449.11, 445.58, 445.28, 449.57,
> 437.02, 436.32, 428.63, 432.83, 434.19, 436.63, 426.35, 421.9,
> 420.66, 414.85, 419.54), close = c(222.72, 227.48, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 420.18, 425.43, 422.54, 418.01, 423.03,
> 425.2, 426.89, 415, 415.76, 417.79, 415.49, 412.87, 417, 418.79,
> 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62, 443.57,
> 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46, 437.39,
> 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83, 421.5,
> 418.58, 423.35), adjClose = c(222.48, 227.23, 226.96, 224.23,
> 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> 250.42, 243.85, 243.36, 419.34, 424.58, 421.7, 417.17, 422.18,
> 424.35, 426.04, 414.17, 414.93, 416.96, 414.66, 412.87, 417,
> 418.79, 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62,
> 443.57, 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46,
> 437.39, 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83,
> 421.5, 418.58, 423.35)), class = "data.frame", row.names = c(NA,
> -80L))
>
> library(TTR)
> atr <- ATR(Hist[,c("high","low","close")], n=14)
> atr
>
>
Here's a function that splits your data into a list by symbol, then
does the TTR calculation for each symbol and re-combines the result
into an object with the same structure as the input.

  library(quantmod)
  my_atr <- function(ohlc, n = 14, ...)
  {
      cn <- names(ohlc)
      # get all the necessary columns
      atr_cols <- c(which(grepl("date", cn, ignore.case = TRUE)),
                    has.HLC(ohlc, which = TRUE))
      # find the symbol column
      sym_col <- which(grepl("symbol", cn, ignore.case = TRUE))

      # convert the input data.frame into a list of xts objects
      # this ensures the data are correctly ordered by date
      xts_list <- lapply(split(ohlc[, atr_cols], ohlc[, sym_col]), as.xts)
      # calculate ATR for each symbol
      atr_list <- lapply(xts_list, ATR, n = n, ...)

      # convert the list results into data.frames
      to_df <- function(nm) {
          i <- atr_list[[nm]];
          data.frame(symbol = nm, date = index(i), coredata(i))
      }
      atr_df <- lapply(names(atr_list), to_df)

      # rbind all the list elements into a single data frame
      do.call(rbind, atr_df)
  }

Hope that helps.

--
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  https://nam04.safelinks.protection.outlook.com/?url=http%3A%2F%2Fwww.fosstrading.com%2F&data=05%7C02%7Cjspark4%40uic.edu%7C2aac1a65ee7c4120930d08dd2daecd07%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638716950981045350%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=zXHcmYaGJN7iyOUvxLhRWr8E%2BjrDyG5ze3LB0uf4n%2BI%3D&reserved=0<http://www.fosstrading.com/>

This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Sun Jan  5 18:59:22 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Sun, 5 Jan 2025 09:59:22 -0800
Subject: [R] Extracting specific arguments from "..."
Message-ID: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>

Consider:

f1 <- function(...){
  one <- list(...)[['a']]
  two <- ...elt(match('a', ...names()))
  c(one, two)
}
## Here "..." is an argument list with "a" somewhere in it, but in an
unknown position.

> f1(b=5, a = 2, c=7)
[1] 2 2

Which is better for extracting a specific named argument, one<- or
two<- ?  Or a third alternative that is better than both?
Comments and critiques welcome.

Cheers,
Bert


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Sun Jan  5 19:09:51 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 5 Jan 2025 12:09:51 -0600
Subject: [R] Using library(TTR) Calculate ATR by Symbol
In-Reply-To: <BY5PR13MB36363E6763A62060DDDEEBD7FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
References: <BY5PR13MB3636FDCC0F83BD0746625B41FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gSKE6V-Oq30sGQ2bLiGGHCBDhntk6MKHPnb39pP2DKd_w@mail.gmail.com>
 <BY5PR13MB36363E6763A62060DDDEEBD7FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
Message-ID: <CAPPM_gTD4hHsYtPzjFO2rUqhp7Xp7kEfnECM3PiQYWNNYhDqFQ@mail.gmail.com>

On Sun, Jan 5, 2025 at 11:58?AM Sparks, John <jspark4 at uic.edu> wrote:
>
> I don't see atr_df appearing in my current directory.
>
> Also, I assume that the input data frame is named ohlc?  Or am I missing something.
>
You need to call the function with your data and assign it to an object.

For example:
    atr <- my_atr(Hist)

> Thanks,
> --JJS
>
> ________________________________
> From: Joshua Ulrich <josh.m.ulrich at gmail.com>
> Sent: Sunday, January 5, 2025 11:31 AM
> To: Sparks, John <jspark4 at uic.edu>
> Cc: R-help at r-project.org <R-help at r-project.org>
> Subject: Re: Using library(TTR) Calculate ATR by Symbol
>
> CAUTION: External Sender
>
> Hi,
>
> TTR/xts/quantmod maintainer here.
>
> On Sun, Jan 5, 2025 at 10:58?AM Sparks, John <jspark4 at uic.edu> wrote:
> >
> > Hi,
> >
> > In looking at the documentation for the TTR library and particularly the
> > example for calculating the ATR (average true range).  The example shows
> > how to calculate ATR for a file of a single stock.
> >
> > If I have multiple stocks in one file, isn't there a way to get the ATR
> > for each of them?  Or does one have to break out each stock and calculate
> > the ATR separately using some sort of loop.
> >
> Yes, the TTR functions only work on a single stock at a time.
>
> > In terms of a reproducible example, the file below contains open, high,
> > low, close, etc. for AAPL and then MSFT.
> >
> Thanks for the reproducible data!
>
> > If the ATR calculation were fully working, then there would be blanks for
> > records 41 through 54 and then the ATR calculation would start up again.
> >
> > Guidance would be very much appreciated.
> >
> > --John Sparks
> >
> >
> > Hist<-
> > structure(list(symbol = c("AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> > "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> > "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> > "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> > "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL", "AAPL",
> > "AAPL", "AAPL", "AAPL", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> > "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> > "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> > "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> > "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT", "MSFT",
> > "MSFT", "MSFT", "MSFT"), date = structure(c(20033, 20034, 20035,
> > 20038, 20039, 20040, 20041, 20042, 20045, 20046, 20047, 20048,
> > 20049, 20052, 20053, 20054, 20056, 20059, 20060, 20061, 20062,
> > 20063, 20066, 20067, 20068, 20069, 20070, 20073, 20074, 20075,
> > 20076, 20077, 20080, 20081, 20083, 20084, 20087, 20088, 20090,
> > 20091, 20033, 20034, 20035, 20038, 20039, 20040, 20041, 20042,
> > 20045, 20046, 20047, 20048, 20049, 20052, 20053, 20054, 20056,
> > 20059, 20060, 20061, 20062, 20063, 20066, 20067, 20068, 20069,
> > 20070, 20073, 20074, 20075, 20076, 20077, 20080, 20081, 20083,
> > 20084, 20087, 20088, 20090, 20091), class = "Date"), open = c(222.61,
> > 224.63, 227.17, 225, 224.55, 224.01, 225.02, 226.4, 225.25, 226.98,
> > 228.06, 228.88, 228.06, 231.46, 233.33, 234.47, 234.81, 237.27,
> > 239.81, 242.87, 243.99, 242.91, 241.83, 246.89, 247.96, 246.89,
> > 247.82, 247.99, 250.08, 252.16, 247.5, 248.04, 254.77, 255.49,
> > 258.19, 257.83, 252.23, 252.44, 248.93, 243.36, 412.42, 421.28,
> > 425.32, 422.52, 418.25, 421.64, 425, 419.82, 414.87, 413.11,
> > 416.87, 419.5, 411.37, 418.38, 419.59, 425.11, 420.09, 421.57,
> > 429.84, 433.03, 437.92, 442.3, 442.6, 444.39, 444.05, 449.11,
> > 448.44, 447.27, 451.01, 451.32, 441.62, 433.11, 436.74, 434.65,
> > 439.08, 434.6, 426.06, 426.1, 425.53, 421.08), high = c(226.07,
> > 227.88, 228.66, 225.7, 225.59, 226.65, 228.87, 226.92, 229.74,
> > 230.16, 229.93, 230.16, 230.72, 233.25, 235.57, 235.69, 237.81,
> > 240.79, 242.76, 244.11, 244.54, 244.63, 247.24, 248.21, 250.8,
> > 248.74, 249.29, 251.38, 253.83, 254.28, 252, 255, 255.65, 258.21,
> > 260.1, 258.7, 253.5, 253.28, 249.1, 244.18, 420.45, 426.85, 426.5,
> > 424.81, 424.44, 429.33, 428.17, 422.8, 418.4, 417.94, 417.29,
> > 419.78, 417.4, 421.08, 429.04, 427.23, 424.88, 433, 432.47, 439.67,
> > 444.66, 446.1, 448.33, 449.62, 450.35, 456.16, 451.43, 452.18,
> > 455.29, 452.65, 443.18, 443.74, 437.65, 439.6, 440.94, 435.22,
> > 427.55, 426.73, 426.07, 424.03), low = c(221.19, 224.57, 226.41,
> > 221.5, 223.36, 222.76, 225, 224.27, 225.17, 226.66, 225.89, 225.71,
> > 228.06, 229.74, 233.33, 233.81, 233.97, 237.16, 238.9, 241.25,
> > 242.13, 242.08, 241.75, 245.34, 246.26, 245.68, 246.24, 247.65,
> > 249.78, 247.74, 247.09, 245.69, 253.45, 255.29, 257.63, 253.06,
> > 250.75, 249.43, 241.82, 241.89, 410.52, 419.88, 421.78, 416,
> > 417.2, 418.21, 420, 413.64, 412.1, 411.55, 410.58, 410.29, 411.06,
> > 414.85, 418.85, 422.02, 417.8, 421.31, 427.74, 432.63, 436.17,
> > 441.77, 440.5, 441.6, 444.05, 449.11, 445.58, 445.28, 449.57,
> > 437.02, 436.32, 428.63, 432.83, 434.19, 436.63, 426.35, 421.9,
> > 420.66, 414.85, 419.54), close = c(222.72, 227.48, 226.96, 224.23,
> > 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> > 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> > 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> > 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> > 250.42, 243.85, 243.36, 420.18, 425.43, 422.54, 418.01, 423.03,
> > 425.2, 426.89, 415, 415.76, 417.79, 415.49, 412.87, 417, 418.79,
> > 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62, 443.57,
> > 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46, 437.39,
> > 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83, 421.5,
> > 418.58, 423.35), adjClose = c(222.48, 227.23, 226.96, 224.23,
> > 224.23, 225.12, 228.22, 225, 228.02, 228.28, 229, 228.52, 229.87,
> > 232.87, 235.06, 234.93, 237.33, 239.59, 242.65, 243.01, 243.04,
> > 242.84, 246.75, 247.77, 246.49, 247.96, 248.13, 251.04, 253.48,
> > 248.05, 249.79, 254.49, 255.27, 258.2, 259.02, 255.59, 252.2,
> > 250.42, 243.85, 243.36, 419.34, 424.58, 421.7, 417.17, 422.18,
> > 424.35, 426.04, 414.17, 414.93, 416.96, 414.66, 412.87, 417,
> > 418.79, 427.99, 422.99, 423.46, 430.98, 431.2, 437.42, 442.62,
> > 443.57, 446.02, 443.33, 448.99, 449.56, 447.27, 451.59, 454.46,
> > 437.39, 437.03, 436.6, 435.25, 439.33, 438.11, 430.53, 424.83,
> > 421.5, 418.58, 423.35)), class = "data.frame", row.names = c(NA,
> > -80L))
> >
> > library(TTR)
> > atr <- ATR(Hist[,c("high","low","close")], n=14)
> > atr
> >
> >
> Here's a function that splits your data into a list by symbol, then
> does the TTR calculation for each symbol and re-combines the result
> into an object with the same structure as the input.
>
>   library(quantmod)
>   my_atr <- function(ohlc, n = 14, ...)
>   {
>       cn <- names(ohlc)
>       # get all the necessary columns
>       atr_cols <- c(which(grepl("date", cn, ignore.case = TRUE)),
>                     has.HLC(ohlc, which = TRUE))
>       # find the symbol column
>       sym_col <- which(grepl("symbol", cn, ignore.case = TRUE))
>
>       # convert the input data.frame into a list of xts objects
>       # this ensures the data are correctly ordered by date
>       xts_list <- lapply(split(ohlc[, atr_cols], ohlc[, sym_col]), as.xts)
>       # calculate ATR for each symbol
>       atr_list <- lapply(xts_list, ATR, n = n, ...)
>
>       # convert the list results into data.frames
>       to_df <- function(nm) {
>           i <- atr_list[[nm]];
>           data.frame(symbol = nm, date = index(i), coredata(i))
>       }
>       atr_df <- lapply(names(atr_list), to_df)
>
>       # rbind all the list elements into a single data frame
>       do.call(rbind, atr_df)
>   }
>
> Hope that helps.
>
> --
> Joshua Ulrich  |  about.me/joshuaulrich
>
> This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.


From |kw@|mmo @end|ng |rom gm@||@com  Sun Jan  5 19:15:55 2025
From: |kw@|mmo @end|ng |rom gm@||@com (Iris Simmons)
Date: Sun, 5 Jan 2025 13:15:55 -0500
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
Message-ID: <CADNULg9QiL2c-ROdQXY94R0JbxEx-kf9PyYRndSiy4tvzgXzMQ@mail.gmail.com>

I would use two because it does not force the evaluation of the other
arguments in the ... list.



On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:

> Consider:
>
> f1 <- function(...){
>   one <- list(...)[['a']]
>   two <- ...elt(match('a', ...names()))
>   c(one, two)
> }
> ## Here "..." is an argument list with "a" somewhere in it, but in an
> unknown position.
>
> > f1(b=5, a = 2, c=7)
> [1] 2 2
>
> Which is better for extracting a specific named argument, one<- or
> two<- ?  Or a third alternative that is better than both?
> Comments and critiques welcome.
>
> Cheers,
> Bert
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Sun Jan  5 20:17:02 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Sun, 5 Jan 2025 11:17:02 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CADNULg9QiL2c-ROdQXY94R0JbxEx-kf9PyYRndSiy4tvzgXzMQ@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
 <CADNULg9QiL2c-ROdQXY94R0JbxEx-kf9PyYRndSiy4tvzgXzMQ@mail.gmail.com>
Message-ID: <CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q@mail.gmail.com>

Thanks, Iris.
That is what I suspected, but it wasn't clear to me from the docs.

Best,
Bert

On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
>
> I would use two because it does not force the evaluation of the other arguments in the ... list.
>
>
>
> On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
>>
>> Consider:
>>
>> f1 <- function(...){
>>   one <- list(...)[['a']]
>>   two <- ...elt(match('a', ...names()))
>>   c(one, two)
>> }
>> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> unknown position.
>>
>> > f1(b=5, a = 2, c=7)
>> [1] 2 2
>>
>> Which is better for extracting a specific named argument, one<- or
>> two<- ?  Or a third alternative that is better than both?
>> Comments and critiques welcome.
>>
>> Cheers,
>> Bert
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.


From j@p@rk4 @end|ng |rom u|c@edu  Sun Jan  5 21:03:11 2025
From: j@p@rk4 @end|ng |rom u|c@edu (Sparks, John)
Date: Sun, 5 Jan 2025 20:03:11 +0000
Subject: [R] Help Parsing String? From HTML
Message-ID: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>

Hi,

I am scraping some data from the internet and I got what I want but in a big long string (sort of) and can't figure out a way to parse it.

What I have gotten to is

> mystring
{xml_nodeset (1)}
[1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n  "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from": "2005-01-04"\n}</p>

But I can't find a way to isolate the individual elements such as symbol, open, etc.

I'll bet there is someone out there with a lot more experience at html parsing than me who can see a way to solve this in minutes.

Any guidance would be appreciated.

--John Sparks

	[[alternative HTML version deleted]]


From |kry|ov @end|ng |rom d|@root@org  Sun Jan  5 21:16:05 2025
From: |kry|ov @end|ng |rom d|@root@org (Ivan Krylov)
Date: Sun, 5 Jan 2025 23:16:05 +0300
Subject: [R] Help Parsing String? From HTML
In-Reply-To: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
References: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
Message-ID: <20250105231605.222a0715@Tarkus>

? Sun, 5 Jan 2025 20:03:11 +0000
"Sparks, John via R-help" <r-help at r-project.org> ?????:

> > mystring  
> {xml_nodeset (1)}
> [1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n
> "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from":
> "2005-01-04"\n}</p>
> 
> But I can't find a way to isolate the individual elements such as
> symbol, open, etc.

This is a JSON string inside a <p> tag. It's not how a web page is
normally constructed (the <p> tag is usually for human-readable text,
not machine readable JSON), but the good news is that

mystring |> xml_text() |> jsonlite::parse_json()

should give you a named list with the desired contents.

-- 
Best regards,
Ivan


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Sun Jan  5 21:55:44 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 5 Jan 2025 14:55:44 -0600
Subject: [R] Help Parsing String? From HTML
In-Reply-To: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
References: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
Message-ID: <CAPPM_gT5LfQ96R2qL4R3a08Cb0u3ZTANpw9K59ng_FJhN0BJvQ@mail.gmail.com>

On Sun, Jan 5, 2025 at 2:03?PM Sparks, John via R-help
<r-help at r-project.org> wrote:
>
> Hi,
>
> I am scraping some data from the internet and I got what I want but in a big long string (sort of) and can't figure out a way to parse it.
>
What site are you scraping? There may be an easier way to get the data on it.

> What I have gotten to is
>
> > mystring
> {xml_nodeset (1)}
> [1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n  "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from": "2005-01-04"\n}</p>
>
> But I can't find a way to isolate the individual elements such as symbol, open, etc.
>
> I'll bet there is someone out there with a lot more experience at html parsing than me who can see a way to solve this in minutes.
>
> Any guidance would be appreciated.
>
> --John Sparks
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.



-- 
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  www.fosstrading.com


From j@p@rk4 @end|ng |rom u|c@edu  Mon Jan  6 00:41:13 2025
From: j@p@rk4 @end|ng |rom u|c@edu (Sparks, John)
Date: Sun, 5 Jan 2025 23:41:13 +0000
Subject: [R] Help Parsing String? From HTML
In-Reply-To: <CAPPM_gT5LfQ96R2qL4R3a08Cb0u3ZTANpw9K59ng_FJhN0BJvQ@mail.gmail.com>
References: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gT5LfQ96R2qL4R3a08Cb0u3ZTANpw9K59ng_FJhN0BJvQ@mail.gmail.com>
Message-ID: <BY5PR13MB363646638BA2166201BABC60FA172@BY5PR13MB3636.namprd13.prod.outlook.com>

Hi Josh,

Thanks for helping me with my second topic of the day.

I am scraping from the fmpcloud website and trying to get data from their survivorship free data (so they say).

The result is supposed to be in json format, but I can't figure out how to get any of R's json interpreters to parse the result.

The programming in R to get the initial data is

html <- read_html("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e")

Any (additional) guidance would be appreciated.

--John Sparks
________________________________
From: Joshua Ulrich <josh.m.ulrich at gmail.com>
Sent: Sunday, January 5, 2025 2:55 PM
To: Sparks, John <jspark4 at uic.edu>
Cc: r-help at r-project.org <r-help at r-project.org>
Subject: Re: [R] Help Parsing String? From HTML

CAUTION: External Sender

On Sun, Jan 5, 2025 at 2:03?PM Sparks, John via R-help
<r-help at r-project.org> wrote:
>
> Hi,
>
> I am scraping some data from the internet and I got what I want but in a big long string (sort of) and can't figure out a way to parse it.
>
What site are you scraping? There may be an easier way to get the data on it.

> What I have gotten to is
>
> > mystring
> {xml_nodeset (1)}
> [1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n  "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from": "2005-01-04"\n}</p>
>
> But I can't find a way to isolate the individual elements such as symbol, open, etc.
>
> I'll bet there is someone out there with a lot more experience at html parsing than me who can see a way to solve this in minutes.
>
> Any guidance would be appreciated.
>
> --John Sparks
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-help&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670167325%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=vpJ%2Bva%2BI%2Fnm1bBXakuB34TSW%2BV832R4sOgyYCAq6iIA%3D&reserved=0<https://stat.ethz.ch/mailman/listinfo/r-help>
> PLEASE do read the posting guide https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.r-project.org%2Fposting-guide.html&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670183537%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=HDxFV4GG6w%2Fut71t3IHHEz%2FTw3kiKYZeuxZvvbGCG7A%3D&reserved=0<https://www.r-project.org/posting-guide.html>
> and provide commented, minimal, self-contained, reproducible code.



--
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  https://nam04.safelinks.protection.outlook.com/?url=http%3A%2F%2Fwww.fosstrading.com%2F&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670195224%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=RSnWCt4%2BS04spT8n1DgklRukVCYHDdoNUW%2BGMtA4iAQ%3D&reserved=0<http://www.fosstrading.com/>

This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.

	[[alternative HTML version deleted]]


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Mon Jan  6 00:54:32 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 5 Jan 2025 17:54:32 -0600
Subject: [R] Help Parsing String? From HTML
In-Reply-To: <BY5PR13MB363646638BA2166201BABC60FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
References: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gT5LfQ96R2qL4R3a08Cb0u3ZTANpw9K59ng_FJhN0BJvQ@mail.gmail.com>
 <BY5PR13MB363646638BA2166201BABC60FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
Message-ID: <CAPPM_gSb4K=pbghXJi61YA9XAXpXRMg-z+ZZWPcf1tC-j2JLxA@mail.gmail.com>

On Sun, Jan 5, 2025 at 5:41?PM Sparks, John <jspark4 at uic.edu> wrote:
>
> Hi Josh,
>
> Thanks for helping me with my second topic of the day.
>
> I am scraping from the fmpcloud website and trying to get data from their survivorship free data (so they say).
>
> The result is supposed to be in json format, but I can't figure out how to get any of R's json interpreters to parse the result.
>
> The programming in R to get the initial data is
>
> html <- read_html("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e")
>
> Any (additional) guidance would be appreciated.
>
That's a REST API endpoint. It responds with JSON, not HTML. So you just need

    x <- jsonlite::parse_json("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e")

> --John Sparks
> ________________________________
> From: Joshua Ulrich <josh.m.ulrich at gmail.com>
> Sent: Sunday, January 5, 2025 2:55 PM
> To: Sparks, John <jspark4 at uic.edu>
> Cc: r-help at r-project.org <r-help at r-project.org>
> Subject: Re: [R] Help Parsing String? From HTML
>
> CAUTION: External Sender
>
> On Sun, Jan 5, 2025 at 2:03?PM Sparks, John via R-help
> <r-help at r-project.org> wrote:
> >
> > Hi,
> >
> > I am scraping some data from the internet and I got what I want but in a big long string (sort of) and can't figure out a way to parse it.
> >
> What site are you scraping? There may be an easier way to get the data on it.
>
> > What I have gotten to is
> >
> > > mystring
> > {xml_nodeset (1)}
> > [1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n  "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from": "2005-01-04"\n}</p>
> >
> > But I can't find a way to isolate the individual elements such as symbol, open, etc.
> >
> > I'll bet there is someone out there with a lot more experience at html parsing than me who can see a way to solve this in minutes.
> >
> > Any guidance would be appreciated.
> >
> > --John Sparks
> >
> >         [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-help&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670167325%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=vpJ%2Bva%2BI%2Fnm1bBXakuB34TSW%2BV832R4sOgyYCAq6iIA%3D&reserved=0
> > PLEASE do read the posting guide https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.r-project.org%2Fposting-guide.html&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670183537%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=HDxFV4GG6w%2Fut71t3IHHEz%2FTw3kiKYZeuxZvvbGCG7A%3D&reserved=0
> > and provide commented, minimal, self-contained, reproducible code.
>
>
>
> --
> Joshua Ulrich  |  about.me/joshuaulrich
>
> This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.


From jo@h@m@u|r|ch @end|ng |rom gm@||@com  Mon Jan  6 01:06:15 2025
From: jo@h@m@u|r|ch @end|ng |rom gm@||@com (Joshua Ulrich)
Date: Sun, 5 Jan 2025 18:06:15 -0600
Subject: [R] Help Parsing String? From HTML
In-Reply-To: <CAPPM_gSb4K=pbghXJi61YA9XAXpXRMg-z+ZZWPcf1tC-j2JLxA@mail.gmail.com>
References: <BY5PR13MB3636F4FE15C6226786203C7CFA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gT5LfQ96R2qL4R3a08Cb0u3ZTANpw9K59ng_FJhN0BJvQ@mail.gmail.com>
 <BY5PR13MB363646638BA2166201BABC60FA172@BY5PR13MB3636.namprd13.prod.outlook.com>
 <CAPPM_gSb4K=pbghXJi61YA9XAXpXRMg-z+ZZWPcf1tC-j2JLxA@mail.gmail.com>
Message-ID: <CAPPM_gR=wGiNgpuEJjZQLxYpCMFp6WUvFBiJOaagQgkmd1rkjA@mail.gmail.com>

On Sun, Jan 5, 2025 at 5:54?PM Joshua Ulrich <josh.m.ulrich at gmail.com> wrote:
>
> On Sun, Jan 5, 2025 at 5:41?PM Sparks, John <jspark4 at uic.edu> wrote:
> >
> > Hi Josh,
> >
> > Thanks for helping me with my second topic of the day.
> >
> > I am scraping from the fmpcloud website and trying to get data from their survivorship free data (so they say).
> >
> > The result is supposed to be in json format, but I can't figure out how to get any of R's json interpreters to parse the result.
> >
> > The programming in R to get the initial data is
> >
> > html <- read_html("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e")
> >
> > Any (additional) guidance would be appreciated.
> >
> That's a REST API endpoint. It responds with JSON, not HTML. So you just need
>
>     <untested code failure omitted>
>
Correction, that should be either
    x <- jsonlite::parse_json(url("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e"))
    # or
    x <- jsonlite::fromJSON("https://fmpcloud.io/api/v4/historical-price-full/ABI/2005-01-04?apikey=1af241eb87c43cfa7e124419cb180d7e")

> > --John Sparks
> > ________________________________
> > From: Joshua Ulrich <josh.m.ulrich at gmail.com>
> > Sent: Sunday, January 5, 2025 2:55 PM
> > To: Sparks, John <jspark4 at uic.edu>
> > Cc: r-help at r-project.org <r-help at r-project.org>
> > Subject: Re: [R] Help Parsing String? From HTML
> >
> > CAUTION: External Sender
> >
> > On Sun, Jan 5, 2025 at 2:03?PM Sparks, John via R-help
> > <r-help at r-project.org> wrote:
> > >
> > > Hi,
> > >
> > > I am scraping some data from the internet and I got what I want but in a big long string (sort of) and can't figure out a way to parse it.
> > >
> > What site are you scraping? There may be an easier way to get the data on it.
> >
> > > What I have gotten to is
> > >
> > > > mystring
> > > {xml_nodeset (1)}
> > > [1] <p>{\n  "symbol": "ABI",\n  "open": 21.04,\n  "high": 21.05,\n  "low": 20.06,\n  "close": 20.2,\n  "volume": 938700,\n  "from": "2005-01-04"\n}</p>
> > >
> > > But I can't find a way to isolate the individual elements such as symbol, open, etc.
> > >
> > > I'll bet there is someone out there with a lot more experience at html parsing than me who can see a way to solve this in minutes.
> > >
> > > Any guidance would be appreciated.
> > >
> > > --John Sparks
> > >
> > >         [[alternative HTML version deleted]]
> > >
> > > ______________________________________________
> > > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > > https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-help&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670167325%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=vpJ%2Bva%2BI%2Fnm1bBXakuB34TSW%2BV832R4sOgyYCAq6iIA%3D&reserved=0
> > > PLEASE do read the posting guide https://nam04.safelinks.protection.outlook.com/?url=https%3A%2F%2Fwww.r-project.org%2Fposting-guide.html&data=05%7C02%7Cjspark4%40uic.edu%7C7bd4229e6e74413d678c08dd2dcb5cff%7Ce202cd477a564baa99e3e3b71a7c77dd%7C0%7C0%7C638717073670183537%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&sdata=HDxFV4GG6w%2Fut71t3IHHEz%2FTw3kiKYZeuxZvvbGCG7A%3D&reserved=0
> > > and provide commented, minimal, self-contained, reproducible code.
> >
> >
> >
> > --
> > Joshua Ulrich  |  about.me/joshuaulrich
> >
> > This email originated from outside the University of Illinois System. Use caution when replying, clicking links, or opening attachments. DO NOT reply to any requests asking you to reply from a personal account or SMS.



-- 
Joshua Ulrich  |  about.me/joshuaulrich
FOSS Trading  |  www.fosstrading.com


From m||@nd_j @end|ng |rom hotm@||@com  Sun Jan  5 21:23:10 2025
From: m||@nd_j @end|ng |rom hotm@||@com (Miland Joshi)
Date: Sun, 5 Jan 2025 20:23:10 +0000
Subject: [R] Possible bug in direct.evidence.plot?
Message-ID: <DB7PR09MB2506A927224E142AC89E9DFEF9172@DB7PR09MB2506.eurprd09.prod.outlook.com>

I succeeded in getting netmetabin to work, but when trying to use direct.evidence.plot I ran into a problem:

> nb1evid <- direct.evidence.plot(nb1)
Error in if (class(x) != "netmeta") { : the condition has length > 1

I tried updating netmeta and dmetar (and dmetafor) from R, but the problem remains.
Has anyone come across this, and could it be a bug?

Regards
Miland Joshi

	[[alternative HTML version deleted]]


From er|cjberger @end|ng |rom gm@||@com  Mon Jan  6 09:24:42 2025
From: er|cjberger @end|ng |rom gm@||@com (Eric Berger)
Date: Mon, 6 Jan 2025 10:24:42 +0200
Subject: [R] Possible bug in direct.evidence.plot?
In-Reply-To: <DB7PR09MB2506A927224E142AC89E9DFEF9172@DB7PR09MB2506.eurprd09.prod.outlook.com>
References: <DB7PR09MB2506A927224E142AC89E9DFEF9172@DB7PR09MB2506.eurprd09.prod.outlook.com>
Message-ID: <CAGgJW74LDza5WL2FRXODpobe9GSTA1a5L04d3ODORwvBHHtKpg@mail.gmail.com>

The explanation is likely that class(x) returns a character vector of
length > 1.
If you go into the code you can achieve what is probably intended without
triggering this error by replacing that statement with the following:

if (inherits(x,"netmeta")) ...

HTH,
Eric


On Mon, Jan 6, 2025 at 9:57?AM Miland Joshi <miland_j at hotmail.com> wrote:

> I succeeded in getting netmetabin to work, but when trying to use
> direct.evidence.plot I ran into a problem:
>
> > nb1evid <- direct.evidence.plot(nb1)
> Error in if (class(x) != "netmeta") { : the condition has length > 1
>
> I tried updating netmeta and dmetar (and dmetafor) from R, but the problem
> remains.
> Has anyone come across this, and could it be a bug?
>
> Regards
> Miland Joshi
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From er|cjberger @end|ng |rom gm@||@com  Mon Jan  6 12:05:38 2025
From: er|cjberger @end|ng |rom gm@||@com (Eric Berger)
Date: Mon, 6 Jan 2025 13:05:38 +0200
Subject: [R] Possible bug in direct.evidence.plot?
In-Reply-To: <DB7PR09MB2506480D2D7136FA27C7306EF9102@DB7PR09MB2506.eurprd09.prod.outlook.com>
References: <DB7PR09MB2506A927224E142AC89E9DFEF9172@DB7PR09MB2506.eurprd09.prod.outlook.com>
 <CAGgJW74LDza5WL2FRXODpobe9GSTA1a5L04d3ODORwvBHHtKpg@mail.gmail.com>
 <DB7PR09MB2506480D2D7136FA27C7306EF9102@DB7PR09MB2506.eurprd09.prod.outlook.com>
Message-ID: <CAGgJW75SWsurK0aXQM7oTbgPwPVvJJu=sj-AGqUnK8KvBWDH6A@mail.gmail.com>

This is as I expected. My suggested fix will work in this case.

On Mon, Jan 6, 2025 at 1:03?PM Miland Joshi <miland_j at hotmail.com> wrote:

> Hello
>
> In R when I looked at the class of nb1 I got:
> > class(nb1)
> [1] "netmetabin" "netmeta"
>
> which suggests that netmeta might work but netmetabin may cause problems.
> I'll notify Mathias Harrer!
>
> BW
> Miland
>
> ------------------------------
> *From:* Eric Berger <ericjberger at gmail.com>
> *Sent:* 06 January 2025 08:24
> *To:* Miland Joshi <miland_j at hotmail.com>
> *Cc:* r-help at R-project.org <r-help at r-project.org>
> *Subject:* Re: [R] Possible bug in direct.evidence.plot?
>
> The explanation is likely that class(x) returns a character vector of
> length > 1.
> If you go into the code you can achieve what is probably intended without
> triggering this error by replacing that statement with the following:
>
> if (inherits(x,"netmeta")) ...
>
> HTH,
> Eric
>
>
> On Mon, Jan 6, 2025 at 9:57?AM Miland Joshi <miland_j at hotmail.com> wrote:
>
> I succeeded in getting netmetabin to work, but when trying to use
> direct.evidence.plot I ran into a problem:
>
> > nb1evid <- direct.evidence.plot(nb1)
> Error in if (class(x) != "netmeta") { : the condition has length > 1
>
> I tried updating netmeta and dmetar (and dmetafor) from R, but the problem
> remains.
> Has anyone come across this, and could it be a bug?
>
> Regards
> Miland Joshi
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>
>

	[[alternative HTML version deleted]]


From JH@rm@e @end|ng |rom roku@com  Mon Jan  6 18:55:21 2025
From: JH@rm@e @end|ng |rom roku@com (Jorgen Harmse)
Date: Mon, 6 Jan 2025 17:55:21 +0000
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
Message-ID: <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>

I think Bert Gunter is right, but do you want partial matches (not found by match), and how robust do you want the code to be?

f <- function(?)
{ pos <- match('a', ...names())
  if (is.na(pos))
    stop("a is required.")
  ?elt(pos)
}

Incidentally, what is the best way to extract the expression without evaluating it?



g <- function(...)

{ pos <- match('a',...names())

  if (is.na(pos))

    stop("a is missing.")

  (function(a,...) substitute(a)) (...)

}

Regards,
Jorgen Harmse.

Message: 8
Date: Sun, 5 Jan 2025 11:17:02 -0800
From: Bert Gunter <bgunter.4567 at gmail.com>
To: Iris Simmons <ikwsimmo at gmail.com>
Cc: R-help <R-help at r-project.org>
Subject: Re: [R] Extracting specific arguments from "..."
Message-ID:
        <CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
Content-Type: text/plain; charset="utf-8"

Thanks, Iris.
That is what I suspected, but it wasn't clear to me from the docs.

Best,
Bert

On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
>
> I would use two because it does not force the evaluation of the other arguments in the ... list.
>
>
>
> On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
>>
>> Consider:
>>
>> f1 <- function(...){
>>   one <- list(...)[['a']]
>>   two <- ...elt(match('a', ...names()))
>>   c(one, two)
>> }
>> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> unknown position.
>>
>> > f1(b=5, a = 2, c=7)
>> [1] 2 2
>>
>> Which is better for extracting a specific named argument, one<- or
>> two<- ?  Or a third alternative that is better than both?
>> Comments and critiques welcome.
>>
>> Cheers,
>> Bert
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.




	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Mon Jan  6 23:22:10 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Mon, 6 Jan 2025 14:22:10 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
Message-ID: <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>

Thanks Jorgen.

I thought your approach to getting the argument expressions was clever, but
somewhat convoluted. I think the usual simple way is to use match.call()
(or sys.call() )to get the unevaluated argument expressions;  e.g. ...

f <- function(...){
   match.call()
}
> f(a = 'red', b = sin(zzz))
f(a = "red", b = sin(zzz))

The return value is an object of class call that can be subscripted as (or
converted by as.list() to) a list to extract the argument expressions:
> f(a = 'red', b = sin(zzz))$b
sin(zzz)

You'll note that the $b component is again of class "call". So you may wish
to convert it to character or expression or whatever for further
processing, depending on context. Obviously, I haven't thought about this
carefully.

You raise an important point about robustness. I believe this approach to
extracting the call expressions should be fairly robust, but I do get
confused about the lay of the land when you add promises with default
arguments that may not yet have been forced before match.call() is called.
You may have to wrestle with sys.call() and it's "wh" argument to make
things work the way you want in that situation. I leave such delights to
wiser heads, as well as any corrections or refinements to anything that
I've said here.

Cheers,
Bert

On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:

> I think Bert Gunter is right, but do you want partial matches (not found
> by match), and how robust do you want the code to be?
>
>
>
> f <- function(?)
>
> { pos <- match('a', ...names())
>
>   if (is.na(pos))
>
>     stop("a is required.")
>
>   ?elt(pos)
>
> }
>
>
>
> Incidentally, what is the best way to extract the expression without
> evaluating it?
>
>
>
> g <- function(...)
>
> { pos <- match('a',...names())
>
>   if (is.na(pos))
>
>     stop("a is missing.")
>
>   (function(a,...) substitute(a)) (...)
>
> }
>
>
>
> Regards,
>
> Jorgen Harmse.
>
>
>
> Message: 8
> Date: Sun, 5 Jan 2025 11:17:02 -0800
> From: Bert Gunter <bgunter.4567 at gmail.com>
> To: Iris Simmons <ikwsimmo at gmail.com>
> Cc: R-help <R-help at r-project.org>
> Subject: Re: [R] Extracting specific arguments from "..."
> Message-ID:
>         <
> CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Thanks, Iris.
> That is what I suspected, but it wasn't clear to me from the docs.
>
> Best,
> Bert
>
> On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
> >
> > I would use two because it does not force the evaluation of the other
> arguments in the ... list.
> >
> >
> >
> > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
> >>
> >> Consider:
> >>
> >> f1 <- function(...){
> >>   one <- list(...)[['a']]
> >>   two <- ...elt(match('a', ...names()))
> >>   c(one, two)
> >> }
> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
> >> unknown position.
> >>
> >> > f1(b=5, a = 2, c=7)
> >> [1] 2 2
> >>
> >> Which is better for extracting a specific named argument, one<- or
> >> two<- ?  Or a third alternative that is better than both?
> >> Comments and critiques welcome.
> >>
> >> Cheers,
> >> Bert
> >>
> >> ______________________________________________
> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> PLEASE do read the posting guide
> https://www.r-project.org/posting-guide.html
> >> and provide commented, minimal, self-contained, reproducible code.
>
>
>
>

	[[alternative HTML version deleted]]


From j@ork|n @end|ng |rom @om@um@ry|@nd@edu  Tue Jan  7 00:26:25 2025
From: j@ork|n @end|ng |rom @om@um@ry|@nd@edu (Sorkin, John)
Date: Mon, 6 Jan 2025 23:26:25 +0000
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
 <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
Message-ID: <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>

Bert and other on this Chain,

The original question asked by Bert Gunter, highlights one of my long standing wishes. Perhaps my wish has already been fulfilled (if it has, please let me know where I can look of fulfill my wish), if it hasn't perhaps someone can grant me my wish.

I have tried to understand how to write a function (beyond a basic function), get values of the parameters, and process the parameters. I have looked for a source that clearly describes how his may be done (with examples), but I have yet to find one. Yes, one can look at a function (e.g. lm) look at the statements that are used and use the help system to research each of the statements (I have done this), but doing this is not the most efficient way to learn the topic. It would be very helpful if someone Knowledgeable would put together a primer on writing functions and processing function arguments. If such a document exist, I would be happy to have someone send me its URL.

Thank you,
John

John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




________________________________________
From: R-help <r-help-bounces at r-project.org> on behalf of Bert Gunter <bgunter.4567 at gmail.com>
Sent: Monday, January 6, 2025 5:22 PM
To: Jorgen Harmse
Cc: r-help at r-project.org
Subject: Re: [R] Extracting specific arguments from "..."

Thanks Jorgen.

I thought your approach to getting the argument expressions was clever, but
somewhat convoluted. I think the usual simple way is to use match.call()
(or sys.call() )to get the unevaluated argument expressions;  e.g. ...

f <- function(...){
   match.call()
}
> f(a = 'red', b = sin(zzz))
f(a = "red", b = sin(zzz))

The return value is an object of class call that can be subscripted as (or
converted by as.list() to) a list to extract the argument expressions:
> f(a = 'red', b = sin(zzz))$b
sin(zzz)

You'll note that the $b component is again of class "call". So you may wish
to convert it to character or expression or whatever for further
processing, depending on context. Obviously, I haven't thought about this
carefully.

You raise an important point about robustness. I believe this approach to
extracting the call expressions should be fairly robust, but I do get
confused about the lay of the land when you add promises with default
arguments that may not yet have been forced before match.call() is called.
You may have to wrestle with sys.call() and it's "wh" argument to make
things work the way you want in that situation. I leave such delights to
wiser heads, as well as any corrections or refinements to anything that
I've said here.

Cheers,
Bert

On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:

> I think Bert Gunter is right, but do you want partial matches (not found
> by match), and how robust do you want the code to be?
>
>
>
> f <- function(?)
>
> { pos <- match('a', ...names())
>
>   if (is.na(pos))
>
>     stop("a is required.")
>
>   ?elt(pos)
>
> }
>
>
>
> Incidentally, what is the best way to extract the expression without
> evaluating it?
>
>
>
> g <- function(...)
>
> { pos <- match('a',...names())
>
>   if (is.na(pos))
>
>     stop("a is missing.")
>
>   (function(a,...) substitute(a)) (...)
>
> }
>
>
>
> Regards,
>
> Jorgen Harmse.
>
>
>
> Message: 8
> Date: Sun, 5 Jan 2025 11:17:02 -0800
> From: Bert Gunter <bgunter.4567 at gmail.com>
> To: Iris Simmons <ikwsimmo at gmail.com>
> Cc: R-help <R-help at r-project.org>
> Subject: Re: [R] Extracting specific arguments from "..."
> Message-ID:
>         <
> CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Thanks, Iris.
> That is what I suspected, but it wasn't clear to me from the docs.
>
> Best,
> Bert
>
> On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
> >
> > I would use two because it does not force the evaluation of the other
> arguments in the ... list.
> >
> >
> >
> > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
> >>
> >> Consider:
> >>
> >> f1 <- function(...){
> >>   one <- list(...)[['a']]
> >>   two <- ...elt(match('a', ...names()))
> >>   c(one, two)
> >> }
> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
> >> unknown position.
> >>
> >> > f1(b=5, a = 2, c=7)
> >> [1] 2 2
> >>
> >> Which is better for extracting a specific named argument, one<- or
> >> two<- ?  Or a third alternative that is better than both?
> >> Comments and critiques welcome.
> >>
> >> Cheers,
> >> Bert
> >>
> >> ______________________________________________
> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> PLEASE do read the posting guide
> https://www.r-project.org/posting-guide.html
> >> and provide commented, minimal, self-contained, reproducible code.
>
>
>
>

        [[alternative HTML version deleted]]

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.

From bgunter@4567 @end|ng |rom gm@||@com  Tue Jan  7 00:48:55 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Mon, 6 Jan 2025 15:48:55 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
 <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
 <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <CAGxFJbTLgFLgehCnG=V5BDaSPe1AT7vQO_NvAmgJpwAdiN5BZA@mail.gmail.com>

I am frankly at a loss.

Have you read "An Introduction to R," which is shipped with R, especially
Ch. 10. Or any of Hadley's (free, online) books. Or looked at Posit's or
the web's tutorials? There is so much out there...

I would say that the Help docs are meant to be concise references on how to
use particular functions, *not* tutorials on how to write functions in R.
(That said, I have found some of R's Help resources sufficient to learn
techniques that I was ignorant of, regular expressions for example.
However, that is not their purpose, as I said).

Or have I entirely misunderstood you?!

NB. Terminology: Function "arguments" not "parameters". "Parameters"
actually means something different in R.

Cheers,
Bert

On Mon, Jan 6, 2025 at 3:26?PM Sorkin, John <jsorkin at som.umaryland.edu>
wrote:

> Bert and other on this Chain,
>
> The original question asked by Bert Gunter, highlights one of my long
> standing wishes. Perhaps my wish has already been fulfilled (if it has,
> please let me know where I can look of fulfill my wish), if it hasn't
> perhaps someone can grant me my wish.
>
> I have tried to understand how to write a function (beyond a basic
> function), get values of the parameters, and process the parameters. I have
> looked for a source that clearly describes how his may be done (with
> examples), but I have yet to find one. Yes, one can look at a function
> (e.g. lm) look at the statements that are used and use the help system to
> research each of the statements (I have done this), but doing this is not
> the most efficient way to learn the topic. It would be very helpful if
> someone Knowledgeable would put together a primer on writing functions and
> processing function arguments. If such a document exist, I would be happy
> to have someone send me its URL.
>
> Thank you,
> John
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical
> Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of
> Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
>
> ________________________________________
> From: R-help <r-help-bounces at r-project.org> on behalf of Bert Gunter <
> bgunter.4567 at gmail.com>
> Sent: Monday, January 6, 2025 5:22 PM
> To: Jorgen Harmse
> Cc: r-help at r-project.org
> Subject: Re: [R] Extracting specific arguments from "..."
>
> Thanks Jorgen.
>
> I thought your approach to getting the argument expressions was clever, but
> somewhat convoluted. I think the usual simple way is to use match.call()
> (or sys.call() )to get the unevaluated argument expressions;  e.g. ...
>
> f <- function(...){
>    match.call()
> }
> > f(a = 'red', b = sin(zzz))
> f(a = "red", b = sin(zzz))
>
> The return value is an object of class call that can be subscripted as (or
> converted by as.list() to) a list to extract the argument expressions:
> > f(a = 'red', b = sin(zzz))$b
> sin(zzz)
>
> You'll note that the $b component is again of class "call". So you may wish
> to convert it to character or expression or whatever for further
> processing, depending on context. Obviously, I haven't thought about this
> carefully.
>
> You raise an important point about robustness. I believe this approach to
> extracting the call expressions should be fairly robust, but I do get
> confused about the lay of the land when you add promises with default
> arguments that may not yet have been forced before match.call() is called.
> You may have to wrestle with sys.call() and it's "wh" argument to make
> things work the way you want in that situation. I leave such delights to
> wiser heads, as well as any corrections or refinements to anything that
> I've said here.
>
> Cheers,
> Bert
>
> On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:
>
> > I think Bert Gunter is right, but do you want partial matches (not found
> > by match), and how robust do you want the code to be?
> >
> >
> >
> > f <- function(?)
> >
> > { pos <- match('a', ...names())
> >
> >   if (is.na(pos))
> >
> >     stop("a is required.")
> >
> >   ?elt(pos)
> >
> > }
> >
> >
> >
> > Incidentally, what is the best way to extract the expression without
> > evaluating it?
> >
> >
> >
> > g <- function(...)
> >
> > { pos <- match('a',...names())
> >
> >   if (is.na(pos))
> >
> >     stop("a is missing.")
> >
> >   (function(a,...) substitute(a)) (...)
> >
> > }
> >
> >
> >
> > Regards,
> >
> > Jorgen Harmse.
> >
> >
> >
> > Message: 8
> > Date: Sun, 5 Jan 2025 11:17:02 -0800
> > From: Bert Gunter <bgunter.4567 at gmail.com>
> > To: Iris Simmons <ikwsimmo at gmail.com>
> > Cc: R-help <R-help at r-project.org>
> > Subject: Re: [R] Extracting specific arguments from "..."
> > Message-ID:
> >         <
> > CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
> > Content-Type: text/plain; charset="utf-8"
> >
> > Thanks, Iris.
> > That is what I suspected, but it wasn't clear to me from the docs.
> >
> > Best,
> > Bert
> >
> > On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
> > >
> > > I would use two because it does not force the evaluation of the other
> > arguments in the ... list.
> > >
> > >
> > >
> > > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
> > >>
> > >> Consider:
> > >>
> > >> f1 <- function(...){
> > >>   one <- list(...)[['a']]
> > >>   two <- ...elt(match('a', ...names()))
> > >>   c(one, two)
> > >> }
> > >> ## Here "..." is an argument list with "a" somewhere in it, but in an
> > >> unknown position.
> > >>
> > >> > f1(b=5, a = 2, c=7)
> > >> [1] 2 2
> > >>
> > >> Which is better for extracting a specific named argument, one<- or
> > >> two<- ?  Or a third alternative that is better than both?
> > >> Comments and critiques welcome.
> > >>
> > >> Cheers,
> > >> Bert
> > >>
> > >> ______________________________________________
> > >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > >> https://stat.ethz.ch/mailman/listinfo/r-help
> > >> PLEASE do read the posting guide
> > https://www.r-project.org/posting-guide.html
> > >> and provide commented, minimal, self-contained, reproducible code.
> >
> >
> >
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.r-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Tue Jan  7 01:04:16 2025
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Mon, 06 Jan 2025 16:04:16 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
 <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
 <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <8220C27D-591E-4B3D-BFDA-1F28044CC344@dcn.davis.ca.us>

It is a pretty tricky topic, but IMO Advanced R [1] steps you through it systematically... you just have to be prepared to follow along in R with the examples as you read it. In particular, the chapter on Functions goes through this.

The subtleties of how base R gives you control over these topics is what lead to the tidyverse creating new packages to build such function interfaces. Manipulating object evaluation from arbitrary environments is still complex, and the more you learn about it the more you learn to avoid it for certain types of tasks. String literals are surprisingly simple alternatives that don't bite you in the butt nearly so often as NSE does.

[1] https://adv-r.hadley.nz/

On January 6, 2025 3:26:25 PM PST, "Sorkin, John" <jsorkin at som.umaryland.edu> wrote:
>Bert and other on this Chain,
>
>The original question asked by Bert Gunter, highlights one of my long standing wishes. Perhaps my wish has already been fulfilled (if it has, please let me know where I can look of fulfill my wish), if it hasn't perhaps someone can grant me my wish.
>
>I have tried to understand how to write a function (beyond a basic function), get values of the parameters, and process the parameters. I have looked for a source that clearly describes how his may be done (with examples), but I have yet to find one. Yes, one can look at a function (e.g. lm) look at the statements that are used and use the help system to research each of the statements (I have done this), but doing this is not the most efficient way to learn the topic. It would be very helpful if someone Knowledgeable would put together a primer on writing functions and processing function arguments. If such a document exist, I would be happy to have someone send me its URL.
>
>Thank you,
>John
>
>John David Sorkin M.D., Ph.D.
>Professor of Medicine, University of Maryland School of Medicine;
>Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
>PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
>Senior Statistician University of Maryland Center for Vascular Research;
>
>Division of Gerontology and Paliative Care,
>10 North Greene Street
>GRECC (BT/18/GR)
>Baltimore, MD 21201-1524
>Cell phone 443-418-5382
>
>
>
>
>________________________________________
>From: R-help <r-help-bounces at r-project.org> on behalf of Bert Gunter <bgunter.4567 at gmail.com>
>Sent: Monday, January 6, 2025 5:22 PM
>To: Jorgen Harmse
>Cc: r-help at r-project.org
>Subject: Re: [R] Extracting specific arguments from "..."
>
>Thanks Jorgen.
>
>I thought your approach to getting the argument expressions was clever, but
>somewhat convoluted. I think the usual simple way is to use match.call()
>(or sys.call() )to get the unevaluated argument expressions;  e.g. ...
>
>f <- function(...){
>   match.call()
>}
>> f(a = 'red', b = sin(zzz))
>f(a = "red", b = sin(zzz))
>
>The return value is an object of class call that can be subscripted as (or
>converted by as.list() to) a list to extract the argument expressions:
>> f(a = 'red', b = sin(zzz))$b
>sin(zzz)
>
>You'll note that the $b component is again of class "call". So you may wish
>to convert it to character or expression or whatever for further
>processing, depending on context. Obviously, I haven't thought about this
>carefully.
>
>You raise an important point about robustness. I believe this approach to
>extracting the call expressions should be fairly robust, but I do get
>confused about the lay of the land when you add promises with default
>arguments that may not yet have been forced before match.call() is called.
>You may have to wrestle with sys.call() and it's "wh" argument to make
>things work the way you want in that situation. I leave such delights to
>wiser heads, as well as any corrections or refinements to anything that
>I've said here.
>
>Cheers,
>Bert
>
>On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:
>
>> I think Bert Gunter is right, but do you want partial matches (not found
>> by match), and how robust do you want the code to be?
>>
>>
>>
>> f <- function(?)
>>
>> { pos <- match('a', ...names())
>>
>>   if (is.na(pos))
>>
>>     stop("a is required.")
>>
>>   ?elt(pos)
>>
>> }
>>
>>
>>
>> Incidentally, what is the best way to extract the expression without
>> evaluating it?
>>
>>
>>
>> g <- function(...)
>>
>> { pos <- match('a',...names())
>>
>>   if (is.na(pos))
>>
>>     stop("a is missing.")
>>
>>   (function(a,...) substitute(a)) (...)
>>
>> }
>>
>>
>>
>> Regards,
>>
>> Jorgen Harmse.
>>
>>
>>
>> Message: 8
>> Date: Sun, 5 Jan 2025 11:17:02 -0800
>> From: Bert Gunter <bgunter.4567 at gmail.com>
>> To: Iris Simmons <ikwsimmo at gmail.com>
>> Cc: R-help <R-help at r-project.org>
>> Subject: Re: [R] Extracting specific arguments from "..."
>> Message-ID:
>>         <
>> CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> Thanks, Iris.
>> That is what I suspected, but it wasn't clear to me from the docs.
>>
>> Best,
>> Bert
>>
>> On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com> wrote:
>> >
>> > I would use two because it does not force the evaluation of the other
>> arguments in the ... list.
>> >
>> >
>> >
>> > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com> wrote:
>> >>
>> >> Consider:
>> >>
>> >> f1 <- function(...){
>> >>   one <- list(...)[['a']]
>> >>   two <- ...elt(match('a', ...names()))
>> >>   c(one, two)
>> >> }
>> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> >> unknown position.
>> >>
>> >> > f1(b=5, a = 2, c=7)
>> >> [1] 2 2
>> >>
>> >> Which is better for extracting a specific named argument, one<- or
>> >> two<- ?  Or a third alternative that is better than both?
>> >> Comments and critiques welcome.
>> >>
>> >> Cheers,
>> >> Bert
>> >>
>> >> ______________________________________________
>> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> >> https://stat.ethz.ch/mailman/listinfo/r-help
>> >> PLEASE do read the posting guide
>> https://www.r-project.org/posting-guide.html
>> >> and provide commented, minimal, self-contained, reproducible code.
>>
>>
>>
>>
>
>        [[alternative HTML version deleted]]
>
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.

-- 
Sent from my phone. Please excuse my brevity.


From bgunter@4567 @end|ng |rom gm@||@com  Tue Jan  7 02:15:59 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Mon, 6 Jan 2025 17:15:59 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <8220C27D-591E-4B3D-BFDA-1F28044CC344@dcn.davis.ca.us>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
 <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
 <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
 <8220C27D-591E-4B3D-BFDA-1F28044CC344@dcn.davis.ca.us>
Message-ID: <CAGxFJbS1iUr-Tu5oTXGU=gtXh1B9GgznEcxvMh-P434j-UFELQ@mail.gmail.com>

Jeff:
Would you care to offer an example of:

"String literals are surprisingly simple alternatives that don't bite you
in the butt nearly so often as NSE does."

"No" is a perfectly acceptable answer.

I would generally agree with you about NSE, but my original query was
motivated by something simple. I like to use lattice graphics when I fool
around with graphing data, as I'm retired and don't have to worry about
adhering to organizational or journal standards built around the ggplot
graphics grammar or require it's very extensive and sophisticated
capabilities. But I do often create custom panel displays, which typically
requires that I have to pass around long default lists of graphics
arguments via "..." that I modify to suit my aesthetic and analytical
preferences. Ergo my query about how to check what's in the "..." list
without requiring evaluation, which Iris helped me with.

I would also suggest that as a personal user of R for "data science stuff",
one can avoid a lot of the complexities to which you allude; while as a
developer of "tools" (chiefly packages) for others, one has to wade into a
lot of those complexities. This is just a software clich? I think.
Unfortunately, S and therefore R, were originally designed for a pretty
sophisticated audience (ATT labs researchers) and intentionally, and to me
rather seductively, blurred the line between "user" and "developer."  All
IMO, of course. YMMV.

Cheers,
Bert


On Mon, Jan 6, 2025 at 4:04?PM Jeff Newmiller <jdnewmil at dcn.davis.ca.us>
wrote:

> It is a pretty tricky topic, but IMO Advanced R [1] steps you through it
> systematically... you just have to be prepared to follow along in R with
> the examples as you read it. In particular, the chapter on Functions goes
> through this.
>
> The subtleties of how base R gives you control over these topics is what
> lead to the tidyverse creating new packages to build such function
> interfaces. Manipulating object evaluation from arbitrary environments is
> still complex, and the more you learn about it the more you learn to avoid
> it for certain types of tasks. String literals are surprisingly simple
> alternatives that don't bite you in the butt nearly so often as NSE does.
>
> [1] https://adv-r.hadley.nz/
>
> On January 6, 2025 3:26:25 PM PST, "Sorkin, John" <
> jsorkin at som.umaryland.edu> wrote:
> >Bert and other on this Chain,
> >
> >The original question asked by Bert Gunter, highlights one of my long
> standing wishes. Perhaps my wish has already been fulfilled (if it has,
> please let me know where I can look of fulfill my wish), if it hasn't
> perhaps someone can grant me my wish.
> >
> >I have tried to understand how to write a function (beyond a basic
> function), get values of the parameters, and process the parameters. I have
> looked for a source that clearly describes how his may be done (with
> examples), but I have yet to find one. Yes, one can look at a function
> (e.g. lm) look at the statements that are used and use the help system to
> research each of the statements (I have done this), but doing this is not
> the most efficient way to learn the topic. It would be very helpful if
> someone Knowledgeable would put together a primer on writing functions and
> processing function arguments. If such a document exist, I would be happy
> to have someone send me its URL.
> >
> >Thank you,
> >John
> >
> >John David Sorkin M.D., Ph.D.
> >Professor of Medicine, University of Maryland School of Medicine;
> >Associate Director for Biostatistics and Informatics, Baltimore VA
> Medical Center Geriatrics Research, Education, and Clinical Center;
> >PI Biostatistics and Informatics Core, University of Maryland School of
> Medicine Claude D. Pepper Older Americans Independence Center;
> >Senior Statistician University of Maryland Center for Vascular Research;
> >
> >Division of Gerontology and Paliative Care,
> >10 North Greene Street
> >GRECC (BT/18/GR)
> >Baltimore, MD 21201-1524
> >Cell phone 443-418-5382
> >
> >
> >
> >
> >________________________________________
> >From: R-help <r-help-bounces at r-project.org> on behalf of Bert Gunter <
> bgunter.4567 at gmail.com>
> >Sent: Monday, January 6, 2025 5:22 PM
> >To: Jorgen Harmse
> >Cc: r-help at r-project.org
> >Subject: Re: [R] Extracting specific arguments from "..."
> >
> >Thanks Jorgen.
> >
> >I thought your approach to getting the argument expressions was clever,
> but
> >somewhat convoluted. I think the usual simple way is to use match.call()
> >(or sys.call() )to get the unevaluated argument expressions;  e.g. ...
> >
> >f <- function(...){
> >   match.call()
> >}
> >> f(a = 'red', b = sin(zzz))
> >f(a = "red", b = sin(zzz))
> >
> >The return value is an object of class call that can be subscripted as (or
> >converted by as.list() to) a list to extract the argument expressions:
> >> f(a = 'red', b = sin(zzz))$b
> >sin(zzz)
> >
> >You'll note that the $b component is again of class "call". So you may
> wish
> >to convert it to character or expression or whatever for further
> >processing, depending on context. Obviously, I haven't thought about this
> >carefully.
> >
> >You raise an important point about robustness. I believe this approach to
> >extracting the call expressions should be fairly robust, but I do get
> >confused about the lay of the land when you add promises with default
> >arguments that may not yet have been forced before match.call() is called.
> >You may have to wrestle with sys.call() and it's "wh" argument to make
> >things work the way you want in that situation. I leave such delights to
> >wiser heads, as well as any corrections or refinements to anything that
> >I've said here.
> >
> >Cheers,
> >Bert
> >
> >On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:
> >
> >> I think Bert Gunter is right, but do you want partial matches (not found
> >> by match), and how robust do you want the code to be?
> >>
> >>
> >>
> >> f <- function(?)
> >>
> >> { pos <- match('a', ...names())
> >>
> >>   if (is.na(pos))
> >>
> >>     stop("a is required.")
> >>
> >>   ?elt(pos)
> >>
> >> }
> >>
> >>
> >>
> >> Incidentally, what is the best way to extract the expression without
> >> evaluating it?
> >>
> >>
> >>
> >> g <- function(...)
> >>
> >> { pos <- match('a',...names())
> >>
> >>   if (is.na(pos))
> >>
> >>     stop("a is missing.")
> >>
> >>   (function(a,...) substitute(a)) (...)
> >>
> >> }
> >>
> >>
> >>
> >> Regards,
> >>
> >> Jorgen Harmse.
> >>
> >>
> >>
> >> Message: 8
> >> Date: Sun, 5 Jan 2025 11:17:02 -0800
> >> From: Bert Gunter <bgunter.4567 at gmail.com>
> >> To: Iris Simmons <ikwsimmo at gmail.com>
> >> Cc: R-help <R-help at r-project.org>
> >> Subject: Re: [R] Extracting specific arguments from "..."
> >> Message-ID:
> >>         <
> >> CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
> >> Content-Type: text/plain; charset="utf-8"
> >>
> >> Thanks, Iris.
> >> That is what I suspected, but it wasn't clear to me from the docs.
> >>
> >> Best,
> >> Bert
> >>
> >> On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com>
> wrote:
> >> >
> >> > I would use two because it does not force the evaluation of the other
> >> arguments in the ... list.
> >> >
> >> >
> >> >
> >> > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com>
> wrote:
> >> >>
> >> >> Consider:
> >> >>
> >> >> f1 <- function(...){
> >> >>   one <- list(...)[['a']]
> >> >>   two <- ...elt(match('a', ...names()))
> >> >>   c(one, two)
> >> >> }
> >> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
> >> >> unknown position.
> >> >>
> >> >> > f1(b=5, a = 2, c=7)
> >> >> [1] 2 2
> >> >>
> >> >> Which is better for extracting a specific named argument, one<- or
> >> >> two<- ?  Or a third alternative that is better than both?
> >> >> Comments and critiques welcome.
> >> >>
> >> >> Cheers,
> >> >> Bert
> >> >>
> >> >> ______________________________________________
> >> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> >> PLEASE do read the posting guide
> >> https://www.r-project.org/posting-guide.html
> >> >> and provide commented, minimal, self-contained, reproducible code.
> >>
> >>
> >>
> >>
> >
> >        [[alternative HTML version deleted]]
> >
> >______________________________________________
> >R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >https://stat.ethz.ch/mailman/listinfo/r-help
> >PLEASE do read the posting guide
> https://www.r-project.org/posting-guide.html
> >and provide commented, minimal, self-contained, reproducible code.
> >______________________________________________
> >R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >https://stat.ethz.ch/mailman/listinfo/r-help
> >PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> >and provide commented, minimal, self-contained, reproducible code.
>
> --
> Sent from my phone. Please excuse my brevity.
>

	[[alternative HTML version deleted]]


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Tue Jan  7 08:23:34 2025
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Mon, 06 Jan 2025 23:23:34 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAGxFJbS1iUr-Tu5oTXGU=gtXh1B9GgznEcxvMh-P434j-UFELQ@mail.gmail.com>
References: <mailman.372427.1.1736161201.1621.r-help@r-project.org>
 <BL0PR01MB44341CE04D07ABD4A162DDB1DC102@BL0PR01MB4434.prod.exchangelabs.com>
 <CAGxFJbSFWNjbAOB6U3dbiSizPyWoJrD3hK5Qe5L9bB_9iug78w@mail.gmail.com>
 <DM6PR03MB5049D8360BE310C35A65FEEDE2102@DM6PR03MB5049.namprd03.prod.outlook.com>
 <8220C27D-591E-4B3D-BFDA-1F28044CC344@dcn.davis.ca.us>
 <CAGxFJbS1iUr-Tu5oTXGU=gtXh1B9GgznEcxvMh-P434j-UFELQ@mail.gmail.com>
Message-ID: <DC69F297-832A-4591-9BB6-CBEC215D4968@dcn.davis.ca.us>

I have no particular example in mind, though if your data are in lists (e.g. data frames) or better yet you want to add new data to a list then a particular trap for inexperienced analysts is trying to capture the name of the not-yet-created item from a symbol instead of simply giving the function a string to label the new item with.

I must say playing around with ... seems tediously unpleasant to me... to each their own though. I prefer to let R handle that... if I want to tweak a variable being passed I just declare the parameter explicitly and pass it along explicitly. As long as it has a default value the calling function shouldn't care... unless it is also abusing ....

On January 6, 2025 5:15:59 PM PST, Bert Gunter <bgunter.4567 at gmail.com> wrote:
>Jeff:
>Would you care to offer an example of:
>
>"String literals are surprisingly simple alternatives that don't bite you
>in the butt nearly so often as NSE does."
>
>"No" is a perfectly acceptable answer.
>
>I would generally agree with you about NSE, but my original query was
>motivated by something simple. I like to use lattice graphics when I fool
>around with graphing data, as I'm retired and don't have to worry about
>adhering to organizational or journal standards built around the ggplot
>graphics grammar or require it's very extensive and sophisticated
>capabilities. But I do often create custom panel displays, which typically
>requires that I have to pass around long default lists of graphics
>arguments via "..." that I modify to suit my aesthetic and analytical
>preferences. Ergo my query about how to check what's in the "..." list
>without requiring evaluation, which Iris helped me with.
>
>I would also suggest that as a personal user of R for "data science stuff",
>one can avoid a lot of the complexities to which you allude; while as a
>developer of "tools" (chiefly packages) for others, one has to wade into a
>lot of those complexities. This is just a software clich? I think.
>Unfortunately, S and therefore R, were originally designed for a pretty
>sophisticated audience (ATT labs researchers) and intentionally, and to me
>rather seductively, blurred the line between "user" and "developer."  All
>IMO, of course. YMMV.
>
>Cheers,
>Bert
>
>
>On Mon, Jan 6, 2025 at 4:04?PM Jeff Newmiller <jdnewmil at dcn.davis.ca.us>
>wrote:
>
>> It is a pretty tricky topic, but IMO Advanced R [1] steps you through it
>> systematically... you just have to be prepared to follow along in R with
>> the examples as you read it. In particular, the chapter on Functions goes
>> through this.
>>
>> The subtleties of how base R gives you control over these topics is what
>> lead to the tidyverse creating new packages to build such function
>> interfaces. Manipulating object evaluation from arbitrary environments is
>> still complex, and the more you learn about it the more you learn to avoid
>> it for certain types of tasks. String literals are surprisingly simple
>> alternatives that don't bite you in the butt nearly so often as NSE does.
>>
>> [1] https://adv-r.hadley.nz/
>>
>> On January 6, 2025 3:26:25 PM PST, "Sorkin, John" <
>> jsorkin at som.umaryland.edu> wrote:
>> >Bert and other on this Chain,
>> >
>> >The original question asked by Bert Gunter, highlights one of my long
>> standing wishes. Perhaps my wish has already been fulfilled (if it has,
>> please let me know where I can look of fulfill my wish), if it hasn't
>> perhaps someone can grant me my wish.
>> >
>> >I have tried to understand how to write a function (beyond a basic
>> function), get values of the parameters, and process the parameters. I have
>> looked for a source that clearly describes how his may be done (with
>> examples), but I have yet to find one. Yes, one can look at a function
>> (e.g. lm) look at the statements that are used and use the help system to
>> research each of the statements (I have done this), but doing this is not
>> the most efficient way to learn the topic. It would be very helpful if
>> someone Knowledgeable would put together a primer on writing functions and
>> processing function arguments. If such a document exist, I would be happy
>> to have someone send me its URL.
>> >
>> >Thank you,
>> >John
>> >
>> >John David Sorkin M.D., Ph.D.
>> >Professor of Medicine, University of Maryland School of Medicine;
>> >Associate Director for Biostatistics and Informatics, Baltimore VA
>> Medical Center Geriatrics Research, Education, and Clinical Center;
>> >PI Biostatistics and Informatics Core, University of Maryland School of
>> Medicine Claude D. Pepper Older Americans Independence Center;
>> >Senior Statistician University of Maryland Center for Vascular Research;
>> >
>> >Division of Gerontology and Paliative Care,
>> >10 North Greene Street
>> >GRECC (BT/18/GR)
>> >Baltimore, MD 21201-1524
>> >Cell phone 443-418-5382
>> >
>> >
>> >
>> >
>> >________________________________________
>> >From: R-help <r-help-bounces at r-project.org> on behalf of Bert Gunter <
>> bgunter.4567 at gmail.com>
>> >Sent: Monday, January 6, 2025 5:22 PM
>> >To: Jorgen Harmse
>> >Cc: r-help at r-project.org
>> >Subject: Re: [R] Extracting specific arguments from "..."
>> >
>> >Thanks Jorgen.
>> >
>> >I thought your approach to getting the argument expressions was clever,
>> but
>> >somewhat convoluted. I think the usual simple way is to use match.call()
>> >(or sys.call() )to get the unevaluated argument expressions;  e.g. ...
>> >
>> >f <- function(...){
>> >   match.call()
>> >}
>> >> f(a = 'red', b = sin(zzz))
>> >f(a = "red", b = sin(zzz))
>> >
>> >The return value is an object of class call that can be subscripted as (or
>> >converted by as.list() to) a list to extract the argument expressions:
>> >> f(a = 'red', b = sin(zzz))$b
>> >sin(zzz)
>> >
>> >You'll note that the $b component is again of class "call". So you may
>> wish
>> >to convert it to character or expression or whatever for further
>> >processing, depending on context. Obviously, I haven't thought about this
>> >carefully.
>> >
>> >You raise an important point about robustness. I believe this approach to
>> >extracting the call expressions should be fairly robust, but I do get
>> >confused about the lay of the land when you add promises with default
>> >arguments that may not yet have been forced before match.call() is called.
>> >You may have to wrestle with sys.call() and it's "wh" argument to make
>> >things work the way you want in that situation. I leave such delights to
>> >wiser heads, as well as any corrections or refinements to anything that
>> >I've said here.
>> >
>> >Cheers,
>> >Bert
>> >
>> >On Mon, Jan 6, 2025 at 9:55?AM Jorgen Harmse <JHarmse at roku.com> wrote:
>> >
>> >> I think Bert Gunter is right, but do you want partial matches (not found
>> >> by match), and how robust do you want the code to be?
>> >>
>> >>
>> >>
>> >> f <- function(?)
>> >>
>> >> { pos <- match('a', ...names())
>> >>
>> >>   if (is.na(pos))
>> >>
>> >>     stop("a is required.")
>> >>
>> >>   ?elt(pos)
>> >>
>> >> }
>> >>
>> >>
>> >>
>> >> Incidentally, what is the best way to extract the expression without
>> >> evaluating it?
>> >>
>> >>
>> >>
>> >> g <- function(...)
>> >>
>> >> { pos <- match('a',...names())
>> >>
>> >>   if (is.na(pos))
>> >>
>> >>     stop("a is missing.")
>> >>
>> >>   (function(a,...) substitute(a)) (...)
>> >>
>> >> }
>> >>
>> >>
>> >>
>> >> Regards,
>> >>
>> >> Jorgen Harmse.
>> >>
>> >>
>> >>
>> >> Message: 8
>> >> Date: Sun, 5 Jan 2025 11:17:02 -0800
>> >> From: Bert Gunter <bgunter.4567 at gmail.com>
>> >> To: Iris Simmons <ikwsimmo at gmail.com>
>> >> Cc: R-help <R-help at r-project.org>
>> >> Subject: Re: [R] Extracting specific arguments from "..."
>> >> Message-ID:
>> >>         <
>> >> CAGxFJbROnopt-boDF6sRPP79bWUcPPOO3+ycDGN3y-YTDU5b6Q at mail.gmail.com>
>> >> Content-Type: text/plain; charset="utf-8"
>> >>
>> >> Thanks, Iris.
>> >> That is what I suspected, but it wasn't clear to me from the docs.
>> >>
>> >> Best,
>> >> Bert
>> >>
>> >> On Sun, Jan 5, 2025 at 10:16?AM Iris Simmons <ikwsimmo at gmail.com>
>> wrote:
>> >> >
>> >> > I would use two because it does not force the evaluation of the other
>> >> arguments in the ... list.
>> >> >
>> >> >
>> >> >
>> >> > On Sun, Jan 5, 2025, 13:00 Bert Gunter <bgunter.4567 at gmail.com>
>> wrote:
>> >> >>
>> >> >> Consider:
>> >> >>
>> >> >> f1 <- function(...){
>> >> >>   one <- list(...)[['a']]
>> >> >>   two <- ...elt(match('a', ...names()))
>> >> >>   c(one, two)
>> >> >> }
>> >> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> >> >> unknown position.
>> >> >>
>> >> >> > f1(b=5, a = 2, c=7)
>> >> >> [1] 2 2
>> >> >>
>> >> >> Which is better for extracting a specific named argument, one<- or
>> >> >> two<- ?  Or a third alternative that is better than both?
>> >> >> Comments and critiques welcome.
>> >> >>
>> >> >> Cheers,
>> >> >> Bert
>> >> >>
>> >> >> ______________________________________________
>> >> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> >> >> https://stat.ethz.ch/mailman/listinfo/r-help
>> >> >> PLEASE do read the posting guide
>> >> https://www.r-project.org/posting-guide.html
>> >> >> and provide commented, minimal, self-contained, reproducible code.
>> >>
>> >>
>> >>
>> >>
>> >
>> >        [[alternative HTML version deleted]]
>> >
>> >______________________________________________
>> >R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> >https://stat.ethz.ch/mailman/listinfo/r-help
>> >PLEASE do read the posting guide
>> https://www.r-project.org/posting-guide.html
>> >and provide commented, minimal, self-contained, reproducible code.
>> >______________________________________________
>> >R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> >https://stat.ethz.ch/mailman/listinfo/r-help
>> >PLEASE do read the posting guide
>> https://www.R-project.org/posting-guide.html
>> >and provide commented, minimal, self-contained, reproducible code.
>>
>> --
>> Sent from my phone. Please excuse my brevity.
>>

-- 
Sent from my phone. Please excuse my brevity.


From m||@nd_j @end|ng |rom hotm@||@com  Mon Jan  6 12:03:46 2025
From: m||@nd_j @end|ng |rom hotm@||@com (Miland Joshi)
Date: Mon, 6 Jan 2025 11:03:46 +0000
Subject: [R] Possible bug in direct.evidence.plot?
In-Reply-To: <CAGgJW74LDza5WL2FRXODpobe9GSTA1a5L04d3ODORwvBHHtKpg@mail.gmail.com>
References: <DB7PR09MB2506A927224E142AC89E9DFEF9172@DB7PR09MB2506.eurprd09.prod.outlook.com>
 <CAGgJW74LDza5WL2FRXODpobe9GSTA1a5L04d3ODORwvBHHtKpg@mail.gmail.com>
Message-ID: <DB7PR09MB2506480D2D7136FA27C7306EF9102@DB7PR09MB2506.eurprd09.prod.outlook.com>

Hello

In R when I looked at the class of nb1 I got:
> class(nb1)
[1] "netmetabin" "netmeta"

which suggests that netmeta might work but netmetabin may cause problems. I'll notify Mathias Harrer!

BW
Miland

________________________________
From: Eric Berger <ericjberger at gmail.com>
Sent: 06 January 2025 08:24
To: Miland Joshi <miland_j at hotmail.com>
Cc: r-help at R-project.org <r-help at r-project.org>
Subject: Re: [R] Possible bug in direct.evidence.plot?

The explanation is likely that class(x) returns a character vector of length > 1.
If you go into the code you can achieve what is probably intended without triggering this error by replacing that statement with the following:

if (inherits(x,"netmeta")) ...

HTH,
Eric


On Mon, Jan 6, 2025 at 9:57?AM Miland Joshi <miland_j at hotmail.com<mailto:miland_j at hotmail.com>> wrote:
I succeeded in getting netmetabin to work, but when trying to use direct.evidence.plot I ran into a problem:

> nb1evid <- direct.evidence.plot(nb1)
Error in if (class(x) != "netmeta") { : the condition has length > 1

I tried updating netmeta and dmetar (and dmetafor) from R, but the problem remains.
Has anyone come across this, and could it be a bug?

Regards
Miland Joshi

        [[alternative HTML version deleted]]

______________________________________________
R-help at r-project.org<mailto:R-help at r-project.org> mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.

	[[alternative HTML version deleted]]


From JH@rm@e @end|ng |rom roku@com  Tue Jan  7 19:47:11 2025
From: JH@rm@e @end|ng |rom roku@com (Jorgen Harmse)
Date: Tue, 7 Jan 2025 18:47:11 +0000
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
Message-ID: <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>

Interesting discussion. A few things occurred to me.

Apologies to Iris Simmons: I mixed up his answer with Bert's question.

Bert raises questions about promises, and I think they are related to John Sorkin's question. A big difference between R and most other languages is that function arguments are computed lazily. match.call & substitute tell us what expressions will be evaluated if function arguments are needed but not the environments in which that will happen. The usual suspects are environment() and parent.frame(), but parent.frame(k) & maybe even other environments are possible. If you are really determined then I guess you can keep evaluating match.call() in parent frames until you have accounted for all the inputs.

It's not clear to what extent John Sorkin is concerned about writing functions as opposed to using functions. Lazy computation has advantages but leads to some issues.
Exactly matching the function's default expression for an input is not necessarily the same as omitting the input. The evaluation environment is different.
If the caller uses an expression with side effects then there is no guarantee that the side effects will happen. If there are side effects from two or more inputs then the order is uncertain. (If an argument is not supplied and the default has side effects then they might not happen either. However, I don't know why the function writer would specify any side effect except stop(), and then he or she has probably arranged for it to happen exactly when it should.)
If a default value depends on another input and that input is modified inside the function then order of evaluation of inputs becomes important. Even if you know exactly what you're doing when you write the function, you should make it clear to future maintainers. An explicit call to force clarifies that the input needs to be computed with the existing values of anything that is used in the default, even if the code is refactored so that the value is not used immediately. If you really want to modify another input before evaluating the default then specify that in a comment.

Jeff Newmiller makes a good point. You can still change your mind about inspecting a particular input without breaking old code that uses your function, and you don?t necessarily need default values.

Old definition: f <- function(?) {<code that passes ? to other functions and does some other things>}

New definition:
f <- function(?, a = <default expression, possibly stop()>)
{ <pass ?, a=a to another function>
  <do something with the output>
}

OR

f <- function(?, a)
{ if (missing(a)) # OK, this becomes clunky if there are several such inputs
  { < pass ? to another function >}
  else
 { <inspect or modify a> # Pitfall: Changing the order of evaluation may break old code, but then the design was probably too devious in the first place.
    <pass ?, a=a to another function>
  }
  <do something with the output>
}

Regards,
Jorgen Harmse.




	[[alternative HTML version deleted]]


From j@ork|n @end|ng |rom @om@um@ry|@nd@edu  Tue Jan  7 23:03:02 2025
From: j@ork|n @end|ng |rom @om@um@ry|@nd@edu (Sorkin, John)
Date: Tue, 7 Jan 2025 22:03:02 +0000
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
 <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
Message-ID: <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>

Colleagues,

My interest is not in writing ad hoc functions (which I might use once to analyze my data), but rather what I will call a system function that might be part of a package. The lm function is a paradigm of what I call a system function. 

The lm function begins by processing the arguments passed to the function (represented in the function as parameters, see code below.) Much of this processing is only peripherally related to running a regression, but the code is necessary to determine exactly what the user of the system function wants the function to do. It would be helpful if there was a document that would describe best practices when writing system functions, with clear explanations of what each step in system function is designed to do and how the line accomplishes its task. It would also be nice if the system function had documentation. I have pushed my way through the lm function, and with the help of R help files, I have come to understand how the function works, but this is not an efficient way to learn best practices that should be used when writing a system function. 

Perhaps there is a document that does what I would like to see done, but I do not know of one.  

John

lmlm
function (formula, data, subset, weights, na.action, method = "qr",
    model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
    contrasts = NULL, offset, ...)
{
    ret.x <- x
    ret.y <- y
    cl <- match.call()
    mf <- match.call(expand.dots = FALSE)
    m <- match(c("formula", "data", "subset", "weights", "na.action",
        "offset"), names(mf), 0L)
    mf <- mf[c(1L, m)]
    mf$drop.unused.levels <- TRUE
    mf[[1L]] <- quote(stats::model.frame)
    mf <- eval(mf, parent.frame())
    if (method == "model.frame")
        return(mf)
    else if (method != "qr")
        warning(gettextf("method = '%s' is not supported. Using 'qr'",
            method), domain = NA)
    mt <- attr(mf, "terms")
    y <- model.response(mf, "numeric")
    w <- as.vector(model.weights(mf))
    if (!is.null(w) && !is.numeric(w))
        stop("'weights' must be a numeric vector")
    offset <- model.offset(mf)
    mlm <- is.matrix(y)
    ny <- if (mlm)
        nrow(y)
    else length(y)
    if (!is.null(offset)) {
        if (!mlm)
            offset <- as.vector(offset)
        if (NROW(offset) != ny)
            stop(gettextf("number of offsets is %d, should equal %d (number of observations)",
                NROW(offset), ny), domain = NA)
    }
    if (is.empty.model(mt)) {
        x <- NULL
        z <- list(coefficients = if (mlm) matrix(NA_real_, 0,
            ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
            y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w !=
            0) else ny)
        if (!is.null(offset)) {
            z$fitted.values <- offset
            z$residuals <- y - offset
        }
    }
    else {
        x <- model.matrix(mt, mf, contrasts)
        z <- if (is.null(w))
            lm.fit(x, y, offset = offset, singular.ok = singular.ok,
                ...)
        else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
            ...)
    }
    class(z) <- c(if (mlm) "mlm", "lm")
    z$na.action <- attr(mf, "na.action")
    z$offset <- offset
    z$contrasts <- attr(x, "contrasts")
    z$xlevels <- .getXlevels(mt, mf)
    z$call <- cl
    z$terms <- mt
    if (model)
        z$model <- mf
    if (ret.x)
        z$x <- x
    if (ret.y)
        z$y <- y
    if (!qr)
        z$qr <- NULL
    z
}



John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;?
PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




________________________________________
From: Jorgen Harmse <JHarmse at roku.com>
Sent: Tuesday, January 7, 2025 1:47 PM
To: r-help at r-project.org; ikwsimmo at gmail.com; Bert Gunter; Sorkin, John; jdnewmil at dcn.davis.ca.us
Subject: Re: Extracting specific arguments from "..."

Interesting discussion. A few things occurred to me.

Apologies to Iris Simmons: I mixed up his answer with Bert's question.

Bert raises questions about promises, and I think they are related to John Sorkin's question. A big difference between R and most other languages is that function arguments are computed lazily. match.call & substitute tell us what expressions will be evaluated if function arguments are needed but not the environments in which that will happen. The usual suspects are environment() and parent.frame(), but parent.frame(k) & maybe even other environments are possible. If you are really determined then I guess you can keep evaluating match.call() in parent frames until you have accounted for all the inputs.

It's not clear to what extent John Sorkin is concerned about writing functions as opposed to using functions. Lazy computation has advantages but leads to some issues.
Exactly matching the function's default expression for an input is not necessarily the same as omitting the input. The evaluation environment is different.
If the caller uses an expression with side effects then there is no guarantee that the side effects will happen. If there are side effects from two or more inputs then the order is uncertain. (If an argument is not supplied and the default has side effects then they might not happen either. However, I don't know why the function writer would specify any side effect except stop(), and then he or she has probably arranged for it to happen exactly when it should.)
If a default value depends on another input and that input is modified inside the function then order of evaluation of inputs becomes important. Even if you know exactly what you're doing when you write the function, you should make it clear to future maintainers. An explicit call to force clarifies that the input needs to be computed with the existing values of anything that is used in the default, even if the code is refactored so that the value is not used immediately. If you really want to modify another input before evaluating the default then specify that in a comment.

Jeff Newmiller makes a good point. You can still change your mind about inspecting a particular input without breaking old code that uses your function, and you don?t necessarily need default values.

Old definition: f <- function(?) {<code that passes ? to other functions and does some other things>}

New definition:
f <- function(?, a = <default expression, possibly stop()>)
{ <pass ?, a=a to another function>
  <do something with the output>
}

OR

f <- function(?, a)
{ if (missing(a)) # OK, this becomes clunky if there are several such inputs
  { < pass ? to another function >}
  else
 { <inspect or modify a> # Pitfall: Changing the order of evaluation may break old code, but then the design was probably too devious in the first place.
    <pass ?, a=a to another function>
  }
  <do something with the output>
}

Regards,
Jorgen Harmse.





From bbo|ker @end|ng |rom gm@||@com  Tue Jan  7 23:06:08 2025
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Tue, 7 Jan 2025 17:06:08 -0500
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
 <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
 <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <719c700b-f706-458c-8e4e-8cc223c8b5df@gmail.com>


   There's an ancient (2003) document on the CRAN "developers' page" 
https://developer.r-project.org/model-fitting-functions.html that is 
sort of (but not exactly) what you're looking for ...


On 2025-01-07 5:03 p.m., Sorkin, John wrote:
> Colleagues,
> 
> My interest is not in writing ad hoc functions (which I might use once to analyze my data), but rather what I will call a system function that might be part of a package. The lm function is a paradigm of what I call a system function.
> 
> The lm function begins by processing the arguments passed to the function (represented in the function as parameters, see code below.) Much of this processing is only peripherally related to running a regression, but the code is necessary to determine exactly what the user of the system function wants the function to do. It would be helpful if there was a document that would describe best practices when writing system functions, with clear explanations of what each step in system function is designed to do and how the line accomplishes its task. It would also be nice if the system function had documentation. I have pushed my way through the lm function, and with the help of R help files, I have come to understand how the function works, but this is not an efficient way to learn best practices that should be used when writing a system function.
> 
> Perhaps there is a document that does what I would like to see done, but I do not know of one.
> 
> John
> 
> lmlm
> function (formula, data, subset, weights, na.action, method = "qr",
>      model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
>      contrasts = NULL, offset, ...)
> {
>      ret.x <- x
>      ret.y <- y
>      cl <- match.call()
>      mf <- match.call(expand.dots = FALSE)
>      m <- match(c("formula", "data", "subset", "weights", "na.action",
>          "offset"), names(mf), 0L)
>      mf <- mf[c(1L, m)]
>      mf$drop.unused.levels <- TRUE
>      mf[[1L]] <- quote(stats::model.frame)
>      mf <- eval(mf, parent.frame())
>      if (method == "model.frame")
>          return(mf)
>      else if (method != "qr")
>          warning(gettextf("method = '%s' is not supported. Using 'qr'",
>              method), domain = NA)
>      mt <- attr(mf, "terms")
>      y <- model.response(mf, "numeric")
>      w <- as.vector(model.weights(mf))
>      if (!is.null(w) && !is.numeric(w))
>          stop("'weights' must be a numeric vector")
>      offset <- model.offset(mf)
>      mlm <- is.matrix(y)
>      ny <- if (mlm)
>          nrow(y)
>      else length(y)
>      if (!is.null(offset)) {
>          if (!mlm)
>              offset <- as.vector(offset)
>          if (NROW(offset) != ny)
>              stop(gettextf("number of offsets is %d, should equal %d (number of observations)",
>                  NROW(offset), ny), domain = NA)
>      }
>      if (is.empty.model(mt)) {
>          x <- NULL
>          z <- list(coefficients = if (mlm) matrix(NA_real_, 0,
>              ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
>              y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w !=
>              0) else ny)
>          if (!is.null(offset)) {
>              z$fitted.values <- offset
>              z$residuals <- y - offset
>          }
>      }
>      else {
>          x <- model.matrix(mt, mf, contrasts)
>          z <- if (is.null(w))
>              lm.fit(x, y, offset = offset, singular.ok = singular.ok,
>                  ...)
>          else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
>              ...)
>      }
>      class(z) <- c(if (mlm) "mlm", "lm")
>      z$na.action <- attr(mf, "na.action")
>      z$offset <- offset
>      z$contrasts <- attr(x, "contrasts")
>      z$xlevels <- .getXlevels(mt, mf)
>      z$call <- cl
>      z$terms <- mt
>      if (model)
>          z$model <- mf
>      if (ret.x)
>          z$x <- x
>      if (ret.y)
>          z$y <- y
>      if (!qr)
>          z$qr <- NULL
>      z
> }
> 
> 
> 
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
> 
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
> 
> 
> 
> 
> ________________________________________
> From: Jorgen Harmse <JHarmse at roku.com>
> Sent: Tuesday, January 7, 2025 1:47 PM
> To: r-help at r-project.org; ikwsimmo at gmail.com; Bert Gunter; Sorkin, John; jdnewmil at dcn.davis.ca.us
> Subject: Re: Extracting specific arguments from "..."
> 
> Interesting discussion. A few things occurred to me.
> 
> Apologies to Iris Simmons: I mixed up his answer with Bert's question.
> 
> Bert raises questions about promises, and I think they are related to John Sorkin's question. A big difference between R and most other languages is that function arguments are computed lazily. match.call & substitute tell us what expressions will be evaluated if function arguments are needed but not the environments in which that will happen. The usual suspects are environment() and parent.frame(), but parent.frame(k) & maybe even other environments are possible. If you are really determined then I guess you can keep evaluating match.call() in parent frames until you have accounted for all the inputs.
> 
> It's not clear to what extent John Sorkin is concerned about writing functions as opposed to using functions. Lazy computation has advantages but leads to some issues.
> Exactly matching the function's default expression for an input is not necessarily the same as omitting the input. The evaluation environment is different.
> If the caller uses an expression with side effects then there is no guarantee that the side effects will happen. If there are side effects from two or more inputs then the order is uncertain. (If an argument is not supplied and the default has side effects then they might not happen either. However, I don't know why the function writer would specify any side effect except stop(), and then he or she has probably arranged for it to happen exactly when it should.)
> If a default value depends on another input and that input is modified inside the function then order of evaluation of inputs becomes important. Even if you know exactly what you're doing when you write the function, you should make it clear to future maintainers. An explicit call to force clarifies that the input needs to be computed with the existing values of anything that is used in the default, even if the code is refactored so that the value is not used immediately. If you really want to modify another input before evaluating the default then specify that in a comment.
> 
> Jeff Newmiller makes a good point. You can still change your mind about inspecting a particular input without breaking old code that uses your function, and you don?t necessarily need default values.
> 
> Old definition: f <- function(?) {<code that passes ? to other functions and does some other things>}
> 
> New definition:
> f <- function(?, a = <default expression, possibly stop()>)
> { <pass ?, a=a to another function>
>    <do something with the output>
> }
> 
> OR
> 
> f <- function(?, a)
> { if (missing(a)) # OK, this becomes clunky if there are several such inputs
>    { < pass ? to another function >}
>    else
>   { <inspect or modify a> # Pitfall: Changing the order of evaluation may break old code, but then the design was probably too devious in the first place.
>      <pass ?, a=a to another function>
>    }
>    <do something with the output>
> }
> 
> Regards,
> Jorgen Harmse.
> 
> 
> 
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

-- 
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
 > E-mail is sent at my convenience; I don't expect replies outside of 
working hours.


From j@ork|n @end|ng |rom @om@um@ry|@nd@edu  Wed Jan  8 00:54:22 2025
From: j@ork|n @end|ng |rom @om@um@ry|@nd@edu (Sorkin, John)
Date: Tue, 7 Jan 2025 23:54:22 +0000
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <719c700b-f706-458c-8e4e-8cc223c8b5df@gmail.com>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
 <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
 <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
 <719c700b-f706-458c-8e4e-8cc223c8b5df@gmail.com>
Message-ID: <DM6PR03MB504908006EC49D9E6C4809C2E2112@DM6PR03MB5049.namprd03.prod.outlook.com>

Ben,
As always, thank you.
You are correct, it is something like what I want, but not exactly. Perhaps someday someone will write a more complete guide.
Thank you,
John


John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




________________________________________
From: R-help <r-help-bounces at r-project.org> on behalf of Ben Bolker <bbolker at gmail.com>
Sent: Tuesday, January 7, 2025 5:06 PM
To: r-help at r-project.org
Subject: Re: [R] Extracting specific arguments from "..."


   There's an ancient (2003) document on the CRAN "developers' page"
https://developer.r-project.org/model-fitting-functions.html that is
sort of (but not exactly) what you're looking for ...


On 2025-01-07 5:03 p.m., Sorkin, John wrote:
> Colleagues,
>
> My interest is not in writing ad hoc functions (which I might use once to analyze my data), but rather what I will call a system function that might be part of a package. The lm function is a paradigm of what I call a system function.
>
> The lm function begins by processing the arguments passed to the function (represented in the function as parameters, see code below.) Much of this processing is only peripherally related to running a regression, but the code is necessary to determine exactly what the user of the system function wants the function to do. It would be helpful if there was a document that would describe best practices when writing system functions, with clear explanations of what each step in system function is designed to do and how the line accomplishes its task. It would also be nice if the system function had documentation. I have pushed my way through the lm function, and with the help of R help files, I have come to understand how the function works, but this is not an efficient way to learn best practices that should be used when writing a system function.
>
> Perhaps there is a document that does what I would like to see done, but I do not know of one.
>
> John
>
> lmlm
> function (formula, data, subset, weights, na.action, method = "qr",
>      model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
>      contrasts = NULL, offset, ...)
> {
>      ret.x <- x
>      ret.y <- y
>      cl <- match.call()
>      mf <- match.call(expand.dots = FALSE)
>      m <- match(c("formula", "data", "subset", "weights", "na.action",
>          "offset"), names(mf), 0L)
>      mf <- mf[c(1L, m)]
>      mf$drop.unused.levels <- TRUE
>      mf[[1L]] <- quote(stats::model.frame)
>      mf <- eval(mf, parent.frame())
>      if (method == "model.frame")
>          return(mf)
>      else if (method != "qr")
>          warning(gettextf("method = '%s' is not supported. Using 'qr'",
>              method), domain = NA)
>      mt <- attr(mf, "terms")
>      y <- model.response(mf, "numeric")
>      w <- as.vector(model.weights(mf))
>      if (!is.null(w) && !is.numeric(w))
>          stop("'weights' must be a numeric vector")
>      offset <- model.offset(mf)
>      mlm <- is.matrix(y)
>      ny <- if (mlm)
>          nrow(y)
>      else length(y)
>      if (!is.null(offset)) {
>          if (!mlm)
>              offset <- as.vector(offset)
>          if (NROW(offset) != ny)
>              stop(gettextf("number of offsets is %d, should equal %d (number of observations)",
>                  NROW(offset), ny), domain = NA)
>      }
>      if (is.empty.model(mt)) {
>          x <- NULL
>          z <- list(coefficients = if (mlm) matrix(NA_real_, 0,
>              ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
>              y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w !=
>              0) else ny)
>          if (!is.null(offset)) {
>              z$fitted.values <- offset
>              z$residuals <- y - offset
>          }
>      }
>      else {
>          x <- model.matrix(mt, mf, contrasts)
>          z <- if (is.null(w))
>              lm.fit(x, y, offset = offset, singular.ok = singular.ok,
>                  ...)
>          else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
>              ...)
>      }
>      class(z) <- c(if (mlm) "mlm", "lm")
>      z$na.action <- attr(mf, "na.action")
>      z$offset <- offset
>      z$contrasts <- attr(x, "contrasts")
>      z$xlevels <- .getXlevels(mt, mf)
>      z$call <- cl
>      z$terms <- mt
>      if (model)
>          z$model <- mf
>      if (ret.x)
>          z$x <- x
>      if (ret.y)
>          z$y <- y
>      if (!qr)
>          z$qr <- NULL
>      z
> }
>
>
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
>
> ________________________________________
> From: Jorgen Harmse <JHarmse at roku.com>
> Sent: Tuesday, January 7, 2025 1:47 PM
> To: r-help at r-project.org; ikwsimmo at gmail.com; Bert Gunter; Sorkin, John; jdnewmil at dcn.davis.ca.us
> Subject: Re: Extracting specific arguments from "..."
>
> Interesting discussion. A few things occurred to me.
>
> Apologies to Iris Simmons: I mixed up his answer with Bert's question.
>
> Bert raises questions about promises, and I think they are related to John Sorkin's question. A big difference between R and most other languages is that function arguments are computed lazily. match.call & substitute tell us what expressions will be evaluated if function arguments are needed but not the environments in which that will happen. The usual suspects are environment() and parent.frame(), but parent.frame(k) & maybe even other environments are possible. If you are really determined then I guess you can keep evaluating match.call() in parent frames until you have accounted for all the inputs.
>
> It's not clear to what extent John Sorkin is concerned about writing functions as opposed to using functions. Lazy computation has advantages but leads to some issues.
> Exactly matching the function's default expression for an input is not necessarily the same as omitting the input. The evaluation environment is different.
> If the caller uses an expression with side effects then there is no guarantee that the side effects will happen. If there are side effects from two or more inputs then the order is uncertain. (If an argument is not supplied and the default has side effects then they might not happen either. However, I don't know why the function writer would specify any side effect except stop(), and then he or she has probably arranged for it to happen exactly when it should.)
> If a default value depends on another input and that input is modified inside the function then order of evaluation of inputs becomes important. Even if you know exactly what you're doing when you write the function, you should make it clear to future maintainers. An explicit call to force clarifies that the input needs to be computed with the existing values of anything that is used in the default, even if the code is refactored so that the value is not used immediately. If you really want to modify another input before evaluating the default then specify that in a comment.
>
> Jeff Newmiller makes a good point. You can still change your mind about inspecting a particular input without breaking old code that uses your function, and you don?t necessarily need default values.
>
> Old definition: f <- function(?) {<code that passes ? to other functions and does some other things>}
>
> New definition:
> f <- function(?, a = <default expression, possibly stop()>)
> { <pass ?, a=a to another function>
>    <do something with the output>
> }
>
> OR
>
> f <- function(?, a)
> { if (missing(a)) # OK, this becomes clunky if there are several such inputs
>    { < pass ? to another function >}
>    else
>   { <inspect or modify a> # Pitfall: Changing the order of evaluation may break old code, but then the design was probably too devious in the first place.
>      <pass ?, a=a to another function>
>    }
>    <do something with the output>
> }
>
> Regards,
> Jorgen Harmse.
>
>
>
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

--
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
 > E-mail is sent at my convenience; I don't expect replies outside of
working hours.

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From @vi@e@gross m@iii@g oii gm@ii@com  Wed Jan  8 03:51:09 2025
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Tue, 7 Jan 2025 21:51:09 -0500
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <DM6PR03MB504908006EC49D9E6C4809C2E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
 <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
 <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
 <719c700b-f706-458c-8e4e-8cc223c8b5df@gmail.com>
 <DM6PR03MB504908006EC49D9E6C4809C2E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <00ae01db6178$2bcb11a0$836134e0$@gmail.com>

Like many things in R, the original way things were done may have ossified
in place and even if largely unknown packages came along, may not be known
by many.

The topic John is talking about is NOT in my mind about systems programming
at all. It is about writing any function where you want control over
evaluating arguments. There may be a better way from a programmers
perspective.

I can imagine a set of functions in a package that are well designed and
hide all the details so they can be easily used. I suspect aspects of what I
am talking about have been done. They could include some "logical" functions
that test if an option has been specified, or even if it is just the
default, without evaluating anything. Other functions would return a
specified argument. Yet others would remove a specified argument so further
evaluation does not see it, including removing it from ... so that in the
end, you can pass along a reduced ... to other functions you call.

I understand some R evaluations can be tricky or even have side effects. But
something better than what I have seen seems quite possible.

Other languages have variants such as getopt() that are a tad different but
quite useful.

-----Original Message-----
From: R-help <r-help-bounces at r-project.org> On Behalf Of Sorkin, John
Sent: Tuesday, January 7, 2025 6:54 PM
To: Ben Bolker <bbolker at gmail.com>; r-help at r-project.org
Subject: Re: [R] Extracting specific arguments from "..."

Ben,
As always, thank you.
You are correct, it is something like what I want, but not exactly. Perhaps
someday someone will write a more complete guide.
Thank you,
John


John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical
Center Geriatrics Research, Education, and Clinical Center;
PI Biostatistics and Informatics Core, University of Maryland School of
Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




________________________________________
From: R-help <r-help-bounces at r-project.org> on behalf of Ben Bolker
<bbolker at gmail.com>
Sent: Tuesday, January 7, 2025 5:06 PM
To: r-help at r-project.org
Subject: Re: [R] Extracting specific arguments from "..."


   There's an ancient (2003) document on the CRAN "developers' page"
https://developer.r-project.org/model-fitting-functions.html that is
sort of (but not exactly) what you're looking for ...


On 2025-01-07 5:03 p.m., Sorkin, John wrote:
> Colleagues,
>
> My interest is not in writing ad hoc functions (which I might use once to
analyze my data), but rather what I will call a system function that might
be part of a package. The lm function is a paradigm of what I call a system
function.
>
> The lm function begins by processing the arguments passed to the function
(represented in the function as parameters, see code below.) Much of this
processing is only peripherally related to running a regression, but the
code is necessary to determine exactly what the user of the system function
wants the function to do. It would be helpful if there was a document that
would describe best practices when writing system functions, with clear
explanations of what each step in system function is designed to do and how
the line accomplishes its task. It would also be nice if the system function
had documentation. I have pushed my way through the lm function, and with
the help of R help files, I have come to understand how the function works,
but this is not an efficient way to learn best practices that should be used
when writing a system function.
>
> Perhaps there is a document that does what I would like to see done, but I
do not know of one.
>
> John
>
> lmlm
> function (formula, data, subset, weights, na.action, method = "qr",
>      model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
>      contrasts = NULL, offset, ...)
> {
>      ret.x <- x
>      ret.y <- y
>      cl <- match.call()
>      mf <- match.call(expand.dots = FALSE)
>      m <- match(c("formula", "data", "subset", "weights", "na.action",
>          "offset"), names(mf), 0L)
>      mf <- mf[c(1L, m)]
>      mf$drop.unused.levels <- TRUE
>      mf[[1L]] <- quote(stats::model.frame)
>      mf <- eval(mf, parent.frame())
>      if (method == "model.frame")
>          return(mf)
>      else if (method != "qr")
>          warning(gettextf("method = '%s' is not supported. Using 'qr'",
>              method), domain = NA)
>      mt <- attr(mf, "terms")
>      y <- model.response(mf, "numeric")
>      w <- as.vector(model.weights(mf))
>      if (!is.null(w) && !is.numeric(w))
>          stop("'weights' must be a numeric vector")
>      offset <- model.offset(mf)
>      mlm <- is.matrix(y)
>      ny <- if (mlm)
>          nrow(y)
>      else length(y)
>      if (!is.null(offset)) {
>          if (!mlm)
>              offset <- as.vector(offset)
>          if (NROW(offset) != ny)
>              stop(gettextf("number of offsets is %d, should equal %d
(number of observations)",
>                  NROW(offset), ny), domain = NA)
>      }
>      if (is.empty.model(mt)) {
>          x <- NULL
>          z <- list(coefficients = if (mlm) matrix(NA_real_, 0,
>              ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
>              y, weights = w, rank = 0L, df.residual = if (!is.null(w))
sum(w !=
>              0) else ny)
>          if (!is.null(offset)) {
>              z$fitted.values <- offset
>              z$residuals <- y - offset
>          }
>      }
>      else {
>          x <- model.matrix(mt, mf, contrasts)
>          z <- if (is.null(w))
>              lm.fit(x, y, offset = offset, singular.ok = singular.ok,
>                  ...)
>          else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
>              ...)
>      }
>      class(z) <- c(if (mlm) "mlm", "lm")
>      z$na.action <- attr(mf, "na.action")
>      z$offset <- offset
>      z$contrasts <- attr(x, "contrasts")
>      z$xlevels <- .getXlevels(mt, mf)
>      z$call <- cl
>      z$terms <- mt
>      if (model)
>          z$model <- mf
>      if (ret.x)
>          z$x <- x
>      if (ret.y)
>          z$y <- y
>      if (!qr)
>          z$qr <- NULL
>      z
> }
>
>
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical
Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of
Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
>
> ________________________________________
> From: Jorgen Harmse <JHarmse at roku.com>
> Sent: Tuesday, January 7, 2025 1:47 PM
> To: r-help at r-project.org; ikwsimmo at gmail.com; Bert Gunter; Sorkin, John;
jdnewmil at dcn.davis.ca.us
> Subject: Re: Extracting specific arguments from "..."
>
> Interesting discussion. A few things occurred to me.
>
> Apologies to Iris Simmons: I mixed up his answer with Bert's question.
>
> Bert raises questions about promises, and I think they are related to John
Sorkin's question. A big difference between R and most other languages is
that function arguments are computed lazily. match.call & substitute tell us
what expressions will be evaluated if function arguments are needed but not
the environments in which that will happen. The usual suspects are
environment() and parent.frame(), but parent.frame(k) & maybe even other
environments are possible. If you are really determined then I guess you can
keep evaluating match.call() in parent frames until you have accounted for
all the inputs.
>
> It's not clear to what extent John Sorkin is concerned about writing
functions as opposed to using functions. Lazy computation has advantages but
leads to some issues.
> Exactly matching the function's default expression for an input is not
necessarily the same as omitting the input. The evaluation environment is
different.
> If the caller uses an expression with side effects then there is no
guarantee that the side effects will happen. If there are side effects from
two or more inputs then the order is uncertain. (If an argument is not
supplied and the default has side effects then they might not happen either.
However, I don't know why the function writer would specify any side effect
except stop(), and then he or she has probably arranged for it to happen
exactly when it should.)
> If a default value depends on another input and that input is modified
inside the function then order of evaluation of inputs becomes important.
Even if you know exactly what you're doing when you write the function, you
should make it clear to future maintainers. An explicit call to force
clarifies that the input needs to be computed with the existing values of
anything that is used in the default, even if the code is refactored so that
the value is not used immediately. If you really want to modify another
input before evaluating the default then specify that in a comment.
>
> Jeff Newmiller makes a good point. You can still change your mind about
inspecting a particular input without breaking old code that uses your
function, and you don't necessarily need default values.
>
> Old definition: f <- function(.) {<code that passes . to other functions
and does some other things>}
>
> New definition:
> f <- function(., a = <default expression, possibly stop()>)
> { <pass ., a=a to another function>
>    <do something with the output>
> }
>
> OR
>
> f <- function(., a)
> { if (missing(a)) # OK, this becomes clunky if there are several such
inputs
>    { < pass . to another function >}
>    else
>   { <inspect or modify a> # Pitfall: Changing the order of evaluation may
break old code, but then the design was probably too devious in the first
place.
>      <pass ., a=a to another function>
>    }
>    <do something with the output>
> }
>
> Regards,
> Jorgen Harmse.
>
>
>
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
https://www.r-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

--
Dr. Benjamin Bolker
Professor, Mathematics & Statistics and Biology, McMaster University
Director, School of Computational Science and Engineering
 > E-mail is sent at my convenience; I don't expect replies outside of
working hours.

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide
https://www.r-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide
https://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Wed Jan  8 11:21:40 2025
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Wed, 8 Jan 2025 11:21:40 +0100
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <mailman.372436.1.1736247601.33267.r-help@r-project.org>
 <BL0PR01MB4434F6B61D60E865E24E05A3DC112@BL0PR01MB4434.prod.exchangelabs.com>
 <DM6PR03MB5049EC581893884BD33D10E8E2112@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <26494.20916.648344.868223@stat.math.ethz.ch>

>>>>> Sorkin, John 
>>>>>     on Tue, 7 Jan 2025 22:03:02 +0000 writes:

    > Colleagues,
    > My interest is not in writing ad hoc functions (which I might use once to analyze my data), but rather what I will call a system function that might be part of a package. The lm function is a paradigm of what I call a system function. 

    > The lm function begins by processing the arguments passed to the function (represented in the function as parameters, see code below.) Much of this processing is only peripherally related to running a regression, but the code is necessary to determine exactly what the user of the system function wants the function to do. It would be helpful if there was a document that would describe best practices when writing system functions, with clear explanations of what each step in system function is designed to do and how the line accomplishes its task. It would also be nice if the system function had documentation. I have pushed my way through the lm function, and with the help of R help files, I have come to understand how the function works, but this is not an efficient way to learn best practices that should be used when writing a system function. 

    > Perhaps there is a document that does what I would like to see done, but I do not know of one.  

    > John

Note that the following is *not* the source of the lm() function, but a
print out to your console of what has become from the original source.
Notably all comments *and* all original author formatting has
been lost (as the "system functions" are *not* installed with
     	   something like options(keep.source = TRUE)).

For a long time, many have strongly advised to use the source
(e.g. https://en.wiktionary.org/wiki/UTSL   "Use The Source, Luke!")
instead. Here's the always latest (development / R-devel) source
for lm() *and* related functions ... also with comments etc:
  --> https://svn.r-project.org/R/trunk/src/library/stats/R/lm.R

(or you use one of its github mirrors ..)

Martin


    > lm

    > function (formula, data, subset, weights, na.action, method = "qr",
    > model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
    > contrasts = NULL, offset, ...)
    > {
    > ret.x <- x
    > ret.y <- y
    > cl <- match.call()
    > mf <- match.call(expand.dots = FALSE)
    > m <- match(c("formula", "data", "subset", "weights", "na.action",
    > "offset"), names(mf), 0L)
    > mf <- mf[c(1L, m)]
    > mf$drop.unused.levels <- TRUE
    > mf[[1L]] <- quote(stats::model.frame)
    > mf <- eval(mf, parent.frame())
    > if (method == "model.frame")
    > return(mf)
    > else if (method != "qr")
    > warning(gettextf("method = '%s' is not supported. Using 'qr'",
    > method), domain = NA)
    > mt <- attr(mf, "terms")
    > y <- model.response(mf, "numeric")
    > w <- as.vector(model.weights(mf))
    > if (!is.null(w) && !is.numeric(w))
    > stop("'weights' must be a numeric vector")
    > offset <- model.offset(mf)
    > mlm <- is.matrix(y)
    > ny <- if (mlm)
    > nrow(y)
    > else length(y)
    > if (!is.null(offset)) {
    > if (!mlm)
    > offset <- as.vector(offset)
    > if (NROW(offset) != ny)
    > stop(gettextf("number of offsets is %d, should equal %d (number of observations)",
    > NROW(offset), ny), domain = NA)
    > }
    > if (is.empty.model(mt)) {
    > x <- NULL
    > z <- list(coefficients = if (mlm) matrix(NA_real_, 0,
    > ncol(y)) else numeric(), residuals = y, fitted.values = 0 *
    > y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w !=
    > 0) else ny)
    > if (!is.null(offset)) {
    > z$fitted.values <- offset
    > z$residuals <- y - offset
    > }
    > }
    > else {
    > x <- model.matrix(mt, mf, contrasts)
    > z <- if (is.null(w))
    > lm.fit(x, y, offset = offset, singular.ok = singular.ok,
    > ...)
    > else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok,
    > ...)
    > }
    > class(z) <- c(if (mlm) "mlm", "lm")
    > z$na.action <- attr(mf, "na.action")
    > z$offset <- offset
    > z$contrasts <- attr(x, "contrasts")
    > z$xlevels <- .getXlevels(mt, mf)
    > z$call <- cl
    > z$terms <- mt
    > if (model)
    > z$model <- mf
    > if (ret.x)
    > z$x <- x
    > if (ret.y)
    > z$y <- y
    > if (!qr)
    > z$qr <- NULL
    > z
    > }



    > John David Sorkin M.D., Ph.D.
    > Professor of Medicine, University of Maryland School of Medicine;
    > Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;?
    > PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
    > Senior Statistician University of Maryland Center for Vascular Research;

    > Division of Gerontology and Paliative Care,
    > 10 North Greene Street
    > GRECC (BT/18/GR)
    > Baltimore, MD 21201-1524
    > Cell phone 443-418-5382




    > ________________________________________
    > From: Jorgen Harmse <JHarmse at roku.com>
    > Sent: Tuesday, January 7, 2025 1:47 PM
    > To: r-help at r-project.org; ikwsimmo at gmail.com; Bert Gunter; Sorkin, John; jdnewmil at dcn.davis.ca.us
    > Subject: Re: Extracting specific arguments from "..."

    > Interesting discussion. A few things occurred to me.

    > Apologies to Iris Simmons: I mixed up his answer with Bert's question.

    > Bert raises questions about promises, and I think they are related to John Sorkin's question. A big difference between R and most other languages is that function arguments are computed lazily. match.call & substitute tell us what expressions will be evaluated if function arguments are needed but not the environments in which that will happen. The usual suspects are environment() and parent.frame(), but parent.frame(k) & maybe even other environments are possible. If you are really determined then I guess you can keep evaluating match.call() in parent frames until you have accounted for all the inputs.

    > It's not clear to what extent John Sorkin is concerned about writing functions as opposed to using functions. Lazy computation has advantages but leads to some issues.
    > Exactly matching the function's default expression for an input is not necessarily the same as omitting the input. The evaluation environment is different.
    > If the caller uses an expression with side effects then there is no guarantee that the side effects will happen. If there are side effects from two or more inputs then the order is uncertain. (If an argument is not supplied and the default has side effects then they might not happen either. However, I don't know why the function writer would specify any side effect except stop(), and then he or she has probably arranged for it to happen exactly when it should.)
    > If a default value depends on another input and that input is modified inside the function then order of evaluation of inputs becomes important. Even if you know exactly what you're doing when you write the function, you should make it clear to future maintainers. An explicit call to force clarifies that the input needs to be computed with the existing values of anything that is used in the default, even if the code is refactored so that the value is not used immediately. If you really want to modify another input before evaluating the default then specify that in a comment.

    > Jeff Newmiller makes a good point. You can still change your mind about inspecting a particular input without breaking old code that uses your function, and you don?t necessarily need default values.

    > Old definition: f <- function(?) {<code that passes ? to other functions and does some other things>}

    > New definition:
    > f <- function(?, a = <default expression, possibly stop()>)
    > { <pass ?, a=a to another function>
    > <do something with the output>
    > }

    > OR

    > f <- function(?, a)
    > { if (missing(a)) # OK, this becomes clunky if there are several such inputs
    > { < pass ? to another function >}
    > else
    > { <inspect or modify a> # Pitfall: Changing the order of evaluation may break old code, but then the design was probably too devious in the first place.
    > <pass ?, a=a to another function>
    > }
    > <do something with the output>
    > }

    > Regards,
    > Jorgen Harmse.




    > ______________________________________________
    > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
    > https://stat.ethz.ch/mailman/listinfo/r-help
    > PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
    > and provide commented, minimal, self-contained, reproducible code.


From h@w|ckh@m @end|ng |rom gm@||@com  Wed Jan  8 21:50:53 2025
From: h@w|ckh@m @end|ng |rom gm@||@com (Hadley Wickham)
Date: Wed, 8 Jan 2025 14:50:53 -0600
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
Message-ID: <CABdHhvHVOBfmTFbDOeApBh0=vt9QYH86=a4xNvjK+BbQL1i5YQ@mail.gmail.com>

I'd propose an alternative that I think is superior: rely on the semantics
of ... to do the work for you:

f1 <- function(...){
  one <- list(...)[['a']]
  two <- ...elt(match('a', ...names()))
  c(one, two, three(...))
}

three <- function(a, ...) {
  a
}

f1(a = 1, b = 2, c = 3)
#> [1] 1 1 1


On Sun, Jan 5, 2025 at 12:00?PM Bert Gunter <bgunter.4567 at gmail.com> wrote:

> Consider:
>
> f1 <- function(...){
>   one <- list(...)[['a']]
>   two <- ...elt(match('a', ...names()))
>   c(one, two)
> }
> ## Here "..." is an argument list with "a" somewhere in it, but in an
> unknown position.
>
> > f1(b=5, a = 2, c=7)
> [1] 2 2
>
> Which is better for extracting a specific named argument, one<- or
> two<- ?  Or a third alternative that is better than both?
> Comments and critiques welcome.
>
> Cheers,
> Bert
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


-- 
http://hadley.nz

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Wed Jan  8 23:57:36 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Wed, 8 Jan 2025 14:57:36 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CABdHhvHVOBfmTFbDOeApBh0=vt9QYH86=a4xNvjK+BbQL1i5YQ@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
 <CABdHhvHVOBfmTFbDOeApBh0=vt9QYH86=a4xNvjK+BbQL1i5YQ@mail.gmail.com>
Message-ID: <CAGxFJbTdpmyGKEB5L2Rj3AuW3uZ1wv=XQAhCZkvsDojx=2csRA@mail.gmail.com>

That's very nice, Hadley. Simple and clean. Never would have thought of it
myself.

As usual, however, in the course of my churnings, I have a further
complication to add. But first ...

**TO ALL**: Feel free to ignore the following, as I'm just fooling around
here and don't want to waste your time with my stupid stuff.

Anyway, the complication is motivated by the use of formals() or otherwise
that *programmatically* generates a character representation of the
arguments I want to select. So, for example:

> z <- "a"
## Then:
f1 <- function(...){
    ...elt(match(z, ...names())) ## since z gets evaluated in the call
}
## still works.
> f1(b =2, a=1, c=3)
[1] 1

But I haven't figured out how to modify your suggestion -- at least in a
simple way -- to do the same. Likely I've missed something, though.


Cheers,
Bert






On Wed, Jan 8, 2025 at 12:51?PM Hadley Wickham <h.wickham at gmail.com> wrote:

> I'd propose an alternative that I think is superior: rely on the semantics
> of ... to do the work for you:
>
> f1 <- function(...){
>   one <- list(...)[['a']]
>   two <- ...elt(match('a', ...names()))
>   c(one, two, three(...))
> }
>
> three <- function(a, ...) {
>   a
> }
>
> f1(a = 1, b = 2, c = 3)
> #> [1] 1 1 1
>
>
> On Sun, Jan 5, 2025 at 12:00?PM Bert Gunter <bgunter.4567 at gmail.com>
> wrote:
>
>> Consider:
>>
>> f1 <- function(...){
>>   one <- list(...)[['a']]
>>   two <- ...elt(match('a', ...names()))
>>   c(one, two)
>> }
>> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> unknown position.
>>
>> > f1(b=5, a = 2, c=7)
>> [1] 2 2
>>
>> Which is better for extracting a specific named argument, one<- or
>> two<- ?  Or a third alternative that is better than both?
>> Comments and critiques welcome.
>>
>> Cheers,
>> Bert
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide
>> https://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>>
>
>
> --
> http://hadley.nz
>

	[[alternative HTML version deleted]]


From |@n@|@rm @end|ng |rom m@|ne@edu  Thu Jan  9 14:12:00 2025
From: |@n@|@rm @end|ng |rom m@|ne@edu (Ian Farm)
Date: Thu, 9 Jan 2025 08:12:00 -0500
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAGxFJbTdpmyGKEB5L2Rj3AuW3uZ1wv=XQAhCZkvsDojx=2csRA@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
 <CABdHhvHVOBfmTFbDOeApBh0=vt9QYH86=a4xNvjK+BbQL1i5YQ@mail.gmail.com>
 <CAGxFJbTdpmyGKEB5L2Rj3AuW3uZ1wv=XQAhCZkvsDojx=2csRA@mail.gmail.com>
Message-ID: <CAP8nD2xJhtwtYHR2yySFZoi=Uyo_mt=GOpjAr1yTrW=JLLvhLw@mail.gmail.com>

I might add that there seems to be a subtle difference between using
`...elt()` and `match.call()`, which is that the former causes `a` itself
to be evaluated while the latter doesn't:
```
# Some approaches that have been suggested:

# 1. Using `list()` (Bert Gunter)
f1 <- function(...) list(...)[["a"]]
# 2. Using `...elt()` (Bert Gunter)
f2 <- function(...) ...elt(match("a", ...names()))
# 3. Using argument matching (Hadley Wickham)
f3 <- function(...) (\(a, ...) a)(...)
# 4. Using `match.call()`
f4 <- function(...) eval(match.call()[["a"]], parent.frame())

ff <- list(f1 = f1, f2 = f2, f3 = f3, f4 = f4)

sapply(ff, \(f) {
  f(b = 2, a = 1, c = 3)
})
#> f1 f2 f3 f4
#>  1  1  1  1

# View the (defused) arguments after `a` has been accessed:

# returns an expression if the argument has not been evaluated, and a
number if it has
check_forced_args <- function(f) {
  body(f) <- call("{", body(f), quote(rlang::enexprs(...)))
  # pass `f()` some expressions to see which are evaluated
  f(a = cos(0), b = sqrt(4))
}
# make a data frame showing the defused arguments for each function
lapply(ff, check_forced_args) |> do.call(rbind, args = _) |> as.data.frame()

#>         a       b
#> f1      1       2    # all the arguments are forced
#> f2      1 sqrt(4)    # only `a` is forced
#> f3      1 sqrt(4)    # only `a` is forced
#> f4 cos(0) sqrt(4)    # none of the arguments are forced
```

Also, here's a possible way to adapt Hadley Wickham's approach so that it
takes the name of the argument as a string, though it does lose the
elegance:
```
pick_arg <- function(nm) {
  as.function(c(
    setNames(alist(. = , . = ), c(nm, "...")),
    as.symbol(nm)
  ))
}

z <- "a"
f5 <- function(...) {
  pick_arg(z)(...)
}
f5(b = 2, a = 1, c = 3)
#> [1] 1
```

Regards,
Ian
____
Ian Farm, Laboratory Manager
University of Maine Agroecology Lab


On Wed, Jan 8, 2025 at 5:58?PM Bert Gunter <bgunter.4567 at gmail.com> wrote:

> That's very nice, Hadley. Simple and clean. Never would have thought of it
> myself.
>
> As usual, however, in the course of my churnings, I have a further
> complication to add. But first ...
>
> **TO ALL**: Feel free to ignore the following, as I'm just fooling around
> here and don't want to waste your time with my stupid stuff.
>
> Anyway, the complication is motivated by the use of formals() or otherwise
> that *programmatically* generates a character representation of the
> arguments I want to select. So, for example:
>
> > z <- "a"
> ## Then:
> f1 <- function(...){
>     ...elt(match(z, ...names())) ## since z gets evaluated in the call
> }
> ## still works.
> > f1(b =2, a=1, c=3)
> [1] 1
>
> But I haven't figured out how to modify your suggestion -- at least in a
> simple way -- to do the same. Likely I've missed something, though.
>
>
> Cheers,
> Bert
>
>
>
>
>
>
> On Wed, Jan 8, 2025 at 12:51?PM Hadley Wickham <h.wickham at gmail.com>
> wrote:
>
> > I'd propose an alternative that I think is superior: rely on the
> semantics
> > of ... to do the work for you:
> >
> > f1 <- function(...){
> >   one <- list(...)[['a']]
> >   two <- ...elt(match('a', ...names()))
> >   c(one, two, three(...))
> > }
> >
> > three <- function(a, ...) {
> >   a
> > }
> >
> > f1(a = 1, b = 2, c = 3)
> > #> [1] 1 1 1
> >
> >
> > On Sun, Jan 5, 2025 at 12:00?PM Bert Gunter <bgunter.4567 at gmail.com>
> > wrote:
> >
> >> Consider:
> >>
> >> f1 <- function(...){
> >>   one <- list(...)[['a']]
> >>   two <- ...elt(match('a', ...names()))
> >>   c(one, two)
> >> }
> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
> >> unknown position.
> >>
> >> > f1(b=5, a = 2, c=7)
> >> [1] 2 2
> >>
> >> Which is better for extracting a specific named argument, one<- or
> >> two<- ?  Or a third alternative that is better than both?
> >> Comments and critiques welcome.
> >>
> >> Cheers,
> >> Bert
> >>
> >> ______________________________________________
> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> PLEASE do read the posting guide
> >> https://www.R-project.org/posting-guide.html
> >> and provide commented, minimal, self-contained, reproducible code.
> >>
> >
> >
> > --
> > http://hadley.nz
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Thu Jan  9 21:59:07 2025
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Thu, 9 Jan 2025 12:59:07 -0800
Subject: [R] Extracting specific arguments from "..."
In-Reply-To: <CAP8nD2xJhtwtYHR2yySFZoi=Uyo_mt=GOpjAr1yTrW=JLLvhLw@mail.gmail.com>
References: <CAGxFJbQsHOnZStQwuJcrSTXxG-XBT1Z-7EckiRjuyLC+vDhoyg@mail.gmail.com>
 <CABdHhvHVOBfmTFbDOeApBh0=vt9QYH86=a4xNvjK+BbQL1i5YQ@mail.gmail.com>
 <CAGxFJbTdpmyGKEB5L2Rj3AuW3uZ1wv=XQAhCZkvsDojx=2csRA@mail.gmail.com>
 <CAP8nD2xJhtwtYHR2yySFZoi=Uyo_mt=GOpjAr1yTrW=JLLvhLw@mail.gmail.com>
Message-ID: <CAGxFJbTZe7qz0R58tROZqBAHeqUkbrqhDSFvu6LuowVBEkzqSA@mail.gmail.com>

Thanks Ian (and others),

Taking the advice of ?"..." (which I should have done at the outset ...
duhh!),  the following seems to be the simplest solution, adequate for my
needs at least:

f <- function(x, ...){
   lapply(seq_along(x), \(i)switch(x[i], ..., NA))
}

(the usual argument checking etc. should be added, of course.)

Comparing this to the ...xx() functions that I previously gave, which are
the same as names(list(...)) etc. without the overhead of unnecessary
evaluation, gives:

g <- function(...){
   one <- f(z,...)
   two <- lapply(charmatch(z, ...names()), \(i)...elt(i))
  list(one = one, two = two)
}

> k <- 5
> z <- c("a","c")
> g(b=2, a=1, c = k)
$one
$one[[1]]
[1] 1

$one[[2]]
[1] 5


$two
$two[[1]]
[1] 1

$two[[2]]
[1] 5

As always, corrections and comments welcomed.

Cheers,
Bert



On Thu, Jan 9, 2025 at 5:12?AM Ian Farm <ian.farm at maine.edu> wrote:

> I might add that there seems to be a subtle difference between using
> `...elt()` and `match.call()`, which is that the former causes `a` itself
> to be evaluated while the latter doesn't:
> ```
> # Some approaches that have been suggested:
>
> # 1. Using `list()` (Bert Gunter)
> f1 <- function(...) list(...)[["a"]]
> # 2. Using `...elt()` (Bert Gunter)
> f2 <- function(...) ...elt(match("a", ...names()))
> # 3. Using argument matching (Hadley Wickham)
> f3 <- function(...) (\(a, ...) a)(...)
> # 4. Using `match.call()`
> f4 <- function(...) eval(match.call()[["a"]], parent.frame())
>
> ff <- list(f1 = f1, f2 = f2, f3 = f3, f4 = f4)
>
> sapply(ff, \(f) {
>   f(b = 2, a = 1, c = 3)
> })
> #> f1 f2 f3 f4
> #>  1  1  1  1
>
> # View the (defused) arguments after `a` has been accessed:
>
> # returns an expression if the argument has not been evaluated, and a
> number if it has
> check_forced_args <- function(f) {
>   body(f) <- call("{", body(f), quote(rlang::enexprs(...)))
>   # pass `f()` some expressions to see which are evaluated
>   f(a = cos(0), b = sqrt(4))
> }
> # make a data frame showing the defused arguments for each function
> lapply(ff, check_forced_args) |> do.call(rbind, args = _) |>
> as.data.frame()
>
> #>         a       b
> #> f1      1       2    # all the arguments are forced
> #> f2      1 sqrt(4)    # only `a` is forced
> #> f3      1 sqrt(4)    # only `a` is forced
> #> f4 cos(0) sqrt(4)    # none of the arguments are forced
> ```
>
> Also, here's a possible way to adapt Hadley Wickham's approach so that it
> takes the name of the argument as a string, though it does lose the
> elegance:
> ```
> pick_arg <- function(nm) {
>   as.function(c(
>     setNames(alist(. = , . = ), c(nm, "...")),
>     as.symbol(nm)
>   ))
> }
>
> z <- "a"
> f5 <- function(...) {
>   pick_arg(z)(...)
> }
> f5(b = 2, a = 1, c = 3)
> #> [1] 1
> ```
>
> Regards,
> Ian
> ____
> Ian Farm, Laboratory Manager
> University of Maine Agroecology Lab
>
>
> On Wed, Jan 8, 2025 at 5:58?PM Bert Gunter <bgunter.4567 at gmail.com> wrote:
>
>> That's very nice, Hadley. Simple and clean. Never would have thought of it
>> myself.
>>
>> As usual, however, in the course of my churnings, I have a further
>> complication to add. But first ...
>>
>> **TO ALL**: Feel free to ignore the following, as I'm just fooling around
>> here and don't want to waste your time with my stupid stuff.
>>
>> Anyway, the complication is motivated by the use of formals() or otherwise
>> that *programmatically* generates a character representation of the
>> arguments I want to select. So, for example:
>>
>> > z <- "a"
>> ## Then:
>> f1 <- function(...){
>>     ...elt(match(z, ...names())) ## since z gets evaluated in the call
>> }
>> ## still works.
>> > f1(b =2, a=1, c=3)
>> [1] 1
>>
>> But I haven't figured out how to modify your suggestion -- at least in a
>> simple way -- to do the same. Likely I've missed something, though.
>>
>>
>> Cheers,
>> Bert
>>
>>
>>
>>
>>
>>
>> On Wed, Jan 8, 2025 at 12:51?PM Hadley Wickham <h.wickham at gmail.com>
>> wrote:
>>
>> > I'd propose an alternative that I think is superior: rely on the
>> semantics
>> > of ... to do the work for you:
>> >
>> > f1 <- function(...){
>> >   one <- list(...)[['a']]
>> >   two <- ...elt(match('a', ...names()))
>> >   c(one, two, three(...))
>> > }
>> >
>> > three <- function(a, ...) {
>> >   a
>> > }
>> >
>> > f1(a = 1, b = 2, c = 3)
>> > #> [1] 1 1 1
>> >
>> >
>> > On Sun, Jan 5, 2025 at 12:00?PM Bert Gunter <bgunter.4567 at gmail.com>
>> > wrote:
>> >
>> >> Consider:
>> >>
>> >> f1 <- function(...){
>> >>   one <- list(...)[['a']]
>> >>   two <- ...elt(match('a', ...names()))
>> >>   c(one, two)
>> >> }
>> >> ## Here "..." is an argument list with "a" somewhere in it, but in an
>> >> unknown position.
>> >>
>> >> > f1(b=5, a = 2, c=7)
>> >> [1] 2 2
>> >>
>> >> Which is better for extracting a specific named argument, one<- or
>> >> two<- ?  Or a third alternative that is better than both?
>> >> Comments and critiques welcome.
>> >>
>> >> Cheers,
>> >> Bert
>> >>
>> >> ______________________________________________
>> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> >> https://stat.ethz.ch/mailman/listinfo/r-help
>> >> PLEASE do read the posting guide
>> >> https://www.R-project.org/posting-guide.html
>> >> and provide commented, minimal, self-contained, reproducible code.
>> >>
>> >
>> >
>> > --
>> > http://hadley.nz
>> >
>>
>>         [[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide
>> https://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>>
>

	[[alternative HTML version deleted]]


