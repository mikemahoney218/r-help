From j@ork|n @end|ng |rom @om@um@ry|@nd@edu  Sun Dec  1 03:27:29 2024
From: j@ork|n @end|ng |rom @om@um@ry|@nd@edu (Sorkin, John)
Date: Sun, 1 Dec 2024 02:27:29 +0000
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
Message-ID: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>

Dear R help folks,

First my apologizes for sending several related questions to the list server. I am trying to learn how to manipulate data in R . . . and am having difficulty getting my program to work. I greatly appreciate the help and support list member give!

I am trying to write a program that will run through a data frame organized by ID and for the first line of each new group of data lines that has the same ID create a new variable first that will be 1 for the first line of the group and 0 for all other lines.

e.g. if my original data is 
 olddata
   ID date
    1     1
    1     1
    1     2
    1     2
    1     3
    1     3
    1     4
    1     4
    1     5
    1     5
    2     5
    2     5
    2     5
    2     6
    2     6
    2     6
    3   10
    3   10

the new data will be
newdata
   ID date  first
    1     1       1
    1     1       0
    1     2       0
    1     2       0
    1     3       0
    1     3       0
    1     4       0
    1     4       0
    1     5       0
    1     5       0
    2     5       1
    2     5       0
    2     5       0
    2     6       0
    2     6       0
    2     6       0
    3   10       1
    3   10       0

When I run the program below, I receive the following error:
Error in df[, "ID"] : incorrect number of dimensions

My code:
# Create data.frame
ID <- c(rep(1,10),rep(2,6),rep(3,2))
date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
          rep(5,3),rep(6,3),rep(10,2))
olddata <- data.frame(ID=ID,date=date)
class(olddata)
cat("This is the original data frame","\n")
print(olddata)
 
# This function is supposed to identify the first row 
# within each level of ID and, for the first row, set
# the variable first to 1, and for all rows other than
# the first row set first to 0.
mydoit <- function(df){
  value <- ifelse (first(df[,"ID"]),1,0)
  cat("value=",value,"\n")
  df[,"first"] <- value
}
newdata <- aggregate(olddata,list(olddata[,"ID"]),mydoit)

Thank you,
John


John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;?
PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




From bbo|ker @end|ng |rom gm@||@com  Sun Dec  1 03:35:38 2024
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Sat, 30 Nov 2024 21:35:38 -0500
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <CABghstS905fhe3rLmbJtfBxDhzLcpqwmCD1jObsNhqVmTznkQw@mail.gmail.com>

I think as.numeric(! duplicated(group)) might do this for you ...

On Sat, Nov 30, 2024, 9:27 PM Sorkin, John <jsorkin at som.umaryland.edu>
wrote:

> Dear R help folks,
>
> First my apologizes for sending several related questions to the list
> server. I am trying to learn how to manipulate data in R . . . and am
> having difficulty getting my program to work. I greatly appreciate the help
> and support list member give!
>
> I am trying to write a program that will run through a data frame
> organized by ID and for the first line of each new group of data lines that
> has the same ID create a new variable first that will be 1 for the first
> line of the group and 0 for all other lines.
>
> e.g. if my original data is
>  olddata
>    ID date
>     1     1
>     1     1
>     1     2
>     1     2
>     1     3
>     1     3
>     1     4
>     1     4
>     1     5
>     1     5
>     2     5
>     2     5
>     2     5
>     2     6
>     2     6
>     2     6
>     3   10
>     3   10
>
> the new data will be
> newdata
>    ID date  first
>     1     1       1
>     1     1       0
>     1     2       0
>     1     2       0
>     1     3       0
>     1     3       0
>     1     4       0
>     1     4       0
>     1     5       0
>     1     5       0
>     2     5       1
>     2     5       0
>     2     5       0
>     2     6       0
>     2     6       0
>     2     6       0
>     3   10       1
>     3   10       0
>
> When I run the program below, I receive the following error:
> Error in df[, "ID"] : incorrect number of dimensions
>
> My code:
> # Create data.frame
> ID <- c(rep(1,10),rep(2,6),rep(3,2))
> date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
>           rep(5,3),rep(6,3),rep(10,2))
> olddata <- data.frame(ID=ID,date=date)
> class(olddata)
> cat("This is the original data frame","\n")
> print(olddata)
>
> # This function is supposed to identify the first row
> # within each level of ID and, for the first row, set
> # the variable first to 1, and for all rows other than
> # the first row set first to 0.
> mydoit <- function(df){
>   value <- ifelse (first(df[,"ID"]),1,0)
>   cat("value=",value,"\n")
>   df[,"first"] <- value
> }
> newdata <- aggregate(olddata,list(olddata[,"ID"]),mydoit)
>
> Thank you,
> John
>
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical
> Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of
> Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> <https://www.google.com/maps/search/10+North+Greene+Street?entry=gmail&source=g>
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From cry@n @end|ng |rom b|ngh@mton@edu  Sun Dec  1 03:46:57 2024
From: cry@n @end|ng |rom b|ngh@mton@edu (Christopher W. Ryan)
Date: Sat, 30 Nov 2024 21:46:57 -0500
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <600b676e-9dab-8f64-e492-39ad4f4ca281@binghamton.edu>

Personally, I'd do this in the tidyverse with dplyr and its row_number()
function.

olddata %>% group_by(ID) %>% mutate(first = as.integer(row_number() == 1))

--Chris Ryan

Sorkin, John wrote:
> ID <- c(rep(1,10),rep(2,6),rep(3,2))
> date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
>           rep(5,3),rep(6,3),rep(10,2))
> olddata <- data.frame(ID=ID,date=date)


From cry@n @end|ng |rom b|ngh@mton@edu  Sun Dec  1 03:51:48 2024
From: cry@n @end|ng |rom b|ngh@mton@edu (Christopher W. Ryan)
Date: Sat, 30 Nov 2024 21:51:48 -0500
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <600b676e-9dab-8f64-e492-39ad4f4ca281@binghamton.edu>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
 <600b676e-9dab-8f64-e492-39ad4f4ca281@binghamton.edu>
Message-ID: <f2250299-b8b5-a8a5-aacb-3779e51c397c@binghamton.edu>

Sorry, for completeness:

library(dplyr)
olddata %>% group_by(ID) %>% mutate(first = as.integer(row_number() == 1))

--Chris Ryan


Christopher W. Ryan wrote:
> Personally, I'd do this in the tidyverse with dplyr and its row_number()
> function.
> 
> olddata %>% group_by(ID) %>% mutate(first = as.integer(row_number() == 1))
> 
> --Chris Ryan
> 
> Sorkin, John wrote:
>> ID <- c(rep(1,10),rep(2,6),rep(3,2))
>> date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
>>           rep(5,3),rep(6,3),rep(10,2))
>> olddata <- data.frame(ID=ID,date=date)


From rmh @end|ng |rom temp|e@edu  Sun Dec  1 04:54:47 2024
From: rmh @end|ng |rom temp|e@edu (Richard M. Heiberger)
Date: Sun, 1 Dec 2024 03:54:47 +0000
Subject: [R] 
 [External]  Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <ACBADD34-16BF-4F7F-99BC-3D1DE568CD48@temple.edu>

tmp.ID <- unique(olddata$ID)
Firsts <- match(tmp.ID, olddata$ID)
newdata <- cbind(olddata, First=0)
newdata$First[Firsts] <- 1
newdata

newdata$FirstDay <- 0
for (id in tmp.ID)
  newdata$FirstDay[newdata$ID == id] <- newdata$date[newdata$ID == id][1]
newdata


> On Nov 30, 2024, at 21:27, Sorkin, John <jsorkin at som.umaryland.edu> wrote:
>
> Dear R help folks,
>
> First my apologizes for sending several related questions to the list server. I am trying to learn how to manipulate data in R . . . and am having difficulty getting my program to work. I greatly appreciate the help and support list member give!
>
> I am trying to write a program that will run through a data frame organized by ID and for the first line of each new group of data lines that has the same ID create a new variable first that will be 1 for the first line of the group and 0 for all other lines.
>
> e.g. if my original data is
> olddata
>   ID date
>    1     1
>    1     1
>    1     2
>    1     2
>    1     3
>    1     3
>    1     4
>    1     4
>    1     5
>    1     5
>    2     5
>    2     5
>    2     5
>    2     6
>    2     6
>    2     6
>    3   10
>    3   10
>
> the new data will be
> newdata
>   ID date  first
>    1     1       1
>    1     1       0
>    1     2       0
>    1     2       0
>    1     3       0
>    1     3       0
>    1     4       0
>    1     4       0
>    1     5       0
>    1     5       0
>    2     5       1
>    2     5       0
>    2     5       0
>    2     6       0
>    2     6       0
>    2     6       0
>    3   10       1
>    3   10       0
>
> When I run the program below, I receive the following error:
> Error in df[, "ID"] : incorrect number of dimensions
>
> My code:
> # Create data.frame
> ID <- c(rep(1,10),rep(2,6),rep(3,2))
> date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
>          rep(5,3),rep(6,3),rep(10,2))
> olddata <- data.frame(ID=ID,date=date)
> class(olddata)
> cat("This is the original data frame","\n")
> print(olddata)
>
> # This function is supposed to identify the first row
> # within each level of ID and, for the first row, set
> # the variable first to 1, and for all rows other than
> # the first row set first to 0.
> mydoit <- function(df){
>  value <- ifelse (first(df[,"ID"]),1,0)
>  cat("value=",value,"\n")
>  df[,"first"] <- value
> }
> newdata <- aggregate(olddata,list(olddata[,"ID"]),mydoit)
>
> Thank you,
> John
>
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From bgunter@4567 @end|ng |rom gm@||@com  Sun Dec  1 05:33:42 2024
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Sat, 30 Nov 2024 20:33:42 -0800
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <CAGxFJbQzXRAQzgnyS7QTiN3ewCkLiMvpJb6AiEhTp4EvstesHw@mail.gmail.com>

May I ask *why* you want to do this?

It sounds to me like like you're using SAS-like strategies for your
data analysis rather than R-like.

-- Bert

-- Bert

On Sat, Nov 30, 2024 at 6:27?PM Sorkin, John <jsorkin at som.umaryland.edu> wrote:
>
> Dear R help folks,
>
> First my apologizes for sending several related questions to the list server. I am trying to learn how to manipulate data in R . . . and am having difficulty getting my program to work. I greatly appreciate the help and support list member give!
>
> I am trying to write a program that will run through a data frame organized by ID and for the first line of each new group of data lines that has the same ID create a new variable first that will be 1 for the first line of the group and 0 for all other lines.
>
> e.g. if my original data is
>  olddata
>    ID date
>     1     1
>     1     1
>     1     2
>     1     2
>     1     3
>     1     3
>     1     4
>     1     4
>     1     5
>     1     5
>     2     5
>     2     5
>     2     5
>     2     6
>     2     6
>     2     6
>     3   10
>     3   10
>
> the new data will be
> newdata
>    ID date  first
>     1     1       1
>     1     1       0
>     1     2       0
>     1     2       0
>     1     3       0
>     1     3       0
>     1     4       0
>     1     4       0
>     1     5       0
>     1     5       0
>     2     5       1
>     2     5       0
>     2     5       0
>     2     6       0
>     2     6       0
>     2     6       0
>     3   10       1
>     3   10       0
>
> When I run the program below, I receive the following error:
> Error in df[, "ID"] : incorrect number of dimensions
>
> My code:
> # Create data.frame
> ID <- c(rep(1,10),rep(2,6),rep(3,2))
> date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
>           rep(5,3),rep(6,3),rep(10,2))
> olddata <- data.frame(ID=ID,date=date)
> class(olddata)
> cat("This is the original data frame","\n")
> print(olddata)
>
> # This function is supposed to identify the first row
> # within each level of ID and, for the first row, set
> # the variable first to 1, and for all rows other than
> # the first row set first to 0.
> mydoit <- function(df){
>   value <- ifelse (first(df[,"ID"]),1,0)
>   cat("value=",value,"\n")
>   df[,"first"] <- value
> }
> newdata <- aggregate(olddata,list(olddata[,"ID"]),mydoit)
>
> Thank you,
> John
>
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From @vi@e@gross m@iii@g oii gm@ii@com  Sun Dec  1 07:18:09 2024
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Sun, 1 Dec 2024 01:18:09 -0500
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <CAGxFJbQzXRAQzgnyS7QTiN3ewCkLiMvpJb6AiEhTp4EvstesHw@mail.gmail.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
 <CAGxFJbQzXRAQzgnyS7QTiN3ewCkLiMvpJb6AiEhTp4EvstesHw@mail.gmail.com>
Message-ID: <010901db43b8$cb3408b0$619c1a10$@gmail.com>

I was wondering along similar lines, Bert.

One way to get help is to ask how to do some single step of a larger strategy. That can lead to answers that may not be as applicable to the scenario.

Another way would be to include a synopsis of what they are trying to do.

But, as John says he is trying to learn and improve his abilities, perhaps he s getting what he wants.
After watching some of the exchanges in multiple questions, many seem to revolve around a wish to deal with sorted grouped data. He seems to have looked at some base R methods as well as packages like dplyr using tibbles as well as another package and format.

What interests me from a dplyr perspective is how many little embedded functions it makes available and some have been mentioned here. If you want to  add a column that contains the same value for each group, such as the minimum, mean, first and many other things, it is very easily doable.

The latest request seems to be a bit different as it wants a column with a 1 (presumably for TRUE) only for the first entry in  the group. Again, fairly easy using one of several hooks such as the rownumber being "1" versus not. There are many variations on the answer supplied depending on style and need, such as making a column that contains the row number, and in a later step, set those to zero that are not a one. 

But sometimes you want to ask what the overall algorithm is. Do you need extra columns to then use for some purpose, or could that purpose have been done another way such as doing some calculation only when rownumber is one.

As noted, R makes some operations fairly natural, in ways that differ from the "natural" way another program/environment does it. Sometimes a translation is not worth doing as compared to a reworked algorithm that makes good use of whichever package and related functionality you want to use. 

Assuming all these questions relate to the same project, I am not clear if and where the lookback at previous row/value fits.

Of course, John may not be free to share more in public.

Anyone want to suggest a book or two on data processing of this sort using R that might illustrate with examples galore on how various problems are solved and then perhaps some will be similar enough ...

-----Original Message-----
From: R-help <r-help-bounces at r-project.org> On Behalf Of Bert Gunter
Sent: Saturday, November 30, 2024 11:34 PM
To: Sorkin, John <jsorkin at som.umaryland.edu>
Cc: r-help at r-project.org (r-help at r-project.org) <r-help at r-project.org>
Subject: Re: [R] Identify first row of each ID within a data frame, create a variable first =1 for the first row and first=0 of all other rows

May I ask *why* you want to do this?

It sounds to me like like you're using SAS-like strategies for your
data analysis rather than R-like.

-- Bert

-- Bert

On Sat, Nov 30, 2024 at 6:27?PM Sorkin, John <jsorkin at som.umaryland.edu> wrote:
>
> Dear R help folks,
>
> First my apologizes for sending several related questions to the list server. I am trying to learn how to manipulate data in R . . . and am having difficulty getting my program to work. I greatly appreciate the help and support list member give!
>
> I am trying to write a program that will run through a data frame organized by ID and for the first line of each new group of data lines that has the same ID create a new variable first that will be 1 for the first line of the group and 0 for all other lines.
>
> e.g. if my original data is
>  olddata
>    ID date
>     1     1
>     1     1
>     1     2
>     1     2
>     1     3
>     1     3
>     1     4
>     1     4
>     1     5
>     1     5
>     2     5
>     2     5
>     2     5
>     2     6
>     2     6
>     2     6
>     3   10
>     3   10
>
> the new data will be
> newdata
>    ID date  first
>     1     1       1
>     1     1       0
>     1     2       0
>     1     2       0
>     1     3       0
>     1     3       0
>     1     4       0
>     1     4       0
>     1     5       0
>     1     5       0
>     2     5       1
>     2     5       0
>     2     5       0
>     2     6       0
>     2     6       0
>     2     6       0
>     3   10       1
>     3   10       0
>
> When I run the program below, I receive the following error:
> Error in df[, "ID"] : incorrect number of dimensions
>
> My code:
> # Create data.frame
> ID <- c(rep(1,10),rep(2,6),rep(3,2))
> date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
>           rep(5,3),rep(6,3),rep(10,2))
> olddata <- data.frame(ID=ID,date=date)
> class(olddata)
> cat("This is the original data frame","\n")
> print(olddata)
>
> # This function is supposed to identify the first row
> # within each level of ID and, for the first row, set
> # the variable first to 1, and for all rows other than
> # the first row set first to 0.
> mydoit <- function(df){
>   value <- ifelse (first(df[,"ID"]),1,0)
>   cat("value=",value,"\n")
>   df[,"first"] <- value
> }
> newdata <- aggregate(olddata,list(olddata[,"ID"]),mydoit)
>
> Thank you,
> John
>
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Sun Dec  1 08:05:24 2024
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Sun, 1 Dec 2024 07:05:24 +0000
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <b888c330-de36-4a00-aeff-b38385baa085@sapo.pt>

?s 02:27 de 01/12/2024, Sorkin, John escreveu:
> Dear R help folks,
> 
> First my apologizes for sending several related questions to the list server. I am trying to learn how to manipulate data in R . . . and am having difficulty getting my program to work. I greatly appreciate the help and support list member give!
> 
> I am trying to write a program that will run through a data frame organized by ID and for the first line of each new group of data lines that has the same ID create a new variable first that will be 1 for the first line of the group and 0 for all other lines.
> 
> e.g. if my original data is
>   olddata
>     ID date
>      1     1
>      1     1
>      1     2
>      1     2
>      1     3
>      1     3
>      1     4
>      1     4
>      1     5
>      1     5
>      2     5
>      2     5
>      2     5
>      2     6
>      2     6
>      2     6
>      3   10
>      3   10
> 
> the new data will be
> newdata
>     ID date  first
>      1     1       1
>      1     1       0
>      1     2       0
>      1     2       0
>      1     3       0
>      1     3       0
>      1     4       0
>      1     4       0
>      1     5       0
>      1     5       0
>      2     5       1
>      2     5       0
>      2     5       0
>      2     6       0
>      2     6       0
>      2     6       0
>      3   10       1
>      3   10       0
> 
> When I run the program below, I receive the following error:
> Error in df[, "ID"] : incorrect number of dimensions
> 
> My code:
> # Create data.frame
> ID <- c(rep(1,10),rep(2,6),rep(3,2))
> date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
>            rep(5,3),rep(6,3),rep(10,2))
> olddata <- data.frame(ID=ID,date=date)
> class(olddata)
> cat("This is the original data frame","\n")
> print(olddata)
>   
> # This function is supposed to identify the first row
> # within each level of ID and, for the first row, set
> # the variable first to 1, and for all rows other than
> # the first row set first to 0.
> mydoit <- function(df){
>    value <- ifelse (first(df[,"ID"]),1,0)
>    cat("value=",value,"\n")
>    df[,"first"] <- value
> }
> newdata <- aggregate(olddata,list(olddata[,"ID"]),mydoit)
> 
> Thank you,
> John
> 
> 
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI?Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
> 
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
> 
> 
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
Hello,

And here are two other solutions.


olddata$first <- with(olddata, ave(seq_along(ID), ID, FUN = \(x) x == 
x[1L]))

olddata$first <- c(1L, diff(olddata$ID))


Of these two, diff is faster. But of all the solutions posted so far, 
Ben Bolker's is the fastest. And it can be made a little faster if 
as.integer substitutes for as.numeric.
And dplyr::mutate now has a .by argument, which avoids explicit the call 
to group_by, with a performance gain.


library(microbenchmark)

mb <- microbenchmark(
   ave = with(olddata, ave(seq_along(ID), ID, FUN = \(x) x == x[1L])),
   dup_num = as.numeric(! duplicated(olddata$ID)),
   dup_int = as.integer(! duplicated(olddata$ID)),
   diff = diff = c(1L, diff(olddata$ID)),
   dplyr_grp = olddata %>% group_by(ID) %>% mutate(first = 
as.integer(row_number() == 1)),
   dplyr = olddata %>% mutate(first = as.integer(row_number() == 1), .by 
= ID)
)
print(mb, order = "median")



However, note that dplyr operates in entire data.frames and therefore is 
expected to be slower when tested against instructions that process one 
column only.


Hope this helps,

Rui Barradas


-- 
Este e-mail foi analisado pelo software antiv?rus AVG para verificar a presen?a de v?rus.
www.avg.com


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Sun Dec  1 08:15:37 2024
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Sun, 1 Dec 2024 07:15:37 +0000
Subject: [R] dplyr summarize by groups
In-Reply-To: <005b01db3d6b$ed2288a0$c76799e0$@yahoo.com>
References: <005b01db3d6b$ed2288a0$c76799e0$.ref@yahoo.com>
 <005b01db3d6b$ed2288a0$c76799e0$@yahoo.com>
Message-ID: <d88925f6-9316-499a-b90b-46e38e696786@sapo.pt>

?s 05:52 de 23/11/2024, tgs77m--- via R-help escreveu:
> # Get mean, min, max sigma and skew by group
> 
>   options (digits = 3)
>   library (ISwR
> data(energy)
> 
> data %>%
>    group_by(stature) %>%
>    summarize(
>      Mean = mean(expend),
>      Min =  min(expend),
>      Max = max(expend),
>      Sigma = sd(expend),
>      Skew = skew(expend))
> 
> # Output
> 
>    stature  Mean   Min   Max Sigma  Skew
>    <fct>   <dbl> <dbl> <dbl> <dbl> <dbl>
> 1 lean     8.07  6.13  10.9  1.24 0.907
> 2 obese   10.3   8.79  12.8  1.40 0.587
> 
> Why does output stats vary in decimal places even when options (digits=3)
> were set?
> 
> All the best
> 
> Thomas S.
> 
> 
> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
Hello,


"Why does output stats vary in decimal places even when options 
(digits=3) were set?"

Yes, they do but shouldn't they? I'm seeing all numbers with 3 digits. 
Display digits and rounding are not the same thing.

Also, you don't need to load the package to have access to one of its 
data sets,


data(energy, package = "ISwR")


will load it. In this case, it's probably even better, "energy" is not 
an uncommon source for data and there might be data sets with the same 
name in other packages.


Hope this helps,

Rui Barradas




-- 
Este e-mail foi analisado pelo software antiv?rus AVG para verificar a presen?a de v?rus.
www.avg.com


From bor|@@@te|pe @end|ng |rom utoronto@c@  Sun Dec  1 13:46:06 2024
From: bor|@@@te|pe @end|ng |rom utoronto@c@ (Boris Steipe)
Date: Sun, 1 Dec 2024 12:46:06 +0000
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <FC7E5425-9A46-4C5D-92D9-2584ABE02A46@utoronto.ca>


olddata$first <- as.numeric(! duplicated(olddata$ID))


:-)




> On Nov 30, 2024, at 22:27, Sorkin, John <jsorkin at som.umaryland.edu> wrote:
> 
> ID <- c(rep(1,10),rep(2,6),rep(3,2))
> date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
>          rep(5,3),rep(6,3),rep(10,2))
> olddata <- data.frame(ID=ID,date=date)
> class(olddata)


From bgunter@4567 @end|ng |rom gm@||@com  Sun Dec  1 17:30:03 2024
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Sun, 1 Dec 2024 08:30:03 -0800
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <b888c330-de36-4a00-aeff-b38385baa085@sapo.pt>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
 <b888c330-de36-4a00-aeff-b38385baa085@sapo.pt>
Message-ID: <CAGxFJbTUEFgeeDXe0rpAe4EfGN8edJAC1oVSjMTKuat-iBkSww@mail.gmail.com>

Rui:
"f these two, diff is faster. But of all the solutions posted so far,
Ben Bolker's is the fastest."

But the explicit version of diff is still considerably faster:

> D <- c(rep(1,10),rep(2,6),rep(3,2))

> microbenchmark(c(1L,diff(D)), times = 1000L)
Unit: microseconds
           expr   min    lq    mean median    uq    max neval
 c(1L, diff(D)) 3.075 3.198 3.34396   3.28 3.362 29.684  1000

> microbenchmark( as.integer(!duplicated(D)), times =1000L)
Unit: microseconds
                       expr   min    lq     mean median   uq  max neval
 as.integer(!duplicated(D)) 1.476 1.558 1.644264  1.599 1.64 16.4  1000

> microbenchmark( D - c(0L, D[-length(D)]), times = 1000L)
Unit: nanoseconds  ## note that unit is nanoseconds not microseconds
                     expr min  lq    mean median  uq  max neval
 D - c(0L, D[-length(D)]) 369 410 489.335    492 533 9840  1000

Cheers,
Bert

On Sat, Nov 30, 2024 at 11:05?PM Rui Barradas <ruipbarradas at sapo.pt> wrote:
>
> ?s 02:27 de 01/12/2024, Sorkin, John escreveu:
> > Dear R help folks,
> >
> > First my apologizes for sending several related questions to the list server. I am trying to learn how to manipulate data in R . . . and am having difficulty getting my program to work. I greatly appreciate the help and support list member give!
> >
> > I am trying to write a program that will run through a data frame organized by ID and for the first line of each new group of data lines that has the same ID create a new variable first that will be 1 for the first line of the group and 0 for all other lines.
> >
> > e.g. if my original data is
> >   olddata
> >     ID date
> >      1     1
> >      1     1
> >      1     2
> >      1     2
> >      1     3
> >      1     3
> >      1     4
> >      1     4
> >      1     5
> >      1     5
> >      2     5
> >      2     5
> >      2     5
> >      2     6
> >      2     6
> >      2     6
> >      3   10
> >      3   10
> >
> > the new data will be
> > newdata
> >     ID date  first
> >      1     1       1
> >      1     1       0
> >      1     2       0
> >      1     2       0
> >      1     3       0
> >      1     3       0
> >      1     4       0
> >      1     4       0
> >      1     5       0
> >      1     5       0
> >      2     5       1
> >      2     5       0
> >      2     5       0
> >      2     6       0
> >      2     6       0
> >      2     6       0
> >      3   10       1
> >      3   10       0
> >
> > When I run the program below, I receive the following error:
> > Error in df[, "ID"] : incorrect number of dimensions
> >
> > My code:
> > # Create data.frame
> > ID <- c(rep(1,10),rep(2,6),rep(3,2))
> > date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
> >            rep(5,3),rep(6,3),rep(10,2))
> > olddata <- data.frame(ID=ID,date=date)
> > class(olddata)
> > cat("This is the original data frame","\n")
> > print(olddata)
> >
> > # This function is supposed to identify the first row
> > # within each level of ID and, for the first row, set
> > # the variable first to 1, and for all rows other than
> > # the first row set first to 0.
> > mydoit <- function(df){
> >    value <- ifelse (first(df[,"ID"]),1,0)
> >    cat("value=",value,"\n")
> >    df[,"first"] <- value
> > }
> > newdata <- aggregate(olddata,list(olddata[,"ID"]),mydoit)
> >
> > Thank you,
> > John
> >
> >
> > John David Sorkin M.D., Ph.D.
> > Professor of Medicine, University of Maryland School of Medicine;
> > Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> > PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> > Senior Statistician University of Maryland Center for Vascular Research;
> >
> > Division of Gerontology and Paliative Care,
> > 10 North Greene Street
> > GRECC (BT/18/GR)
> > Baltimore, MD 21201-1524
> > Cell phone 443-418-5382
> >
> >
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.
> Hello,
>
> And here are two other solutions.
>
>
> olddata$first <- with(olddata, ave(seq_along(ID), ID, FUN = \(x) x ==
> x[1L]))
>
> olddata$first <- c(1L, diff(olddata$ID))
>
>
> Of these two, diff is faster. But of all the solutions posted so far,
> Ben Bolker's is the fastest. And it can be made a little faster if
> as.integer substitutes for as.numeric.
> And dplyr::mutate now has a .by argument, which avoids explicit the call
> to group_by, with a performance gain.
>
>
> library(microbenchmark)
>
> mb <- microbenchmark(
>    ave = with(olddata, ave(seq_along(ID), ID, FUN = \(x) x == x[1L])),
>    dup_num = as.numeric(! duplicated(olddata$ID)),
>    dup_int = as.integer(! duplicated(olddata$ID)),
>    diff = diff = c(1L, diff(olddata$ID)),
>    dplyr_grp = olddata %>% group_by(ID) %>% mutate(first =
> as.integer(row_number() == 1)),
>    dplyr = olddata %>% mutate(first = as.integer(row_number() == 1), .by
> = ID)
> )
> print(mb, order = "median")
>
>
>
> However, note that dplyr operates in entire data.frames and therefore is
> expected to be slower when tested against instructions that process one
> column only.
>
>
> Hope this helps,
>
> Rui Barradas
>
>
> --
> Este e-mail foi analisado pelo software antiv?rus AVG para verificar a presen?a de v?rus.
> www.avg.com
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From bgunter@4567 @end|ng |rom gm@||@com  Mon Dec  2 06:43:45 2024
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Sun, 1 Dec 2024 21:43:45 -0800
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <DM6PR03MB5049F365BD14FF48597163E3E2352@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
 <CAGxFJbQzXRAQzgnyS7QTiN3ewCkLiMvpJb6AiEhTp4EvstesHw@mail.gmail.com>
 <DM6PR03MB5049F365BD14FF48597163E3E2352@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <CAGxFJbQ_YjZND6XFGgpA2fCOxWdw-zRwSTpr1OnZA-FsPxBW7A@mail.gmail.com>

OK.

(Note: I am ccing this to the list so that others can correct any
mistakes, misunderstandings, or misstatements that I may make; and
also give you more and better advice about how to proceed. For
example, there may be environmental packages ( see the environmetrics
task view, https://CRAN.R-project.org/view=Environmetrics) that
already do everything you want from your data source that someone else
could tell you about. Why reinvent the wheel if you don't have to? )

Unfortunately, you failed to show us the critical information
necessary to give you a definitive answer: the structure of a single
record. However, I will wing it based on your description and assume
that each record contains the following information something like
this: Latitude   Longitude  Date Time pm25 + other stuff maybe.  If
this is the case,

1) You do not need to sort anything. R has robust date-time
manipulation and computation capabilities to handle dates and times,
though in this case you only need dates. R knows all about how to
order dates and times.

2) You do not have to physically group your records according to
geographic location. R knows how to extract and manipulate groups
without this;

3) And as all you need is a daily average, you do not need to worry
about when days begin or end.

If this is a reasonably accurate interpretation of what needs to be
done, and your data are in a data frame called dat, then something
like the following will do it:
## First convert latitude and longitude into a single location factor, loc
dat$loc <- with(dat, paste0(Latitude, Longitude))

## you could also convert the latitude and longitude into actual
location names if you like; the "factor" data structure in R is one
simple way to do this, for example.

## Then a one liner in base R does what I think you want:
avgs <- aggregate(pm25 ~ loc + Date, FUN = mean, data = dat)

See ?aggregate for details. Note in particular that you can get
results simultaneously for several different pm's or whatevers. I
should also note that the so-called "Tidyverse" and "data.table"
groups of packages, and likely others, also can easily do these sorts
of things, though of course with different syntax, semantics, and
functionality, perhaps in ways that you might find simpler to master..
There are many good tutorials available for both base R and these
packages, but from my ignorant perspective, you need to first spend
some time to learn about R's basic data structures (factors, lists,
vectors, etc.) if you want to use R for serious data manipulation.
Finally, my best advice would be to forget about SAS if you wish to
use R. Trying to translate SAS paradigms into R is the devil's work.

Cheers,
Bert






On Sun, Dec 1, 2024 at 7:29?PM Sorkin, John <jsorkin at som.umaryland.edu> wrote:
>
> Bert, Avi:
>
> I stand accused of "using SAS-like strategies for your data analysis rather than R-like [analyses]." Although I am guilty, but I beg the court's mercy ;).  I have been a SAS programmer for more than 35 years. I have used R (and S-Plus) for about 20-years, but mostly for statistical analyses that required little or no data manipulation. I now need to use R for both statistical analyses and data manipulation and am trying to do in R what I can do easily is SAS.
>
> Here is a full description of my data manipulation problem:
> I have satellite data of airborne pollutants, obtained every 15-minutes over four-days from approximately 500 geographic areas=438 observations/4 days*500 geographic locations=approximately 250,000 individual observations. (I say approximately because I have slightly less than four-days data and I have slightly less than 500 geographic areas. The exact number of observations is of minor importance.)
>
> Each of the 500 geographic areas has a fixed longitude and latitude. Each of the 438 observations for each of the approximately 500 geographic areas has a date-time stamp. I need to compute average 24-hour pollutant (e.g. pm2.5) exposure for each day, across ALL 500 geographic areas. To accomplish this, I need to
>
> 1) Group data from each of the 500 geographic areas together
>
> 2) Within each geographic area order the observations by day and time
>         1) and 2) are easily accomplished using the R order function,
>       mydata<-mydata[order(mydata$lat_lon,mydata$Time),]
>
>  or SAS proc sort:
>         proc sort data=mydata;
>            by lat_lon daytime;  /* lat long is a string giving latitude and longitude */
>         run;
>
> 3) For each geographic area determine the records that mark the start and stop of each of the four days, let's say from 00:00 hrs to 23:59 hours, and create a variable, daynum that indicates the day number (valid values 1 to 4). I do not know how to accomplish this in R. This is the part of my analysis that I asked the R community to help me write. I know how this this can be easily done in SAS:
> * Arrange data date and time within each geographic region (i.e. lat_lon and daytime);
> proc sort data=mydata;
>   by lat_lon daytime;
> run;
>
> data mydata;
>   /* For each getgraphic area, each time a new record is run, keep the preceding value of daynum */
>   retain daynum;
>   set mydata;
>      by lat_lon daytime;
>   /* initialize daynum to 0 for first record from a given geographic location*/
>   if _n_ eq 1 then daynum=0;
>  /* Determine start of each day */
> mytime = timepart(daytime)  /* Extract time from date-time constant */
>   if mytime eq '00:00:00't then daynum=daynum+1; /* Increment daynum for each new day */
> run;
>
> 4) Get average value for a pollutant, pm25, by day across all 500 geographic areas. This is easily done in SAS using proc sort and proc means.
> proc sort data=mydata;
>   by daynum;
> run;
>
> * Get mean pm 2.5 by day accross all 500 geographic regions.;
> proc means data=mydata;
>   by daynum;
>   var pm25;
> run;
>
> If I can get step (3) above accomplished in R, I know how to accomplish step 4) in R using the by function:
> by(mydata[,"pm25"], mydata[,"daynum"],mean)
>
> I am trying to write the analysis described, and written in SAS, for 3) above in R. Please understand that I am fluent in SAS, and (except for straight forward analyses that require little or no data manipulation, where I am an intermediate programmer) i am an R tyro.
>
> Thank you for your help. My apologies for the long description of what I am trying to do. I sent this because you asked what I was trying to do and why I was doing it from the perspective of a SAS programmer rather than a matrix-based R programmer.
>
> John David Sorkin M.D., Ph.D.
> Professor of Medicine, University of Maryland School of Medicine;
> Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> Senior Statistician University of Maryland Center for Vascular Research;
>
> Division of Gerontology and Paliative Care,
> 10 North Greene Street
> GRECC (BT/18/GR)
> Baltimore, MD 21201-1524
> Cell phone 443-418-5382
>
>
>
>
> ________________________________________
> From: Bert Gunter <bgunter.4567 at gmail.com>
> Sent: Saturday, November 30, 2024 11:33 PM
> To: Sorkin, John
> Cc: r-help at r-project.org (r-help at r-project.org)
> Subject: Re: [R] Identify first row of each ID within a data frame, create a variable first =1 for the first row and first=0 of all other rows
>
> May I ask *why* you want to do this?
>
> It sounds to me like like you're using SAS-like strategies for your
> data analysis rather than R-like.
>
> -- Bert
>
> -- Bert
>
> On Sat, Nov 30, 2024 at 6:27?PM Sorkin, John <jsorkin at som.umaryland.edu> wrote:
> >
> > Dear R help folks,
> >
> > First my apologizes for sending several related questions to the list server. I am trying to learn how to manipulate data in R . . . and am having difficulty getting my program to work. I greatly appreciate the help and support list member give!
> >
> > I am trying to write a program that will run through a data frame organized by ID and for the first line of each new group of data lines that has the same ID create a new variable first that will be 1 for the first line of the group and 0 for all other lines.
> >
> > e.g. if my original data is
> >  olddata
> >    ID date
> >     1     1
> >     1     1
> >     1     2
> >     1     2
> >     1     3
> >     1     3
> >     1     4
> >     1     4
> >     1     5
> >     1     5
> >     2     5
> >     2     5
> >     2     5
> >     2     6
> >     2     6
> >     2     6
> >     3   10
> >     3   10
> >
> > the new data will be
> > newdata
> >    ID date  first
> >     1     1       1
> >     1     1       0
> >     1     2       0
> >     1     2       0
> >     1     3       0
> >     1     3       0
> >     1     4       0
> >     1     4       0
> >     1     5       0
> >     1     5       0
> >     2     5       1
> >     2     5       0
> >     2     5       0
> >     2     6       0
> >     2     6       0
> >     2     6       0
> >     3   10       1
> >     3   10       0
> >
> > When I run the program below, I receive the following error:
> > Error in df[, "ID"] : incorrect number of dimensions
> >
> > My code:
> > # Create data.frame
> > ID <- c(rep(1,10),rep(2,6),rep(3,2))
> > date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
> >           rep(5,3),rep(6,3),rep(10,2))
> > olddata <- data.frame(ID=ID,date=date)
> > class(olddata)
> > cat("This is the original data frame","\n")
> > print(olddata)
> >
> > # This function is supposed to identify the first row
> > # within each level of ID and, for the first row, set
> > # the variable first to 1, and for all rows other than
> > # the first row set first to 0.
> > mydoit <- function(df){
> >   value <- ifelse (first(df[,"ID"]),1,0)
> >   cat("value=",value,"\n")
> >   df[,"first"] <- value
> > }
> > newdata <- aggregate(olddata,list(olddata[,"ID"]),mydoit)
> >
> > Thank you,
> > John
> >
> >
> > John David Sorkin M.D., Ph.D.
> > Professor of Medicine, University of Maryland School of Medicine;
> > Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> > PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> > Senior Statistician University of Maryland Center for Vascular Research;
> >
> > Division of Gerontology and Paliative Care,
> > 10 North Greene Street
> > GRECC (BT/18/GR)
> > Baltimore, MD 21201-1524
> > Cell phone 443-418-5382
> >
> >
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.


From ro||turner @end|ng |rom po@teo@net  Mon Dec  2 07:47:20 2024
From: ro||turner @end|ng |rom po@teo@net (Rolf Turner)
Date: Mon,  2 Dec 2024 06:47:20 +0000
Subject: [R] Fortune nomination.
In-Reply-To: <CAGxFJbQ_YjZND6XFGgpA2fCOxWdw-zRwSTpr1OnZA-FsPxBW7A@mail.gmail.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
 <CAGxFJbQzXRAQzgnyS7QTiN3ewCkLiMvpJb6AiEhTp4EvstesHw@mail.gmail.com>
 <DM6PR03MB5049F365BD14FF48597163E3E2352@DM6PR03MB5049.namprd03.prod.outlook.com>
 <CAGxFJbQ_YjZND6XFGgpA2fCOxWdw-zRwSTpr1OnZA-FsPxBW7A@mail.gmail.com>
Message-ID: <20241202194720.3baf35af@new-hp>


On Sun, 1 Dec 2024 21:43:45 -0800
Bert Gunter <bgunter.4567 at gmail.com> wrote:


> Finally, my best advice would be to forget about SAS if you wish to
> use R. Trying to translate SAS paradigms into R is the devil's work.

cheers,

Rolf Turner

-- 
Honorary Research Fellow
Department of Statistics
University of Auckland
Stats. Dep't. (secretaries) phone:
         +64-9-373-7599 ext. 89622
Home phone: +64-9-480-4619


From @vi@e@gross m@iii@g oii gm@ii@com  Mon Dec  2 06:39:28 2024
From: @vi@e@gross m@iii@g oii gm@ii@com (@vi@e@gross m@iii@g oii gm@ii@com)
Date: Mon, 2 Dec 2024 00:39:28 -0500
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <DM6PR03MB50499E32539371619AB9CE39E2352@DM6PR03MB5049.namprd03.prod.outlook.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
 <b888c330-de36-4a00-aeff-b38385baa085@sapo.pt>
 <CAGxFJbTUEFgeeDXe0rpAe4EfGN8edJAC1oVSjMTKuat-iBkSww@mail.gmail.com>
 <DM6PR03MB50499E32539371619AB9CE39E2352@DM6PR03MB5049.namprd03.prod.outlook.com>
Message-ID: <000701db447c$8df72760$a9e57620$@gmail.com>

John,

Thanks for enlightening us so we better understand.

I won't argue with your wish to learn to do things in base R first. I started that way, myself, and found lots of the commands not particularly easy to fit into a single worldview. Many functions I read about were promptly forgotten, especially those without great documentation and not enough examples of real world usage.

This is why some packages that came later are important as they generally try to come up with a somewhat consistent set of tools that often are also faster and more flexible. There is often a set of reasons various packages are created in the first place to meet real needs. And, I note that some may be subtle. Original R was often inconsistent in the order of command arguments while the dplyr and other tidyverse command try as much as possible to make the first argument be the one normally passed through a pipeline. R fairly recently added a native pipe operator that may be faster than the magrittr pipe but in some ways makes some functionality harder. The rest of R has not really been changed to make using commands in pipelines easy.

You seem to have also looked at data.table and given you may have large amounts of data, it may be designed in ways that might also be beneficial.

But as I do not want to relearn lots of R functions I never use, I will bow out from further discussion as what I would offer these days would probably not be what you want.

My personal opinion is that proper use of R can actually be far easier and more flexible than you had with the proprietary software that may largely consist of canned reports often used.

I do want to point out a few things to consider.

When you go grouping, you may want to consider grouping (as well as sorting) by multipole variables. You mention a variable with about 500 possibilities and then another variable with an ID number but did not say the ID number was unique across them all. 

And, I want to note you may want to also look into testing the sanity of your data. That is a wide area too. Things like duplicates, for example.

I do not know how many steps you can handle but there are sometimes designs that make an algorithm work differently.

Consider your request to find  the first row in each grouping and add a column with a 1, and 0 for all others. If that is what you need, fine.

But, what if instead you just added a row number. Some rows would have a 1, and some may have a 2, 3, or 4.

When you wanted  to so something to just the rows with a 1, you can filter out a subset of the data easily enough or apply a command only to those rows. But if you want to test if any entry has more than 4 rows, this could allow you to detect an error. Other ideas might be possible if that is how the data was saved.

And, if it really is a 0/1 choice, fine, but consider the advantages or disadvantages of what you save in the new column. Storing a numeric or an int can take up space when storing a Boolean or TRUE/FALSE is what you need. R gives you lots of flexibility which perhaps you did not have to think about before.

All I know is that so much of what you want to do is easily enough done with a pipeline or two in dplyr. But this is your task and you choose what makes sense. It specializes in group analysis and generates reports and so on. It may not be how you think. 


-----Original Message-----
From: Sorkin, John <jsorkin at som.umaryland.edu> 
Sent: Sunday, December 1, 2024 11:19 PM
To: Bert Gunter <bgunter.4567 at gmail.com>; Rui Barradas <ruipbarradas at sapo.pt>; twoolman at ontargettek.com; tebert at ufl.edu; Bert Gunter <bgunter.4567 at gmail.com>; jdnewmil at dcn.davis.ca.us; avi.e.gross at gmail.com; therneau at mayo.edu; dwinsemius at comcast.net; tebert at ufl.edu; rmh at temple.edu; ken.knoblauch at inserm.fr; boris.steipe at utoronto.ca
Cc: r-help at r-project.org (r-help at r-project.org) <r-help at r-project.org>; kimmo.elo at uef.fi
Subject: Re: [R] Identify first row of each ID within a data frame, create a variable first =1 for the first row and first=0 of all other rows

Dear Colleagues,

I am grateful to all of you for helping me with my question, how to write R code that will identify the first row of each ID within a data frame, create a variable first=1 for the first row and first=0 for all repeats of the ID.

WOW!!!
I just saw Boris Steipe's answer to my question:
olddata$first <- as.numeric(! duplicated(olddata$ID))
The solution is elegant, short, easy to understand, and it uses base R! All important characteristics of a good solution, at least for me. While I want to learn solutions using packages that extend base R, I believe that a good programmer learns how to do something using the base language and once that is learned, explores way to solve a programing problem using advanced packages.

Each and every one of you (I hope I did not miss anyone in my list of email addresses) took the time to read my emails and respond to me. Your collective help is invaluable, and I am in your collect debt.

Many, many thanks,
John

John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




________________________________________
From: Bert Gunter <bgunter.4567 at gmail.com>
Sent: Sunday, December 1, 2024 11:30 AM
To: Rui Barradas
Cc: Sorkin, John; r-help at r-project.org (r-help at r-project.org)
Subject: Re: [R] Identify first row of each ID within a data frame, create a variable first =1 for the first row and first=0 of all other rows

Rui:
"f these two, diff is faster. But of all the solutions posted so far,
Ben Bolker's is the fastest."

But the explicit version of diff is still considerably faster:

> D <- c(rep(1,10),rep(2,6),rep(3,2))

> microbenchmark(c(1L,diff(D)), times = 1000L)
Unit: microseconds
           expr   min    lq    mean median    uq    max neval
 c(1L, diff(D)) 3.075 3.198 3.34396   3.28 3.362 29.684  1000

> microbenchmark( as.integer(!duplicated(D)), times =1000L)
Unit: microseconds
                       expr   min    lq     mean median   uq  max neval
 as.integer(!duplicated(D)) 1.476 1.558 1.644264  1.599 1.64 16.4  1000

> microbenchmark( D - c(0L, D[-length(D)]), times = 1000L)
Unit: nanoseconds  ## note that unit is nanoseconds not microseconds
                     expr min  lq    mean median  uq  max neval
 D - c(0L, D[-length(D)]) 369 410 489.335    492 533 9840  1000

Cheers,
Bert

On Sat, Nov 30, 2024 at 11:05?PM Rui Barradas <ruipbarradas at sapo.pt> wrote:
>
> ?s 02:27 de 01/12/2024, Sorkin, John escreveu:
> > Dear R help folks,
> >
> > First my apologizes for sending several related questions to the list server. I am trying to learn how to manipulate data in R . . . and am having difficulty getting my program to work. I greatly appreciate the help and support list member give!
> >
> > I am trying to write a program that will run through a data frame organized by ID and for the first line of each new group of data lines that has the same ID create a new variable first that will be 1 for the first line of the group and 0 for all other lines.
> >
> > e.g. if my original data is
> >   olddata
> >     ID date
> >      1     1
> >      1     1
> >      1     2
> >      1     2
> >      1     3
> >      1     3
> >      1     4
> >      1     4
> >      1     5
> >      1     5
> >      2     5
> >      2     5
> >      2     5
> >      2     6
> >      2     6
> >      2     6
> >      3   10
> >      3   10
> >
> > the new data will be
> > newdata
> >     ID date  first
> >      1     1       1
> >      1     1       0
> >      1     2       0
> >      1     2       0
> >      1     3       0
> >      1     3       0
> >      1     4       0
> >      1     4       0
> >      1     5       0
> >      1     5       0
> >      2     5       1
> >      2     5       0
> >      2     5       0
> >      2     6       0
> >      2     6       0
> >      2     6       0
> >      3   10       1
> >      3   10       0
> >
> > When I run the program below, I receive the following error:
> > Error in df[, "ID"] : incorrect number of dimensions
> >
> > My code:
> > # Create data.frame
> > ID <- c(rep(1,10),rep(2,6),rep(3,2))
> > date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
> >            rep(5,3),rep(6,3),rep(10,2))
> > olddata <- data.frame(ID=ID,date=date)
> > class(olddata)
> > cat("This is the original data frame","\n")
> > print(olddata)
> >
> > # This function is supposed to identify the first row
> > # within each level of ID and, for the first row, set
> > # the variable first to 1, and for all rows other than
> > # the first row set first to 0.
> > mydoit <- function(df){
> >    value <- ifelse (first(df[,"ID"]),1,0)
> >    cat("value=",value,"\n")
> >    df[,"first"] <- value
> > }
> > newdata <- aggregate(olddata,list(olddata[,"ID"]),mydoit)
> >
> > Thank you,
> > John
> >
> >
> > John David Sorkin M.D., Ph.D.
> > Professor of Medicine, University of Maryland School of Medicine;
> > Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> > PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> > Senior Statistician University of Maryland Center for Vascular Research;
> >
> > Division of Gerontology and Paliative Care,
> > 10 North Greene Street
> > GRECC (BT/18/GR)
> > Baltimore, MD 21201-1524
> > Cell phone 443-418-5382
> >
> >
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.
> Hello,
>
> And here are two other solutions.
>
>
> olddata$first <- with(olddata, ave(seq_along(ID), ID, FUN = \(x) x ==
> x[1L]))
>
> olddata$first <- c(1L, diff(olddata$ID))
>
>
> Of these two, diff is faster. But of all the solutions posted so far,
> Ben Bolker's is the fastest. And it can be made a little faster if
> as.integer substitutes for as.numeric.
> And dplyr::mutate now has a .by argument, which avoids explicit the call
> to group_by, with a performance gain.
>
>
> library(microbenchmark)
>
> mb <- microbenchmark(
>    ave = with(olddata, ave(seq_along(ID), ID, FUN = \(x) x == x[1L])),
>    dup_num = as.numeric(! duplicated(olddata$ID)),
>    dup_int = as.integer(! duplicated(olddata$ID)),
>    diff = diff = c(1L, diff(olddata$ID)),
>    dplyr_grp = olddata %>% group_by(ID) %>% mutate(first =
> as.integer(row_number() == 1)),
>    dplyr = olddata %>% mutate(first = as.integer(row_number() == 1), .by
> = ID)
> )
> print(mb, order = "median")
>
>
>
> However, note that dplyr operates in entire data.frames and therefore is
> expected to be slower when tested against instructions that process one
> column only.
>
>
> Hope this helps,
>
> Rui Barradas
>
>
> --
> Este e-mail foi analisado pelo software antiv?rus AVG para verificar a presen?a de v?rus.
> http://www.avg.com/
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From j@ork|n @end|ng |rom @om@um@ry|@nd@edu  Mon Dec  2 05:18:40 2024
From: j@ork|n @end|ng |rom @om@um@ry|@nd@edu (Sorkin, John)
Date: Mon, 2 Dec 2024 04:18:40 +0000
Subject: [R] Identify first row of each ID within a data frame,
 create a variable first =1 for the first row and first=0 of all
 other rows
In-Reply-To: <CAGxFJbTUEFgeeDXe0rpAe4EfGN8edJAC1oVSjMTKuat-iBkSww@mail.gmail.com>
References: <DM6PR03MB5049ED4EE95641C693B3D7EAE2342@DM6PR03MB5049.namprd03.prod.outlook.com>
 <b888c330-de36-4a00-aeff-b38385baa085@sapo.pt>
 <CAGxFJbTUEFgeeDXe0rpAe4EfGN8edJAC1oVSjMTKuat-iBkSww@mail.gmail.com>
Message-ID: <DM6PR03MB50499E32539371619AB9CE39E2352@DM6PR03MB5049.namprd03.prod.outlook.com>

Dear Colleagues,

I am grateful to all of you for helping me with my question, how to write R code that will identify the first row of each ID within a data frame, create a variable first=1 for the first row and first=0 for all repeats of the ID.

WOW!!!
I just saw Boris Steipe's answer to my question:
olddata$first <- as.numeric(! duplicated(olddata$ID))
The solution is elegant, short, easy to understand, and it uses base R! All important characteristics of a good solution, at least for me. While I want to learn solutions using packages that extend base R, I believe that a good programmer learns how to do something using the base language and once that is learned, explores way to solve a programing problem using advanced packages.

Each and every one of you (I hope I did not miss anyone in my list of email addresses) took the time to read my emails and respond to me. Your collective help is invaluable, and I am in your collect debt.

Many, many thanks,
John

John David Sorkin M.D., Ph.D.
Professor of Medicine, University of Maryland School of Medicine;
Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
Senior Statistician University of Maryland Center for Vascular Research;

Division of Gerontology and Paliative Care,
10 North Greene Street
GRECC (BT/18/GR)
Baltimore, MD 21201-1524
Cell phone 443-418-5382




________________________________________
From: Bert Gunter <bgunter.4567 at gmail.com>
Sent: Sunday, December 1, 2024 11:30 AM
To: Rui Barradas
Cc: Sorkin, John; r-help at r-project.org (r-help at r-project.org)
Subject: Re: [R] Identify first row of each ID within a data frame, create a variable first =1 for the first row and first=0 of all other rows

Rui:
"f these two, diff is faster. But of all the solutions posted so far,
Ben Bolker's is the fastest."

But the explicit version of diff is still considerably faster:

> D <- c(rep(1,10),rep(2,6),rep(3,2))

> microbenchmark(c(1L,diff(D)), times = 1000L)
Unit: microseconds
           expr   min    lq    mean median    uq    max neval
 c(1L, diff(D)) 3.075 3.198 3.34396   3.28 3.362 29.684  1000

> microbenchmark( as.integer(!duplicated(D)), times =1000L)
Unit: microseconds
                       expr   min    lq     mean median   uq  max neval
 as.integer(!duplicated(D)) 1.476 1.558 1.644264  1.599 1.64 16.4  1000

> microbenchmark( D - c(0L, D[-length(D)]), times = 1000L)
Unit: nanoseconds  ## note that unit is nanoseconds not microseconds
                     expr min  lq    mean median  uq  max neval
 D - c(0L, D[-length(D)]) 369 410 489.335    492 533 9840  1000

Cheers,
Bert

On Sat, Nov 30, 2024 at 11:05?PM Rui Barradas <ruipbarradas at sapo.pt> wrote:
>
> ?s 02:27 de 01/12/2024, Sorkin, John escreveu:
> > Dear R help folks,
> >
> > First my apologizes for sending several related questions to the list server. I am trying to learn how to manipulate data in R . . . and am having difficulty getting my program to work. I greatly appreciate the help and support list member give!
> >
> > I am trying to write a program that will run through a data frame organized by ID and for the first line of each new group of data lines that has the same ID create a new variable first that will be 1 for the first line of the group and 0 for all other lines.
> >
> > e.g. if my original data is
> >   olddata
> >     ID date
> >      1     1
> >      1     1
> >      1     2
> >      1     2
> >      1     3
> >      1     3
> >      1     4
> >      1     4
> >      1     5
> >      1     5
> >      2     5
> >      2     5
> >      2     5
> >      2     6
> >      2     6
> >      2     6
> >      3   10
> >      3   10
> >
> > the new data will be
> > newdata
> >     ID date  first
> >      1     1       1
> >      1     1       0
> >      1     2       0
> >      1     2       0
> >      1     3       0
> >      1     3       0
> >      1     4       0
> >      1     4       0
> >      1     5       0
> >      1     5       0
> >      2     5       1
> >      2     5       0
> >      2     5       0
> >      2     6       0
> >      2     6       0
> >      2     6       0
> >      3   10       1
> >      3   10       0
> >
> > When I run the program below, I receive the following error:
> > Error in df[, "ID"] : incorrect number of dimensions
> >
> > My code:
> > # Create data.frame
> > ID <- c(rep(1,10),rep(2,6),rep(3,2))
> > date <- c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),
> >            rep(5,3),rep(6,3),rep(10,2))
> > olddata <- data.frame(ID=ID,date=date)
> > class(olddata)
> > cat("This is the original data frame","\n")
> > print(olddata)
> >
> > # This function is supposed to identify the first row
> > # within each level of ID and, for the first row, set
> > # the variable first to 1, and for all rows other than
> > # the first row set first to 0.
> > mydoit <- function(df){
> >    value <- ifelse (first(df[,"ID"]),1,0)
> >    cat("value=",value,"\n")
> >    df[,"first"] <- value
> > }
> > newdata <- aggregate(olddata,list(olddata[,"ID"]),mydoit)
> >
> > Thank you,
> > John
> >
> >
> > John David Sorkin M.D., Ph.D.
> > Professor of Medicine, University of Maryland School of Medicine;
> > Associate Director for Biostatistics and Informatics, Baltimore VA Medical Center Geriatrics Research, Education, and Clinical Center;
> > PI Biostatistics and Informatics Core, University of Maryland School of Medicine Claude D. Pepper Older Americans Independence Center;
> > Senior Statistician University of Maryland Center for Vascular Research;
> >
> > Division of Gerontology and Paliative Care,
> > 10 North Greene Street
> > GRECC (BT/18/GR)
> > Baltimore, MD 21201-1524
> > Cell phone 443-418-5382
> >
> >
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.
> Hello,
>
> And here are two other solutions.
>
>
> olddata$first <- with(olddata, ave(seq_along(ID), ID, FUN = \(x) x ==
> x[1L]))
>
> olddata$first <- c(1L, diff(olddata$ID))
>
>
> Of these two, diff is faster. But of all the solutions posted so far,
> Ben Bolker's is the fastest. And it can be made a little faster if
> as.integer substitutes for as.numeric.
> And dplyr::mutate now has a .by argument, which avoids explicit the call
> to group_by, with a performance gain.
>
>
> library(microbenchmark)
>
> mb <- microbenchmark(
>    ave = with(olddata, ave(seq_along(ID), ID, FUN = \(x) x == x[1L])),
>    dup_num = as.numeric(! duplicated(olddata$ID)),
>    dup_int = as.integer(! duplicated(olddata$ID)),
>    diff = diff = c(1L, diff(olddata$ID)),
>    dplyr_grp = olddata %>% group_by(ID) %>% mutate(first =
> as.integer(row_number() == 1)),
>    dplyr = olddata %>% mutate(first = as.integer(row_number() == 1), .by
> = ID)
> )
> print(mb, order = "median")
>
>
>
> However, note that dplyr operates in entire data.frames and therefore is
> expected to be slower when tested against instructions that process one
> column only.
>
>
> Hope this helps,
>
> Rui Barradas
>
>
> --
> Este e-mail foi analisado pelo software antiv?rus AVG para verificar a presen?a de v?rus.
> http://www.avg.com/
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.r-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

From gerr|t@e|chner @end|ng |rom m@th@un|-g|e@@en@de  Wed Dec  4 13:38:45 2024
From: gerr|t@e|chner @end|ng |rom m@th@un|-g|e@@en@de (Gerrit Eichner)
Date: Wed, 4 Dec 2024 13:38:45 +0100
Subject: [R] Undocumented behaviour of diag when replacing the diagonal of a
 matrix?
Message-ID: <982a9d37-0f89-42bc-9394-69f8080bf227@math.uni-giessen.de>

Dear list,

is anyone aware of the following behavious of diag when used to replace 
diagonals (plural!) of a matrix?

Small example: The following is documented and clearly to be expected:

A <- matrix(0, nrow = 5, ncol = 5)
diag(A) <- 1; A


BUT, what about the following? When executing the code of `diag<-` line 
by line, it throws errors. So why does it work?

diag(A[-1, ]) <- 2; A

diag(A[-5, -1]) <- 3; A

diag(A[-5, -(1:2)]) <- 4; A


Any ideas?

  TIA and best regards  --  Gerrit

---------------------------------------------------------------------
Dr. Gerrit Eichner                   Mathematical Institute, Room 215
gerrit.eichner at math.uni-giessen.de   Justus-Liebig-University Giessen
Tel: +49-(0)641-99-32104          Arndtstr. 2, 35392 Giessen, Germany
https://www.uni-giessen.de/math/eichner


From bgunter@4567 @end|ng |rom gm@||@com  Wed Dec  4 14:38:44 2024
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Wed, 4 Dec 2024 05:38:44 -0800
Subject: [R] 
 Undocumented behaviour of diag when replacing the diagonal of a
 matrix?
In-Reply-To: <982a9d37-0f89-42bc-9394-69f8080bf227@math.uni-giessen.de>
References: <982a9d37-0f89-42bc-9394-69f8080bf227@math.uni-giessen.de>
Message-ID: <CAGxFJbQAb21XyihMJ7Fiu+ctLdPdkFodjWJggQgvxKjeZ_QHpQ@mail.gmail.com>

matrices are vectors with a "dim" attribute.
So what I think is happening is:

> A <- matrix(1:25, nrow = 5, ncol = 5)
> diag(A[-1,]) <- 0
> A
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    6   11   16   21
[2,]    0    7   12   17   22
[3,]    3    0   13   18   23
[4,]    4    9    0   19   24
[5,]    5   10   15    0   25
>
> ## is equivqalent to:
>
> A <- matrix(1:25, nrow = 5, ncol = 5)
> wh <- c(diag(A[-1,]))   # A's vector indices of diag(A[-1,])
> A[wh] <- 0
> A
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    6   11   16   21
[2,]    0    7   12   17   22
[3,]    3    0   13   18   23
[4,]    4    9    0   19   24
[5,]    5   10   15    0   25

I didn't check, but I assume your other examples would work similarly.
Please repost if I am wrong.

Cheers,
Bert

On Wed, Dec 4, 2024 at 4:39?AM Gerrit Eichner
<gerrit.eichner at math.uni-giessen.de> wrote:
>
> Dear list,
>
> is anyone aware of the following behavious of diag when used to replace
> diagonals (plural!) of a matrix?
>
> Small example: The following is documented and clearly to be expected:
>
> A <- matrix(0, nrow = 5, ncol = 5)
> diag(A) <- 1; A
>
>
> BUT, what about the following? When executing the code of `diag<-` line
> by line, it throws errors. So why does it work?
>
> diag(A[-1, ]) <- 2; A
>
> diag(A[-5, -1]) <- 3; A
>
> diag(A[-5, -(1:2)]) <- 4; A
>
>
> Any ideas?
>
>   TIA and best regards  --  Gerrit
>
> ---------------------------------------------------------------------
> Dr. Gerrit Eichner                   Mathematical Institute, Room 215
> gerrit.eichner at math.uni-giessen.de   Justus-Liebig-University Giessen
> Tel: +49-(0)641-99-32104          Arndtstr. 2, 35392 Giessen, Germany
> https://www.uni-giessen.de/math/eichner
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide https://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec  4 15:31:30 2024
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 4 Dec 2024 09:31:30 -0500
Subject: [R] 
 Undocumented behaviour of diag when replacing the diagonal of a
 matrix?
In-Reply-To: <982a9d37-0f89-42bc-9394-69f8080bf227@math.uni-giessen.de>
References: <982a9d37-0f89-42bc-9394-69f8080bf227@math.uni-giessen.de>
Message-ID: <f8d638cf-75ab-41c6-9127-b0a69c162330@gmail.com>

On 2024-12-04 7:38 a.m., Gerrit Eichner wrote:
> Dear list,
> 
> is anyone aware of the following behavious of diag when used to replace
> diagonals (plural!) of a matrix?
> 
> Small example: The following is documented and clearly to be expected:
> 
> A <- matrix(0, nrow = 5, ncol = 5)
> diag(A) <- 1; A
> 
> 
> BUT, what about the following? When executing the code of `diag<-` line
> by line, it throws errors. So why does it work?
> 
> diag(A[-1, ]) <- 2; A
> 
> diag(A[-5, -1]) <- 3; A
> 
> diag(A[-5, -(1:2)]) <- 4; A
> 

Could you show us the log of what you did that generated errors?  The 
statement `diag(A[-1, ]) <- 2` is pretty complex; it involves two 
assignment functions (both `diag<-` and `[<-`), so you might have tried 
to execute the wrong thing.

Duncan Murdoch


