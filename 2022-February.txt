From yugoh|@v @end|ng |rom gm@||@com  Tue Feb  1 04:50:57 2022
From: yugoh|@v @end|ng |rom gm@||@com (Love Umesi)
Date: Tue, 1 Feb 2022 16:50:57 +1300
Subject: [R] Survey design for multilevel analysis
Message-ID: <CAOTqx+KtV1_WOtffzuZJetE=JFKqVDqV8O15aUs0vBFZa1yyeQ@mail.gmail.com>

I am new in using R, and I need to run a multilevel analysis (two-phase
design on two levels) using Cox frailty survival model on a survey data
(Nigeria Demographic and Health Survey Data).

My problem is how to write the design weight using the two weights needed
and apply them to the analysis.

I have identified the needed variables for the survey design, which
are : psu/cluster=
v021 individual-level weight= wt1_1 cluster-level weigh= wt2_1 strata/stratum=
v022

Please can someone help me with the survey design (svydesign) code and how
to include it and the weights in a model.

I understand I have to use svycoxph in the model. Please how do I include
survey design and account for the 2 weights (individual-level and
cluster-level weights) in the gamma frailty model below?

Frailty1 <- coxph (Surv(study_time, died) ~ factor(v024) + factor(mat_edu)
+ v025 + frailty(v021,distribution="gamma"), data=rcom2018)

Really looking forward to your help as my project is hanging on this.

Many thanks.


library(survival)#> Warning: package 'survival' was built under R version 4.0.5
library(frailtypack)#> Warning: package 'frailtypack' was built under
R version 4.0.5#> Loading required package: boot#> #> Attaching
package: 'boot'#> The following object is masked from
'package:survival':#> #>     aml#> Loading required package: MASS#>
Loading required package: survC1#> Warning: package 'survC1' was built
under R version 4.0.5#> Loading required package: doBy#> Warning:
package 'doBy' was built under R version 4.0.5#> #> Attaching package:
'frailtypack'#> The following object is masked from
'package:survival':#> #>     cluster


rcom1 <- data.frame(
  data.frame(
    pid = c(
      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
      14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
      30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,
      46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
      61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
      77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92,
      93, 94, 95, 96, 97, 98, 99, 100
    ),
    study_time = c(
      13, 9, 17, 31, 39, 22, 24, 0, 23, 12, 9, 35,
      18, 20, 60, 18, 5, 46, 26, 54, 37, 51, 31, 55, 27, 15, 39, 6,
      29, 0, 9, 40, 23, 12, 35, 56, 14, 40, 57, 42, 5, 42, 39, 39,
      54, 19, 52, 42, 7, 28, 53, 5, 28, 13, 37, 0, 23, 33, 27, 36, 20,
      24, 58, 34, 12, 44, 3, 34, 14, 5, 10, 40, 12, 36, 19, 58, 17,
      40, 39, 58, 53, 53, 1, 50, 2, 28, 24, 13, 13, 50, 46, 46, 19, 6,
      32, 59, 9, 30, 30, 43
    ),
    died = c(
      0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0,
      0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0
    ),
    v021 = c(
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3,
      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4,
      4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
      6
    ),
    v022 = c(
      "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "2", "2", "2", "2", "2", "2", "2",
      "2", "2", "2"
    ),
    v012 = c(
      40, 37, 27, 27, 24, 32, 35, 35, 34, 20, 28,
      28, 26, 24, 24, 25, 26, 26, 26, 26, 28, 27, 25, 25, 27, 26, 26,
      21, 21, 31, 36, 36, 27, 23, 32, 32, 33, 33, 33, 28, 25, 37,
      33, 34, 33, 28, 28, 29, 33, 33, 33, 39, 38, 38, 38, 38, 24, 27,
      35, 40, 22, 38, 38, 21, 30, 30, 30, 39, 43, 18, 23, 23, 25, 25,
      30, 45, 26, 26, 35, 35, 35, 35, 32, 32, 40, 25, 27, 30, 30, 30,
      28, 28, 18, 27, 30, 30, 27, 21, 21, 30
    ),
    wt2_1 = c(
      401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031,
      401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
      631.818176269531, 631.818176269531, 631.818176269531,
      631.818176269531, 631.818176269531, 631.818176269531, 631.818176269531,
      631.818176269531, 631.818176269531, 631.818176269531
    ),
    wt1_1 = c(
      2.5074667930603, 2.5074667930603,
      2.5074667930603, 2.5074667930603, 2.5074667930603, 2.5074667930603,
      2.5074667930603, 2.5074667930603, 2.5074667930603, 2.5074667930603,
      2.5074667930603, 2.5074667930603, 2.5074667930603,
      2.5074667930603, 2.5074667930603, 5.1194109916687, 5.1194109916687,
      5.1194109916687, 5.1194109916687, 5.1194109916687, 5.1194109916687,
      5.1194109916687, 5.1194109916687, 5.1194109916687,
      5.1194109916687, 5.1194109916687, 5.1194109916687, 5.1194109916687,
      5.1194109916687, 5.1194109916687, 5.1194109916687, 5.1194109916687,
      5.1194109916687, 5.1194109916687, 2.40910983085632,
      2.40910983085632, 2.40910983085632, 2.40910983085632, 2.40910983085632,
      2.40910983085632, 2.40910983085632, 2.40910983085632,
      2.40910983085632, 2.40910983085632, 2.40910983085632, 2.40910983085632,
      2.40910983085632, 2.40910983085632, 1.06203985214233,
      1.06203985214233, 1.06203985214233, 1.06203985214233, 1.06203985214233,
      1.06203985214233, 1.06203985214233, 1.06203985214233,
      1.06203985214233, 1.06203985214233, 1.06203985214233, 1.06203985214233,
      1.06203985214233, 1.06203985214233, 1.06203985214233,
      1.06203985214233, 1.06203985214233, 1.06203985214233, 1.06203985214233,
      2.80098295211792, 2.80098295211792, 2.80098295211792,
      2.80098295211792, 2.80098295211792, 2.80098295211792, 2.80098295211792,
      2.80098295211792, 2.80098295211792, 2.80098295211792,
      2.80098295211792, 2.80098295211792, 2.80098295211792, 2.80098295211792,
      2.80098295211792, 2.80098295211792, 2.80098295211792,
      2.80098295211792, 2.80098295211792, 2.80098295211792, 2.80098295211792,
      2.80098295211792, 2.80098295211792, 1.24210178852081,
      1.24210178852081, 1.24210178852081, 1.24210178852081, 1.24210178852081,
      1.24210178852081, 1.24210178852081, 1.24210178852081,
      1.24210178852081, 1.24210178852081
    ),
    v024 = c(
      "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1"
    ),
    v025 = c(
      "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
      "1", "1", "1", "1", "1", "1", "2", "2", "2", "2", "2", "2", "2",
      "2", "2", "2"
    ),
    mat_edu = c(
      "5", "5", "5", "4", "4", "5", "4", "4", "4",
      "4", "4", "4", "5", "5", "5", "5", "5", "5", "4", "4", "5",
      "4", "4", "4", "5", "3", "3", "4", "4", "5", "5", "5", "5", "4",
      "2", "2", "0", "0", "0", "5", "5", "0", "1", "5", "5", "3",
      "3", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "4", "5",
      "5", "4", "5", "5", "3", "4", "4", "5", "3", "1", "3", "3", "3",
      "1", "3", "2", "1", "3", "3", "4", "4", "0", "0", "2", "2",
      "1", "0", "4", "4", "4", "4", "0", "0", "3", "4", "2", "2", "3",
      "3", "3", "0"
    )
  ))

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Tue Feb  1 16:34:24 2022
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Tue, 1 Feb 2022 07:34:24 -0800
Subject: [R] Repeatability Analysis of Ordinal Data
In-Reply-To: <DM6PR01MB4314D3686B97D43F15DF3096EA259@DM6PR01MB4314.prod.exchangelabs.com>
References: <DM6PR01MB4314D3686B97D43F15DF3096EA259@DM6PR01MB4314.prod.exchangelabs.com>
Message-ID: <CAGxFJbTqwHWJnBtX92T+bBH58C2tA4cT613nnv6g=8mO38VYJA@mail.gmail.com>

Package-specific questions for non-standard packages (see
https://cran.r-project.org/doc/FAQ/R-FAQ.html#Add-on-packages-in-R for
the list of current standard packages) are generally off topic here
per the posting guide (linked below). It is suggested there that you
contact the package maintainer (?maintainer) for such questions.

Bert Gunter

"The trouble with having an open mind is that people keep coming along
and sticking things into it."
-- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )


On Tue, Feb 1, 2022 at 2:02 AM Sidoti, Salvatore <sidoti.23 at osu.edu> wrote:
>
> Greetings, Colleagues:
>
> I have several Likert-type ordinal data sets consisting of animal responses with repeated measures. I was able to implement a CLMM model easily enough with the package `ordinal`. However, the package does not support repeatability analyses.
>
> Assuming that I subset my data according to treatment and/or sex, I am keen to try the `ordinalRR` package. According to the package documentation (https://cran.r-project.org/web/packages/ordinalRR/ordinalRR.pdf), performing `summary()` on the output from the function `ordinalRR()` returns the point estimates for each rater and for each pairwise combination of raters. However, is it possible to return an overall repeatability value and a 95% credible interval across all raters?
>
> What follows is a stock procedure from the package reference document:
>
> #-------------------------------------------------------------------------------
> library(ordinalRR)
>
> # load the dataset that comes with the package
> data(followup)
>
> # preprocess data to accommodate the package functions
> followup.pre <- preprocess(followup)
>
> # perform the analysis
> followup.random <- ordinalRR(followup.pre)
>
> summary(followup.random)
>
> Call:
>   ordinalRR(followup.pre)
>
> Data: 30 parts, 3 operators, 2 repetitions with 4 ordinal categories.
> Random-effects model MCMC chain: 1000 burn-in and 10000 retained.
>
> Simple repeatability and model parameter estimates by rater:
>   Rater j Repeatability  a_j d_{j,1} d_{j,2} d_{j,3}
> 1         0.900 12.0    -1.5    -0.1     0.6
> 2         0.900 10.9    -1.6    -0.3     0.5
> 3         0.933 12.7    -1.5    -0.2     0.5
>
> Simple repeatability and reproducibility (R&R) point estimates for pairs of raters:
>   Rater j Rater j' (R&R)_{j,j'}
> 1        2        0.808
> 1        3        0.900
> 2        3        0.850
> #-------------------------------------------------------------------------------
>
> Kind Regards,
> Salvatore Sidoti
> PhD Candidate
> The Ohio State University
> Columbus, Ohio USA
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From nboeger @end|ng |rom gm@||@com  Tue Feb  1 14:45:40 2022
From: nboeger @end|ng |rom gm@||@com (Nathan Boeger)
Date: Tue, 1 Feb 2022 20:45:40 +0700
Subject: [R] Funky calculations
Message-ID: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>

Hello,

I found something strange and maybe I am going nuts but this does not make
sense:

>  (0.4 + 0.2 + 0 + 0.3 + 0 + 0.1) > 1
[1] TRUE

I tried it on my mac M1 (R v4.1.2) and my Linux box (R v4.0.4). If I use
other values, it does not work (see below). It seems only that combination,
granted I did not try them all.

>  (0.4 + 0.2 + 0 + 0.2 + 0 + 0.2) > 1
[1] FALSE

Am I missing something?

Cheers

-nb

	[[alternative HTML version deleted]]


From kev|n@thorpe @end|ng |rom utoronto@c@  Tue Feb  1 17:34:13 2022
From: kev|n@thorpe @end|ng |rom utoronto@c@ (Kevin Thorpe)
Date: Tue, 1 Feb 2022 16:34:13 +0000
Subject: [R] Funky calculations
In-Reply-To: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
References: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
Message-ID: <B55BEB40-523F-4362-905A-98AB3BF1ED48@utoronto.ca>

This looks like a version of FAQ 7.31.

> On Feb 1, 2022, at 8:45 AM, Nathan Boeger <nboeger at gmail.com> wrote:
> 
> [You don't often get email from nboeger at gmail.com. Learn why this is important at http://aka.ms/LearnAboutSenderIdentification.]
> 
> Hello,
> 
> I found something strange and maybe I am going nuts but this does not make
> sense:
> 
>> (0.4 + 0.2 + 0 + 0.3 + 0 + 0.1) > 1
> [1] TRUE
> 
> I tried it on my mac M1 (R v4.1.2) and my Linux box (R v4.0.4). If I use
> other values, it does not work (see below). It seems only that combination,
> granted I did not try them all.
> 
>> (0.4 + 0.2 + 0 + 0.2 + 0 + 0.2) > 1
> [1] FALSE
> 
> Am I missing something?
> 
> Cheers
> 
> -nb
> 
>        [[alternative HTML version deleted]]
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


-- 
Kevin E. Thorpe
Head of Biostatistics,  Applied Health Research Centre (AHRC)
Li Ka Shing Knowledge Institute of St. Michael?s Hospital
Assistant Professor, Dalla Lana School of Public Health
University of Toronto
email: kevin.thorpe at utoronto.ca  Tel: 416.864.5776  Fax: 416.864.3016


From gm@rk@|ow|er @end|ng |rom out|ook@com  Tue Feb  1 17:34:21 2022
From: gm@rk@|ow|er @end|ng |rom out|ook@com (Mark Fowler)
Date: Tue, 1 Feb 2022 16:34:21 +0000
Subject: [R] Funky calculations
In-Reply-To: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
References: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
Message-ID: <MN2PR07MB7213D0DFE6763C37A38C8A9985269@MN2PR07MB7213.namprd07.prod.outlook.com>

This a joke? The values differ between the TRUE and FALSE syntaxes. The FALSE computes to 1.0, which is not greater than 0.

Sent from Mail<https://go.microsoft.com/fwlink/?LinkId=550986> for Windows

From: Nathan Boeger<mailto:nboeger at gmail.com>
Sent: Tuesday, February 1, 2022 12:28 PM
To: r-help at r-project.org<mailto:r-help at r-project.org>
Subject: [R] Funky calculations

Hello,

I found something strange and maybe I am going nuts but this does not make
sense:

>  (0.4 + 0.2 + 0 + 0.3 + 0 + 0.1) > 1
[1] TRUE

I tried it on my mac M1 (R v4.1.2) and my Linux box (R v4.0.4). If I use
other values, it does not work (see below). It seems only that combination,
granted I did not try them all.

>  (0.4 + 0.2 + 0 + 0.2 + 0 + 0.2) > 1
[1] FALSE

Am I missing something?

Cheers

-nb

        [[alternative HTML version deleted]]

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


	[[alternative HTML version deleted]]


From kry|ov@r00t @end|ng |rom gm@||@com  Tue Feb  1 17:35:57 2022
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Tue, 1 Feb 2022 19:35:57 +0300
Subject: [R] Funky calculations
In-Reply-To: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
References: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
Message-ID: <20220201193557.308209e8@Tarkus>

On Tue, 1 Feb 2022 20:45:40 +0700
Nathan Boeger <nboeger at gmail.com> wrote:

> I found something strange and maybe I am going nuts but this does not
> make sense:
> 
> >  (0.4 + 0.2 + 0 + 0.3 + 0 + 0.1) > 1  
> [1] TRUE

Unfortunately, this always happens when computers approximate real
numbers with fractions in binary. See R FAQ 7.31 (RShowDoc('FAQ') or
<https://cran.r-project.org/doc/FAQ/R-FAQ.html>).

-- 
Best regards,
Ivan


From gm@rk@|ow|er @end|ng |rom out|ook@com  Tue Feb  1 17:37:03 2022
From: gm@rk@|ow|er @end|ng |rom out|ook@com (Mark Fowler)
Date: Tue, 1 Feb 2022 16:37:03 +0000
Subject: [R] Funky calculations
In-Reply-To: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
References: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
Message-ID: <MN2PR07MB7213E5C0FC4BD36A4034C16985269@MN2PR07MB7213.namprd07.prod.outlook.com>

Sorry, last post I meant not > 1

Sent from Mail<https://go.microsoft.com/fwlink/?LinkId=550986> for Windows

From: Nathan Boeger<mailto:nboeger at gmail.com>
Sent: Tuesday, February 1, 2022 12:28 PM
To: r-help at r-project.org<mailto:r-help at r-project.org>
Subject: [R] Funky calculations

Hello,

I found something strange and maybe I am going nuts but this does not make
sense:

>  (0.4 + 0.2 + 0 + 0.3 + 0 + 0.1) > 1
[1] TRUE

I tried it on my mac M1 (R v4.1.2) and my Linux box (R v4.0.4). If I use
other values, it does not work (see below). It seems only that combination,
granted I did not try them all.

>  (0.4 + 0.2 + 0 + 0.2 + 0 + 0.2) > 1
[1] FALSE

Am I missing something?

Cheers

-nb

        [[alternative HTML version deleted]]

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


	[[alternative HTML version deleted]]


From @v|gro@@ @end|ng |rom ver|zon@net  Tue Feb  1 17:52:56 2022
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Tue, 1 Feb 2022 16:52:56 +0000 (UTC)
Subject: [R] Funky calculations
In-Reply-To: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
References: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
Message-ID: <542510676.2533919.1643734376267@mail.yahoo.com>

Yes, Nathan, you are missing something.

You are missing a computer language that does infinite precision arithmetic.

0.1 cannot be stored in binary exactly just as numbers like pi and e cannot be stored exactly as they keep needing more digits. The last digit of the allowed number of digits in floating point may have to be chosen as either a 0 or 1 even though the value is sort of in between. 

Think of what happens if you add in decimal

1/3 + 1/3 + 1/3

You could add

.333
.333
.333

And your handwritten calculation would be .999

And no matter how many more 3's you add, you never get beyond .999999999999999999999999999999999

And obviously the right answer is 1.0000000000000000000000000000

The order the numbers are added can matter. You interspersed a combination of floating point and integers so conversions are happening too. 

R has the ability to test for very near equality like this:

> all.equal(1, (0.4 + 0.2 + 0 + 0.3 + 0 + 0.1))
[1] TRUE

There are some built-in and sort of hidden variables stored in .Machine that provide some tolerances for the data storage on that machine. 

> str(.Machine)
List of 28
 $ double.eps               : num 2.22e-16
 $ double.neg.eps           : num 1.11e-16
 $ double.xmin              : num 2.23e-308
 $ double.xmax              : num 1.8e+308
 $ double.base              : int 2
 $ double.digits            : int 53
 $ double.rounding          : int 5
 $ double.guard             : int 0
 $ double.ulp.digits        : int -52
 $ double.neg.ulp.digits    : int -53
 $ double.exponent          : int 11
 $ double.min.exp           : int -1022
 $ double.max.exp           : int 1024
 $ integer.max              : int 2147483647
 $ sizeof.long              : int 4
 $ sizeof.longlong          : int 8
 $ sizeof.longdouble        : int 16
 $ sizeof.pointer           : int 8
 $ longdouble.eps           : num 1.08e-19
 $ longdouble.neg.eps       : num 5.42e-20
 $ longdouble.digits        : int 64
 $ longdouble.rounding      : int 5
 $ longdouble.guard         : int 0
 $ longdouble.ulp.digits    : int -63
 $ longdouble.neg.ulp.digits: int -64
 $ longdouble.exponent      : int 15
 $ longdouble.min.exp       : int -16382
 $ longdouble.max.exp       : int 16384

Functions like all.equal() can use these to determine a way to compare while ignoring the last.

So yes, R shares this glitch with other programming languages and it is not really safe to compare floating point numbers at times. Here is just a suggestion on say rounding your sum to twelve digits to see how it compares to 1.0:

> round((0.4 + 0.2 + 0 + 0.3 + 0 + 0.1),12) > 1.0
[1] FALSE





-----Original Message-----
From: Nathan Boeger <nboeger at gmail.com>
To: r-help at r-project.org
Sent: Tue, Feb 1, 2022 8:45 am
Subject: [R] Funky calculations

Hello,

I found something strange and maybe I am going nuts but this does not make
sense:

>? (0.4 + 0.2 + 0 + 0.3 + 0 + 0.1) > 1
[1] TRUE

I tried it on my mac M1 (R v4.1.2) and my Linux box (R v4.0.4). If I use
other values, it does not work (see below). It seems only that combination,
granted I did not try them all.

>? (0.4 + 0.2 + 0 + 0.2 + 0 + 0.2) > 1
[1] FALSE

Am I missing something?

Cheers

-nb

??? [[alternative HTML version deleted]]

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Tue Feb  1 18:07:51 2022
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Tue, 1 Feb 2022 17:07:51 +0000
Subject: [R] Funky calculations
In-Reply-To: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
References: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
Message-ID: <e414e0f2-129f-e81e-7fa1-ca1f610c6176@sapo.pt>

Hello,

Like others have said, this is FAQ 7.31. Try

(0.4 + 0.2 + 0 + 0.3 + 0 + 0.1) - 1


on both systems, on one of them it's not zero.

Hope this helps,

Rui Barradas

?s 13:45 de 01/02/2022, Nathan Boeger escreveu:
> Hello,
> 
> I found something strange and maybe I am going nuts but this does not make
> sense:
> 
>>   (0.4 + 0.2 + 0 + 0.3 + 0 + 0.1) > 1
> [1] TRUE
> 
> I tried it on my mac M1 (R v4.1.2) and my Linux box (R v4.0.4). If I use
> other values, it does not work (see below). It seems only that combination,
> granted I did not try them all.
> 
>>   (0.4 + 0.2 + 0 + 0.2 + 0 + 0.2) > 1
> [1] FALSE
> 
> Am I missing something?
> 
> Cheers
> 
> -nb
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From @v|gro@@ @end|ng |rom ver|zon@net  Tue Feb  1 18:19:47 2022
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Tue, 1 Feb 2022 17:19:47 +0000 (UTC)
Subject: [R] 
 [External] Weird behaviour of order() when having multiple ties
In-Reply-To: <CAFVVV-i83ad8OWs-8veC3dpnFNmaOenuNLWHpksuEH1za=Gr3w@mail.gmail.com>
References: <CAFVVV-gzoE2UDGMga_Pgbix=BmZj5WN2nA1wqY9s75_tcKQiWA@mail.gmail.com>
 <BL1PR11MB5239432B2669D24516983141D2249@BL1PR11MB5239.namprd11.prod.outlook.com>
 <CAFVVV-i83ad8OWs-8veC3dpnFNmaOenuNLWHpksuEH1za=Gr3w@mail.gmail.com>
Message-ID: <1765395989.2546954.1643735987443@mail.yahoo.com>

Stefan,

You are thinking of sorting and indeed if you sort, you get what you think:

> sort(c(2,3,4,1,1,1,1,1))
[1] 1 1 1 1 1 2 3 4

BUT order() does not return any of its values. NONE. It returns the indexes of sorted values and you can, if you choose, use the index to sort one or more values.

Imagine you have two independent vectors (not a data.frame) containing names and ages. You want to rearrange the names in alphabetical order but do not want to lose the ages. When done you want the correspondence to remain.

> Names <- c("Marie", "Jacques", "Zelda", "Jean")
> Ages <- c(12, 32, 3, 102)
> (index <- order(Names))
[1] 2 4 1 3
> (sortedNames <- Names[index])
[1] "Jacques" "Jean"    "Marie"   "Zelda"  
> (sortedAges <- Ages[index])
[1]  32 102  12   3

By getting the order you should take entries from the original, you can apply that order to both of the vectors, or anything else linked such as their birthday. Yes, many people avoid this by simply connecting all the vectors in a data.frame, but under the sheets, the code you use to manipulate things will often do something similar to actually make what you want happen.

In your example, you can get the sorted version like this:

> # Get vector of indices and print
> (index <- order(c(2,3,4,1,1,1,1,1)))
[1] 4 5 6 7 8 1 2 3
> 
> # Use the index on the vector to reaarange the order and print
> (c(2,3,4,1,1,1,1,1)[index])
[1] 1 1 1 1 1 2 3 4
> 
> # Use the index reversed to print in descending order.
> (c(2,3,4,1,1,1,1,1)[rev(index)])
[1] 4 3 2 1 1 1 1 1

And note you can print it forward and backward without calling sort() twice, not that this is important!

I hope that clarifies why the name is "order" and not "sort". 


-----Original Message-----
From: Stefan Fleck <stefan.b.fleck at gmail.com>
To: Richard M. Heiberger <rmh at temple.edu>
Cc: r-help at r-project.org <r-help at r-project.org>
Sent: Sun, Jan 30, 2022 3:07 pm
Subject: Re: [R]  [External] Weird behaviour of order() when having multiple ties

it's not about the sort order of the ties, shouldn't all the 1s in
order(c(2,3,4,1,1,1,1,1)) come before 2,3,4? because that's not what
happening

On Sun, Jan 30, 2022 at 9:00 PM Richard M. Heiberger <rmh at temple.edu> wrote:

> when there are ties it doesn't matter which is first.
> in a situation where it does matter, you will need a tiebreaker column.
> ------------------------------
> *From:* R-help <r-help-bounces at r-project.org> on behalf of Stefan Fleck <
> stefan.b.fleck at gmail.com>
> *Sent:* Sunday, January 30, 2022 4:16:44 AM
> *To:* r-help at r-project.org <r-help at r-project.org>
> *Subject:* [External] [R] Weird behaviour of order() when having multiple
> ties
>
> I am experiencing a weird behavior of `order()` for numeric vectors. I
> tested on 3.6.2 and 4.1.2 for windows and R 4.0.2 on ubuntu. Can anyone
> confirm?
>
> order(
>?  c(
>? ?  0.6,
>? ?  0.5,
>? ?  0.3,
>? ?  0.2,
>? ?  0.1,
>? ?  0.1
>?  )
> )
> ## Result [should be in order]
> [1] 5 6 4 3 2 1
>
> The sort order is obviously wrong. This only occurs if i have multiple
> ties. The problem does _not_ occur for decreasing = TRUE.
>
>? ? ? ?  [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>
> https://nam10.safelinks.protection.outlook.com/?url=https%3A%2F%2Fstat.ethz.ch%2Fmailman%2Flistinfo%2Fr-help&data=04%7C01%7Crmh%40temple.edu%7Cbae20314c2314a5cc7cd08d9e429e33f%7C716e81efb52244738e3110bd02ccf6e5%7C0%7C0%7C637791692024451993%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000&sdata=O6R%2FNM6IdPzP8RY3JIWfLgmkE%2B0KcVyYBxoRMo8v2dk%3D&reserved=0
> PLEASE do read the posting guide
> https://nam10.safelinks.protection.outlook.com/?url=http%3A%2F%2Fwww.r-project.org%2Fposting-guide.html&data=04%7C01%7Crmh%40temple.edu%7Cbae20314c2314a5cc7cd08d9e429e33f%7C716e81efb52244738e3110bd02ccf6e5%7C0%7C0%7C637791692024451993%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000&sdata=6hlfMjZLzopVzGnFVWlGnoEqvZBQwXPlxMuZ2sglEUk%3D&reserved=0
> and provide commented, minimal, self-contained, reproducible code.
>

??? [[alternative HTML version deleted]]

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From @v|gro@@ @end|ng |rom ver|zon@net  Tue Feb  1 20:07:50 2022
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Tue, 1 Feb 2022 19:07:50 +0000 (UTC)
Subject: [R] Funky calculations
In-Reply-To: <e414e0f2-129f-e81e-7fa1-ca1f610c6176@sapo.pt>
References: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
 <e414e0f2-129f-e81e-7fa1-ca1f610c6176@sapo.pt>
Message-ID: <302884631.2576868.1643742470880@mail.yahoo.com>

I suspect there are examples, RUI, where the same code can produce different results based on the underlying representation or manipulation of floating point. There are two main versions I typically see using what some call a "float" and a "double" and I suspect at some future point someone will take 256 bits or so to make a "superdouble" that allots so many more bits to the mantissa and exponent components that you can use much larger numbers with many more significant digits. But it is the final digits where imprecision enters and also a number can vary whether you do rounding or truncating at that point. I think in binary, you generally truncate. So if you consider a number like 1/7 that has an infinitely long decimal representation in bases like decimal, but does have repeats, compared to a transcendental number like pi that does not really repeat, you can round it in decimal representation depending on where you are in the sequence when you stop.

.142857142857142857...

If you stop at a 5 or 7 or 8 and back up to the previous digit, you round up. Else you leave the previous result alone.

.1
.14
.143
.1429
etc.

I actually wrote a much longer explanation about a similar concern someone had in another language, Python, that was picked up and published in a new daily and can be found as the second article at the following URL if interested.

https://pyherald.com/articles/02_01_2022/

It starts like this:

Representing Numbers: The Complexity Behind
Mail by Avi Gross , src

Note I did not choose that title nor did I choose the original Subject line I was replying to here: https://mail.python.org/pipermail/python-list/2021-November/904404.html

And, no, I was not asked nor given any opportunity to polish it or fix a spelling error. It was just my fairly usual free-floating posting style like I use here. It doe illustrate that we are not talking about a bug in R and that the proper way to avoid it may include being aware that sometimes a test for near-equality may be needed.

Think of how many people write an endless loop by waiting for an asymptotic sum like adding 1/2 + 1/4 + 1/8 ... and breaking out of the loop only when the sum is exactly equal to 1.0. Not only will it mathematically never happen, unless you consider happening AT infinity to qualify, but the addition using floating point numbers may end at 0.9999999999999999999999 or so and anything added to it will underflow and always be shown as adding 0 thereafter. But looked at properly, this is pretty much the same problem being reported here. So some people create a small epsilon such as 1E-15 ad write code like:

if (abs(myval - expected) < epsilon) ...

This is another way of saying, if I am close enough, we are there.

All computer languages are alike; except where they aren't.


-----Original Message-----
From: Rui Barradas <ruipbarradas at sapo.pt>
To: Nathan Boeger <nboeger at gmail.com>; r-help at r-project.org
Sent: Tue, Feb 1, 2022 12:07 pm
Subject: Re: [R] Funky calculations


Hello,

Like others have said, this is FAQ 7.31. Try

(0.4 + 0.2 + 0 + 0.3 + 0 + 0.1) - 1


on both systems, on one of them it's not zero.

Hope this helps,

Rui Barradas

?s 13:45 de 01/02/2022, Nathan Boeger escreveu:
> Hello,
> 
> I found something strange and maybe I am going nuts but this does not make
> sense:
> 
>>?  (0.4 + 0.2 + 0 + 0.3 + 0 + 0.1) > 1
> [1] TRUE
> 
> I tried it on my mac M1 (R v4.1.2) and my Linux box (R v4.0.4). If I use
> other values, it does not work (see below). It seems only that combination,
> granted I did not try them all.
> 
>>?  (0.4 + 0.2 + 0 + 0.2 + 0 + 0.2) > 1
> [1] FALSE
> 
> Am I missing something?
> 
> Cheers
> 
> -nb


 


From rmh @end|ng |rom temp|e@edu  Tue Feb  1 20:44:02 2022
From: rmh @end|ng |rom temp|e@edu (Richard M. Heiberger)
Date: Tue, 1 Feb 2022 19:44:02 +0000
Subject: [R] [External]  Funky calculations
In-Reply-To: <20220201193557.308209e8@Tarkus>
References: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
 <20220201193557.308209e8@Tarkus>
Message-ID: <D24231AD-5CBF-4595-962E-2009821BD20B@temple.edu>

RShowDoc('FAQ') 

then search for 7.31


This statement
"If you stop at a 5 or 7 or 8 and back up to the previous digit, you round up. Else you leave the previous result alone."
is not quite right.  The recommendation in IEEE 754, and this is how R does arithmetic, is to Round Even.

I ilustrate here with decimal, even though R and other programs use binary.

> x <- c(1.4, 1.5, 1.6, 2.4, 2.5, 2.6, 3.4, 3.5, 3.6, 4.4, 4.5, 4.6)
> r <- round(x)
> cbind(x, r)
        x r
 [1,] 1.4 1
 [2,] 1.5 2
 [3,] 1.6 2
 [4,] 2.4 2
 [5,] 2.5 2
 [6,] 2.6 3
 [7,] 3.4 3
 [8,] 3.5 4
 [9,] 3.6 4
[10,] 4.4 4
[11,] 4.5 4
[12,] 4.6 5
> 

Numbers whose last digit is not 5 (when in decimal) round to the nearest integer.
Numbers who last digit is 5 (1.5, 2.5, 3.5, 4.5 above) 
round to the nearest EVEN integer.
Hence 1.5 and 3.5 round up to the even numbers 2 and 4.
2.5 and 4.5 round down do the even numbers 2 and 4.

This way the round ups and downs average out to 0.  If we always went up from .5 we would have
an updrift over time.

For even more detail click on the link in FAQ 7.31 to my appendix
https:// link.springer.com/content/pdf/bbm%3A978-1-4939-2122-5%2F1.pdf
and search for "Appendix G".

Section G.5 explains Round to Even.
Sections G.6 onward illustrate specific examples, such as the one that started this email thread.

Rich

From drj|m|emon @end|ng |rom gm@||@com  Tue Feb  1 23:19:35 2022
From: drj|m|emon @end|ng |rom gm@||@com (Jim Lemon)
Date: Wed, 2 Feb 2022 09:19:35 +1100
Subject: [R] Survey design for multilevel analysis
In-Reply-To: <CAOTqx+KtV1_WOtffzuZJetE=JFKqVDqV8O15aUs0vBFZa1yyeQ@mail.gmail.com>
References: <CAOTqx+KtV1_WOtffzuZJetE=JFKqVDqV8O15aUs0vBFZa1yyeQ@mail.gmail.com>
Message-ID: <CA+8X3fUCk5FYbXOpTWLnFS3tzf7pSx4DvQrGHa0RcCRgTKJ4Tw@mail.gmail.com>

Hi Love,
I have finally had a chance to look at this more closely. I think that
the following link:

https://cran.r-project.org/web/packages/survival/vignettes/adjcurve.pdf

may be useful. See section 4.2.
This is not my area of expertise, but it seems to be a known problem.
Perhaps by posting to the:

R-SGI-Epi

mailing list you will get responses from specialists in the field.

Jim

On Tue, Feb 1, 2022 at 9:02 PM Love Umesi <yugohlav at gmail.com> wrote:
>
> I am new in using R, and I need to run a multilevel analysis (two-phase
> design on two levels) using Cox frailty survival model on a survey data
> (Nigeria Demographic and Health Survey Data).
>
> My problem is how to write the design weight using the two weights needed
> and apply them to the analysis.
>
> I have identified the needed variables for the survey design, which
> are : psu/cluster=
> v021 individual-level weight= wt1_1 cluster-level weigh= wt2_1 strata/stratum=
> v022
>
> Please can someone help me with the survey design (svydesign) code and how
> to include it and the weights in a model.
>
> I understand I have to use svycoxph in the model. Please how do I include
> survey design and account for the 2 weights (individual-level and
> cluster-level weights) in the gamma frailty model below?
>
> Frailty1 <- coxph (Surv(study_time, died) ~ factor(v024) + factor(mat_edu)
> + v025 + frailty(v021,distribution="gamma"), data=rcom2018)
>
> Really looking forward to your help as my project is hanging on this.
>
> Many thanks.
>
>
> library(survival)#> Warning: package 'survival' was built under R version 4.0.5
> library(frailtypack)#> Warning: package 'frailtypack' was built under
> R version 4.0.5#> Loading required package: boot#> #> Attaching
> package: 'boot'#> The following object is masked from
> 'package:survival':#> #>     aml#> Loading required package: MASS#>
> Loading required package: survC1#> Warning: package 'survC1' was built
> under R version 4.0.5#> Loading required package: doBy#> Warning:
> package 'doBy' was built under R version 4.0.5#> #> Attaching package:
> 'frailtypack'#> The following object is masked from
> 'package:survival':#> #>     cluster
>
>
> rcom1 <- data.frame(
>   data.frame(
>     pid = c(
>       1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
>       14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
>       30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,
>       46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
>       61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
>       77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92,
>       93, 94, 95, 96, 97, 98, 99, 100
>     ),
>     study_time = c(
>       13, 9, 17, 31, 39, 22, 24, 0, 23, 12, 9, 35,
>       18, 20, 60, 18, 5, 46, 26, 54, 37, 51, 31, 55, 27, 15, 39, 6,
>       29, 0, 9, 40, 23, 12, 35, 56, 14, 40, 57, 42, 5, 42, 39, 39,
>       54, 19, 52, 42, 7, 28, 53, 5, 28, 13, 37, 0, 23, 33, 27, 36, 20,
>       24, 58, 34, 12, 44, 3, 34, 14, 5, 10, 40, 12, 36, 19, 58, 17,
>       40, 39, 58, 53, 53, 1, 50, 2, 28, 24, 13, 13, 50, 46, 46, 19, 6,
>       32, 59, 9, 30, 30, 43
>     ),
>     died = c(
>       0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
>       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
>       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0,
>       0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
>       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
>       0
>     ),
>     v021 = c(
>       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
>       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3,
>       3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4,
>       4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
>       5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
>       6
>     ),
>     v022 = c(
>       "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "2", "2", "2", "2", "2", "2", "2",
>       "2", "2", "2"
>     ),
>     v012 = c(
>       40, 37, 27, 27, 24, 32, 35, 35, 34, 20, 28,
>       28, 26, 24, 24, 25, 26, 26, 26, 26, 28, 27, 25, 25, 27, 26, 26,
>       21, 21, 31, 36, 36, 27, 23, 32, 32, 33, 33, 33, 28, 25, 37,
>       33, 34, 33, 28, 28, 29, 33, 33, 33, 39, 38, 38, 38, 38, 24, 27,
>       35, 40, 22, 38, 38, 21, 30, 30, 30, 39, 43, 18, 23, 23, 25, 25,
>       30, 45, 26, 26, 35, 35, 35, 35, 32, 32, 40, 25, 27, 30, 30, 30,
>       28, 28, 18, 27, 30, 30, 27, 21, 21, 30
>     ),
>     wt2_1 = c(
>       401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031,
>       401.200012207031, 401.200012207031, 401.200012207031, 401.200012207031,
>       631.818176269531, 631.818176269531, 631.818176269531,
>       631.818176269531, 631.818176269531, 631.818176269531, 631.818176269531,
>       631.818176269531, 631.818176269531, 631.818176269531
>     ),
>     wt1_1 = c(
>       2.5074667930603, 2.5074667930603,
>       2.5074667930603, 2.5074667930603, 2.5074667930603, 2.5074667930603,
>       2.5074667930603, 2.5074667930603, 2.5074667930603, 2.5074667930603,
>       2.5074667930603, 2.5074667930603, 2.5074667930603,
>       2.5074667930603, 2.5074667930603, 5.1194109916687, 5.1194109916687,
>       5.1194109916687, 5.1194109916687, 5.1194109916687, 5.1194109916687,
>       5.1194109916687, 5.1194109916687, 5.1194109916687,
>       5.1194109916687, 5.1194109916687, 5.1194109916687, 5.1194109916687,
>       5.1194109916687, 5.1194109916687, 5.1194109916687, 5.1194109916687,
>       5.1194109916687, 5.1194109916687, 2.40910983085632,
>       2.40910983085632, 2.40910983085632, 2.40910983085632, 2.40910983085632,
>       2.40910983085632, 2.40910983085632, 2.40910983085632,
>       2.40910983085632, 2.40910983085632, 2.40910983085632, 2.40910983085632,
>       2.40910983085632, 2.40910983085632, 1.06203985214233,
>       1.06203985214233, 1.06203985214233, 1.06203985214233, 1.06203985214233,
>       1.06203985214233, 1.06203985214233, 1.06203985214233,
>       1.06203985214233, 1.06203985214233, 1.06203985214233, 1.06203985214233,
>       1.06203985214233, 1.06203985214233, 1.06203985214233,
>       1.06203985214233, 1.06203985214233, 1.06203985214233, 1.06203985214233,
>       2.80098295211792, 2.80098295211792, 2.80098295211792,
>       2.80098295211792, 2.80098295211792, 2.80098295211792, 2.80098295211792,
>       2.80098295211792, 2.80098295211792, 2.80098295211792,
>       2.80098295211792, 2.80098295211792, 2.80098295211792, 2.80098295211792,
>       2.80098295211792, 2.80098295211792, 2.80098295211792,
>       2.80098295211792, 2.80098295211792, 2.80098295211792, 2.80098295211792,
>       2.80098295211792, 2.80098295211792, 1.24210178852081,
>       1.24210178852081, 1.24210178852081, 1.24210178852081, 1.24210178852081,
>       1.24210178852081, 1.24210178852081, 1.24210178852081,
>       1.24210178852081, 1.24210178852081
>     ),
>     v024 = c(
>       "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1"
>     ),
>     v025 = c(
>       "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1",
>       "1", "1", "1", "1", "1", "1", "2", "2", "2", "2", "2", "2", "2",
>       "2", "2", "2"
>     ),
>     mat_edu = c(
>       "5", "5", "5", "4", "4", "5", "4", "4", "4",
>       "4", "4", "4", "5", "5", "5", "5", "5", "5", "4", "4", "5",
>       "4", "4", "4", "5", "3", "3", "4", "4", "5", "5", "5", "5", "4",
>       "2", "2", "0", "0", "0", "5", "5", "0", "1", "5", "5", "3",
>       "3", "5", "5", "5", "5", "5", "5", "5", "5", "5", "5", "4", "5",
>       "5", "4", "5", "5", "3", "4", "4", "5", "3", "1", "3", "3", "3",
>       "1", "3", "2", "1", "3", "3", "4", "4", "0", "0", "2", "2",
>       "1", "0", "4", "4", "4", "4", "0", "0", "3", "4", "2", "2", "3",
>       "3", "3", "0"
>     )
>   ))
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From @v|gro@@ @end|ng |rom ver|zon@net  Wed Feb  2 02:42:12 2022
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Wed, 2 Feb 2022 01:42:12 +0000 (UTC)
Subject: [R] [External]  Funky calculations
In-Reply-To: <D24231AD-5CBF-4595-962E-2009821BD20B@temple.edu>
References: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
 <20220201193557.308209e8@Tarkus>
 <D24231AD-5CBF-4595-962E-2009821BD20B@temple.edu>
Message-ID: <1240726547.2663210.1643766132419@mail.yahoo.com>

Richard,

I think it was fairly clear I was explaining how people do arithmetic manually and often truncate or round to some number of decimal places. I said nothing about what R does or what the IEEE standards say and I do not particularly care when making MY point.

My point is that humans before computers also had trouble writing down any decimals that continue indefinitely. It cannot be expected computer versions of arithmetic can do much better. Different people can opt to do the calculation with the same or different numbers of digits ad when compared to each other they may not match.

I do care what it does in my programs, of course. My goal here was to explain to someone that the anomaly found was not really an anomaly and that careful coding may be required in these situations.


-----Original Message-----
From: Richard M. Heiberger <rmh at temple.edu>
To: Avi Gross <avigross at verizon.net>
Cc: Nathan Boeger <nboeger at gmail.com>; r-help at r-project.org <r-help at r-project.org>
Sent: Tue, Feb 1, 2022 2:44 pm
Subject: Re: [External] [R] Funky calculations


RShowDoc('FAQ') 


then search for 7.31


This statement
"If you stop at a 5 or 7 or 8 and back up to the previous digit, you round up. Else you leave the previous result alone."
is not quite right.? The recommendation in IEEE 754, and this is how R does arithmetic, is to Round Even.

I ilustrate here with decimal, even though R and other programs use binary.

> x <- c(1.4, 1.5, 1.6, 2.4, 2.5, 2.6, 3.4, 3.5, 3.6, 4.4, 4.5, 4.6)
> r <- round(x)
> cbind(x, r)
? ? ? ? x r
 [1,] 1.4 1
 [2,] 1.5 2
 [3,] 1.6 2
 [4,] 2.4 2
 [5,] 2.5 2
 [6,] 2.6 3
 [7,] 3.4 3
 [8,] 3.5 4
 [9,] 3.6 4
[10,] 4.4 4
[11,] 4.5 4
[12,] 4.6 5
> 

Numbers whose last digit is not 5 (when in decimal) round to the nearest integer.
Numbers who last digit is 5 (1.5, 2.5, 3.5, 4.5 above) 
round to the nearest EVEN integer.
Hence 1.5 and 3.5 round up to the even numbers 2 and 4.
2.5 and 4.5 round down do the even numbers 2 and 4.

This way the round ups and downs average out to 0.? If we always went up from .5 we would have
an updrift over time.

For even more detail click on the link in FAQ 7.31 to my appendix
https:// link.springer.com/content/pdf/bbm%3A978-1-4939-2122-5%2F1.pdf
and search for "Appendix G".

Section G.5 explains Round to Even.
Sections G.6 onward illustrate specific examples, such as the one that started this email thread.

Rich
 


From rmh @end|ng |rom temp|e@edu  Wed Feb  2 03:04:45 2022
From: rmh @end|ng |rom temp|e@edu (Richard M. Heiberger)
Date: Wed, 2 Feb 2022 02:04:45 +0000
Subject: [R] [External]  Funky calculations
In-Reply-To: <1240726547.2663210.1643766132419@mail.yahoo.com>
References: <CAFxA6QotuTYyJ8Jz_9SeeGZNR_LRxCXHKXYO+o3JihnQdnQL+g@mail.gmail.com>
 <20220201193557.308209e8@Tarkus>
 <D24231AD-5CBF-4595-962E-2009821BD20B@temple.edu>
 <1240726547.2663210.1643766132419@mail.yahoo.com>
Message-ID: <1A13EFE0-C500-40D0-9BD0-8546E4EECBEA@temple.edu>

I apologize if my tone came across wrong.  I enjoy reading your comments on this list.

My goal was to describe what the IEEE and R interpret "careful coding" to be.

> On Feb 01, 2022, at 20:42, Avi Gross <avigross at verizon.net> wrote:
> 
> Richard,
> 
> I think it was fairly clear I was explaining how people do arithmetic manually and often truncate or round to some number of decimal places. I said nothing about what R does or what the IEEE standards say and I do not particularly care when making MY point.
> 
> My point is that humans before computers also had trouble writing down any decimals that continue indefinitely. It cannot be expected computer versions of arithmetic can do much better. Different people can opt to do the calculation with the same or different numbers of digits ad when compared to each other they may not match.
> 
> I do care what it does in my programs, of course. My goal here was to explain to someone that the anomaly found was not really an anomaly and that careful coding may be required in these situations.
> 
> 
> -----Original Message-----
> From: Richard M. Heiberger <rmh at temple.edu>
> To: Avi Gross <avigross at verizon.net>
> Cc: Nathan Boeger <nboeger at gmail.com>; r-help at r-project.org <r-help at r-project.org>
> Sent: Tue, Feb 1, 2022 2:44 pm
> Subject: Re: [External] [R] Funky calculations
> 
> 
> RShowDoc('FAQ') 
> 
> 
> then search for 7.31
> 
> 
> This statement
> "If you stop at a 5 or 7 or 8 and back up to the previous digit, you round up. Else you leave the previous result alone."
> is not quite right.  The recommendation in IEEE 754, and this is how R does arithmetic, is to Round Even.
> 
> I ilustrate here with decimal, even though R and other programs use binary.
> 
>> x <- c(1.4, 1.5, 1.6, 2.4, 2.5, 2.6, 3.4, 3.5, 3.6, 4.4, 4.5, 4.6)
>> r <- round(x)
>> cbind(x, r)
>         x r
> [1,] 1.4 1
> [2,] 1.5 2
> [3,] 1.6 2
> [4,] 2.4 2
> [5,] 2.5 2
> [6,] 2.6 3
> [7,] 3.4 3
> [8,] 3.5 4
> [9,] 3.6 4
> [10,] 4.4 4
> [11,] 4.5 4
> [12,] 4.6 5
>> 
> 
> Numbers whose last digit is not 5 (when in decimal) round to the nearest integer.
> Numbers who last digit is 5 (1.5, 2.5, 3.5, 4.5 above) 
> round to the nearest EVEN integer.
> Hence 1.5 and 3.5 round up to the even numbers 2 and 4.
> 2.5 and 4.5 round down do the even numbers 2 and 4.
> 
> This way the round ups and downs average out to 0.  If we always went up from .5 we would have
> an updrift over time.
> 
> For even more detail click on the link in FAQ 7.31 to my appendix
> https:// link.springer.com/content/pdf/bbm%3A978-1-4939-2122-5%2F1.pdf
> and search for "Appendix G".
> 
> Section G.5 explains Round to Even.
> Sections G.6 onward illustrate specific examples, such as the one that started this email thread.
> 
> Rich
> 


